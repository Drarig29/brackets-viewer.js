/*
 * ATTENTION: The "eval" devtool has been used (maybe by default in mode: "development").
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
/******/ (() => { // webpackBootstrap
/******/ 	var __webpack_modules__ = ({

/***/ "./src/main.ts":
/*!*********************!*\
  !*** ./src/main.ts ***!
  \*********************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";
eval("\n\nvar __importDefault = this && this.__importDefault || function (mod) {\n  return mod && mod.__esModule ? mod : {\n    \"default\": mod\n  };\n};\n\nObject.defineProperty(exports, \"__esModule\", ({\n  value: true\n}));\n\nconst braketsViewer_1 = __importDefault(__webpack_require__(/*! ./viewer/braketsViewer */ \"./src/viewer/braketsViewer.ts\"));\n\nconst inMemoryDatabase_1 = __importDefault(__webpack_require__(/*! ./manager/inMemoryDatabase */ \"./src/manager/inMemoryDatabase.ts\"));\n\nconst brackets_manager_1 = __webpack_require__(/*! brackets-manager */ \"./node_modules/brackets-manager/dist/index.js\");\n\nwindow.bracketsViewer = new braketsViewer_1.default();\nwindow.inMemoryDatabase = new inMemoryDatabase_1.default();\nwindow.bracketsManager = new brackets_manager_1.BracketsManager(window.inMemoryDatabase);\n\n//# sourceURL=webpack://brackets-viewer/./src/main.ts?");

/***/ }),

/***/ "./src/manager/inMemoryDatabase.ts":
/*!*****************************************!*\
  !*** ./src/manager/inMemoryDatabase.ts ***!
  \*****************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";
eval("\n\nObject.defineProperty(exports, \"__esModule\", ({\n  value: true\n}));\n\nclass InMemoryDatabase {\n  constructor() {\n    this.data = {\n      participant: [],\n      stage: [],\n      group: [],\n      round: [],\n      match: [],\n      match_game: []\n    };\n  }\n  /**\n   * @param data \"import\" data from external\n   */\n\n\n  setData(data) {\n    this.data = data;\n  }\n\n  makeFilter(partial) {\n    return entry => {\n      let result = true;\n\n      for (const [key, value] of Object.entries(partial)) {\n        result = result && entry[key] === value;\n      }\n\n      return result;\n    };\n  }\n  /**\n   * Clearing all of the data\n   */\n\n\n  reset() {\n    this.data = {\n      participant: [],\n      stage: [],\n      group: [],\n      round: [],\n      match: [],\n      match_game: []\n    };\n  }\n  /**\n   * Implementation of insert\n   *\n   * @param table Where to insert.\n   * @param values What to insert.\n   */\n\n\n  insert(table, values) {\n    let id;\n    id = this.data[table].length;\n\n    if (!Array.isArray(values)) {\n      try {\n        // eslint-disable-next-line @typescript-eslint/ban-ts-comment\n        // @ts-ignore\n        this.data[table].push({\n          id,\n          ...values\n        });\n      } catch (error) {\n        return new Promise(resolve => {\n          resolve(-1);\n        });\n      }\n\n      return new Promise(resolve => {\n        resolve(id);\n      });\n    }\n\n    try {\n      values.map(object => {\n        // eslint-disable-next-line @typescript-eslint/ban-ts-comment\n        // @ts-ignore\n        this.data[table].push({\n          id: id++,\n          ...object\n        });\n      });\n    } catch (error) {\n      return new Promise(resolve => {\n        resolve(false);\n      });\n    }\n\n    return new Promise(resolve => {\n      resolve(true);\n    });\n  }\n  /**\n   * @param table Where to get from.\n   * @param arg\n   */\n\n\n  select(table, arg) {\n    try {\n      if (arg === undefined) {\n        return new Promise(resolve => {\n          // eslint-disable-next-line @typescript-eslint/ban-ts-comment\n          // @ts-ignore\n          resolve(this.data[table]);\n        });\n      }\n\n      if (typeof arg === 'number') {\n        return new Promise(resolve => {\n          // eslint-disable-next-line @typescript-eslint/ban-ts-comment\n          // @ts-ignore\n          resolve(this.data[table][arg]);\n        });\n      }\n\n      return new Promise(resolve => {\n        // eslint-disable-next-line @typescript-eslint/ban-ts-comment\n        // @ts-ignore\n        resolve(this.data[table].filter(this.makeFilter(arg)) || null);\n      });\n    } catch (error) {\n      return new Promise(resolve => {\n        resolve(null);\n      });\n    }\n  }\n  /**\n   * Updates data in a table.\n   *\n   * @param table Where to update.\n   * @param arg\n   * @param value How to update.\n   */\n\n\n  update(table, arg, value) {\n    if (typeof arg === 'number') {\n      try {\n        // eslint-disable-next-line @typescript-eslint/ban-ts-comment\n        // @ts-ignore\n        this.data[table][arg] = value;\n        return new Promise(resolve => {\n          resolve(true);\n        });\n      } catch (error) {\n        return new Promise(resolve => {\n          resolve(false);\n        });\n      }\n    } // eslint-disable-next-line @typescript-eslint/ban-ts-comment\n    // @ts-ignore\n\n\n    const values = this.data[table].filter(this.makeFilter(arg));\n\n    if (!values) {\n      return new Promise(resolve => {\n        resolve(false);\n      });\n    }\n\n    values.forEach(v => {\n      const existing = this.data[table][v.id];\n\n      for (const key in value) {\n        // eslint-disable-next-line @typescript-eslint/ban-ts-comment\n        // @ts-ignore\n        existing[key] = value[key];\n      }\n\n      this.data[table][v.id] = existing;\n    });\n    return new Promise(resolve => {\n      resolve(true);\n    });\n  }\n  /**\n   * Delete data in a table, based on a filter.\n   *\n   * @param table Where to delete in.\n   * @param filter An object to filter data.\n   */\n\n\n  delete(table, filter) {\n    const values = this.data[table];\n\n    if (!values) {\n      return new Promise(resolve => {\n        resolve(false);\n      });\n    }\n\n    const predicate = this.makeFilter(filter);\n\n    const negativeFilter = value => !predicate(value); // eslint-disable-next-line @typescript-eslint/ban-ts-comment\n    // @ts-ignore\n\n\n    this.data[table] = values.filter(negativeFilter);\n    return new Promise(resolve => {\n      resolve(true);\n    });\n  }\n\n}\n\nexports.default = InMemoryDatabase;\n\n//# sourceURL=webpack://brackets-viewer/./src/manager/inMemoryDatabase.ts?");

/***/ }),

/***/ "./src/viewer/braketsViewer.ts":
/*!*************************************!*\
  !*** ./src/viewer/braketsViewer.ts ***!
  \*************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";
eval("\n\nvar __createBinding = this && this.__createBinding || (Object.create ? function (o, m, k, k2) {\n  if (k2 === undefined) k2 = k;\n  Object.defineProperty(o, k2, {\n    enumerable: true,\n    get: function () {\n      return m[k];\n    }\n  });\n} : function (o, m, k, k2) {\n  if (k2 === undefined) k2 = k;\n  o[k2] = m[k];\n});\n\nvar __setModuleDefault = this && this.__setModuleDefault || (Object.create ? function (o, v) {\n  Object.defineProperty(o, \"default\", {\n    enumerable: true,\n    value: v\n  });\n} : function (o, v) {\n  o[\"default\"] = v;\n});\n\nvar __importStar = this && this.__importStar || function (mod) {\n  if (mod && mod.__esModule) return mod;\n  var result = {};\n  if (mod != null) for (var k in mod) if (k !== \"default\" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);\n\n  __setModuleDefault(result, mod);\n\n  return result;\n};\n\nObject.defineProperty(exports, \"__esModule\", ({\n  value: true\n}));\n\n__webpack_require__(/*! ./style.scss */ \"./src/viewer/style.scss\");\n\nconst brackets_model_1 = __webpack_require__(/*! brackets-model */ \"./node_modules/brackets-model/dist/index.js\");\n\nconst helpers_1 = __webpack_require__(/*! ./helpers */ \"./src/viewer/helpers.ts\");\n\nconst dom = __importStar(__webpack_require__(/*! ./dom */ \"./src/viewer/dom.ts\"));\n\nconst lang = __importStar(__webpack_require__(/*! ./lang */ \"./src/viewer/lang.ts\"));\n\nclass BracketsViewer {\n  constructor() {\n    this.participantRefs = {};\n    this.participants = [];\n    this.participantImages = [];\n    this.skipFirstRound = false;\n    this.alwaysConnectFirstRound = false;\n\n    this.onMatchClicked = _ => {};\n  }\n  /**\n   * Renders data generated with `brackets-manager.js`. If multiple stages are given, they will all be displayed.\n   *\n   * Stages won't be discriminated visually based on the tournament they belong to.\n   *\n   * @param data The data to display.\n   * @param config An optional configuration for the viewer.\n   */\n\n\n  render(data, config) {\n    const root = document.createDocumentFragment();\n    this.config = {\n      participantOriginPlacement: (config === null || config === void 0 ? void 0 : config.participantOriginPlacement) || 'before',\n      separatedChildCountLabel: (config === null || config === void 0 ? void 0 : config.separatedChildCountLabel) !== undefined ? config.separatedChildCountLabel : false,\n      showSlotsOrigin: (config === null || config === void 0 ? void 0 : config.showSlotsOrigin) !== undefined ? config.showSlotsOrigin : true,\n      showLowerBracketSlotsOrigin: (config === null || config === void 0 ? void 0 : config.showLowerBracketSlotsOrigin) !== undefined ? config.showLowerBracketSlotsOrigin : true,\n      highlightParticipantOnHover: (config === null || config === void 0 ? void 0 : config.highlightParticipantOnHover) !== undefined ? config.highlightParticipantOnHover : true\n    };\n    this.participants = data.participants;\n    data.participants.forEach(participant => this.participantRefs[participant.id] = []);\n    data.stages.forEach(stage => this.renderStage(root, { ...data,\n      stages: [stage],\n      matches: data.matches.filter(match => match.stage_id === stage.id)\n    }));\n    helpers_1.findRoot(config === null || config === void 0 ? void 0 : config.selector).append(root);\n  }\n  /**\n   * Sets the images which will be rendered for every participant.\n   *\n   * @param images The participant images.\n   */\n\n\n  setParticipantImages(images) {\n    this.participantImages = images;\n  }\n  /**\n   * Renders a stage (round-robin, single or double elimination).\n   *\n   * @param root The root element.\n   * @param data The data to display.\n   */\n\n\n  renderStage(root, data) {\n    const stage = data.stages[0];\n    const matchesByGroup = helpers_1.splitBy(data.matches, 'group_id');\n    this.skipFirstRound = stage.settings.skipFirstRound || false;\n\n    switch (stage.type) {\n      case 'round_robin':\n        this.renderRoundRobin(root, stage, matchesByGroup);\n        break;\n\n      case 'single_elimination':\n      case 'double_elimination':\n        this.renderElimination(root, stage, matchesByGroup);\n        break;\n\n      default:\n        throw Error(`Unknown bracket type: ${stage.type}`);\n    }\n  }\n  /**\n   * Renders a round-robin stage.\n   *\n   * @param root The root element.\n   * @param stage The stage to render.\n   * @param matchesByGroup A list of matches for each group.\n   */\n\n\n  renderRoundRobin(root, stage, matchesByGroup) {\n    const container = dom.createRoundRobinContainer(stage.id);\n    container.append(dom.createTitle(stage.name));\n    let groupNumber = 1;\n\n    for (const groupMatches of matchesByGroup) {\n      const groupId = groupMatches[0].group_id;\n      const groupContainer = dom.createGroupContainer(groupId, lang.getGroupName(groupNumber++));\n      const matchesByRound = helpers_1.splitBy(groupMatches, 'round_id');\n      let roundNumber = 1;\n\n      for (const roundMatches of matchesByRound) {\n        const roundId = roundMatches[0].round_id;\n        const roundContainer = dom.createRoundContainer(roundId, lang.getRoundName(roundNumber++, 0));\n\n        for (const match of roundMatches) roundContainer.append(this.createMatch(match));\n\n        groupContainer.append(roundContainer);\n      }\n\n      groupContainer.append(this.createRanking(groupMatches));\n      container.append(groupContainer);\n    }\n\n    root.append(container);\n  }\n  /**\n   * Renders an elimination stage (single or double).\n   *\n   * @param root The root element.\n   * @param stage The stage to render.\n   * @param matchesByGroup A list of matches for each group.\n   */\n\n\n  renderElimination(root, stage, matchesByGroup) {\n    const container = dom.createEliminationContainer(stage.id);\n    container.append(dom.createTitle(stage.name));\n    if (stage.type === 'single_elimination') this.renderSingleElimination(container, matchesByGroup);else this.renderDoubleElimination(container, matchesByGroup);\n    root.append(container);\n  }\n  /**\n   * Renders a single elimination stage.\n   *\n   * @param container The container to render into.\n   * @param matchesByGroup A list of matches for each group.\n   */\n\n\n  renderSingleElimination(container, matchesByGroup) {\n    const hasFinal = matchesByGroup[1] !== undefined;\n    this.renderBracket(container, helpers_1.splitBy(matchesByGroup[0], 'round_id'), lang.getRoundName, 'single-bracket');\n    if (hasFinal) this.renderFinal(container, 'consolation_final', matchesByGroup[1]);\n  }\n  /**\n   * Renders a double elimination stage.\n   *\n   * @param container The container to render into.\n   * @param matchesByGroup A list of matches for each group.\n   */\n\n\n  renderDoubleElimination(container, matchesByGroup) {\n    const hasLoserBracket = matchesByGroup[1] !== undefined;\n    const hasFinal = matchesByGroup[2] !== undefined;\n    this.renderBracket(container, helpers_1.splitBy(matchesByGroup[0], 'round_id'), lang.getWinnerBracketRoundName, 'winner-bracket', hasFinal);\n    if (hasLoserBracket) this.renderBracket(container, helpers_1.splitBy(matchesByGroup[1], 'round_id'), lang.getLoserBracketRoundName, 'loser-bracket');\n    if (hasFinal) this.renderFinal(container, 'grand_final', matchesByGroup[2]);\n  }\n  /**\n   * Renders a bracket.\n   *\n   * @param container The container to render into.\n   * @param matchesByRound A list of matches for each round.\n   * @param roundName A function giving a round's name based on its number.\n   * @param bracketType Type of the bracket.\n   * @param connectFinal Whether to connect the last match of the bracket to the final.\n   */\n\n\n  renderBracket(container, matchesByRound, roundName, bracketType, connectFinal) {\n    const groupId = matchesByRound[0][0].group_id;\n    const roundCount = matchesByRound.length;\n    const bracketContainer = dom.createBracketContainer(groupId);\n    const {\n      matches: completedMatches,\n      fromToornament\n    } = helpers_1.completeWithBlankMatches(matchesByRound[0], matchesByRound[1], bracketType);\n    this.alwaysConnectFirstRound = !fromToornament;\n\n    for (let roundIndex = 0; roundIndex < matchesByRound.length; roundIndex++) {\n      const roundId = matchesByRound[roundIndex][0].round_id;\n      const roundNumber = roundIndex + 1;\n      const roundContainer = dom.createRoundContainer(roundId, roundName(roundNumber, roundCount));\n      const matches = fromToornament && roundNumber === 1 ? completedMatches : matchesByRound[roundIndex];\n\n      for (const match of matches) roundContainer.append(match && this.createBracketMatch(roundNumber, roundCount, match, bracketType, connectFinal) || this.skipBracketMatch());\n\n      bracketContainer.append(roundContainer);\n    }\n\n    container.append(bracketContainer);\n  }\n  /**\n   * Renders a final group.\n   *\n   * @param container The container to render into.\n   * @param finalType Type of the final.\n   * @param matches Matches of the final.\n   */\n\n\n  renderFinal(container, finalType, matches) {\n    const upperBracket = container.querySelector('.bracket');\n    if (!upperBracket) throw Error('Upper bracket not found.');\n    const winnerWb = matches[0].opponent1;\n    const displayCount = (winnerWb === null || winnerWb === void 0 ? void 0 : winnerWb.id) === null || (winnerWb === null || winnerWb === void 0 ? void 0 : winnerWb.result) === 'win' ? 1 : 2;\n    const finalMatches = matches.slice(0, displayCount);\n    const roundCount = matches.length;\n\n    for (let roundIndex = 0; roundIndex < finalMatches.length; roundIndex++) {\n      const roundNumber = roundIndex + 1;\n      const roundContainer = dom.createRoundContainer(finalMatches[roundIndex].round_id, lang.getFinalMatchLabel(finalType, roundNumber, roundCount));\n      roundContainer.append(this.createFinalMatch(finalType, finalMatches, roundNumber, roundCount));\n      upperBracket.append(roundContainer);\n    }\n  }\n  /**\n   * Creates a ranking table based on matches of a round-robin stage.\n   *\n   * @param matches The list of matches.\n   */\n\n\n  createRanking(matches) {\n    const table = dom.createTable();\n    const ranking = helpers_1.getRanking(matches);\n    table.append(dom.createRankingHeaders(ranking));\n\n    for (const item of ranking) table.append(this.createRankingRow(item));\n\n    return table;\n  }\n  /**\n   * Creates a row of the ranking table.\n   *\n   * @param item Item of the ranking.\n   */\n\n\n  createRankingRow(item) {\n    const row = dom.createRow();\n    const notRanked = item.played === 0;\n\n    for (const key in item) {\n      const prop = key;\n      const data = item[prop];\n\n      if (prop === 'id') {\n        const participant = this.participants.find(participant => participant.id === data);\n\n        if (participant !== undefined) {\n          const cell = dom.createCell(participant.name);\n          this.setupMouseHover(participant.id, cell);\n          row.append(cell);\n          continue;\n        }\n      }\n\n      if (notRanked && (prop === 'rank' || prop === 'points')) {\n        row.append(dom.createCell('-'));\n        continue;\n      }\n\n      row.append(dom.createCell(data));\n    }\n\n    return row;\n  }\n  /**\n   * Creates a match in a bracket.\n   *\n   * @param roundNumber Number of the round.\n   * @param roundCount Count of rounds.\n   * @param match Information about the match.\n   * @param matchLocation Location of the match.\n   * @param connectFinal Whether to connect this match to the final if it happens to be the last one of the bracket.\n   */\n\n\n  createBracketMatch(roundNumber, roundCount, match, matchLocation, connectFinal) {\n    const connection = dom.getBracketConnection(this.alwaysConnectFirstRound, roundNumber, roundCount, match, matchLocation, connectFinal);\n    const matchLabel = lang.getMatchLabel(match.number, roundNumber, roundCount, matchLocation) + (match.child_count > 0 ? `, Bo${match.child_count}` : '');\n    const originHint = lang.getOriginHint(roundNumber, roundCount, this.skipFirstRound, matchLocation);\n    return this.createMatch(match, matchLocation, connection, matchLabel, originHint, roundNumber);\n  }\n  /**\n   * Creates a match in a final.\n   *\n   * @param type Type of the final.\n   * @param matches Matches of the final.\n   * @param roundNumber Number of the round.\n   * @param roundCount Count of rounds.\n   */\n\n\n  createFinalMatch(type, matches, roundNumber, roundCount) {\n    const roundIndex = roundNumber - 1;\n    const connection = dom.getFinalConnection(type, roundNumber, matches.length);\n    const matchLabel = lang.getFinalMatchLabel(type, roundNumber, roundCount);\n    const originHint = lang.getFinalOriginHint(type, roundNumber);\n    return this.createMatch(matches[roundIndex], 'final-group', connection, matchLabel, originHint);\n  }\n  /**\n   * Creates a hidden empty match to act as a placeholder.\n   */\n\n\n  skipBracketMatch() {\n    const matchContainer = dom.createMatchContainer();\n    const opponents = dom.createOpponentsContainer();\n    const participant1 = this.createParticipant(null);\n    const participant2 = this.createParticipant(null);\n    opponents.append(participant1, participant2);\n    matchContainer.append(opponents);\n    matchContainer.style.visibility = 'hidden';\n    return matchContainer;\n  }\n  /**\n   * Creates a match based on its results.\n   *\n   * @param match Results of the match.\n   * @param matchLocation Location of the match.\n   * @param connection Connection of this match with the others.\n   * @param label Label of the match.\n   * @param originHint Origin hint for the match.\n   * @param roundNumber Number of the round.\n   */\n\n\n  createMatch(match, matchLocation, connection, label, originHint, roundNumber) {\n    const matchContainer = dom.createMatchContainer(match.id, match.status);\n    const opponents = dom.createOpponentsContainer(() => this.onMatchClicked(match));\n    if (match.status >= brackets_model_1.Status.Completed) originHint = undefined;\n    const participant1 = this.createParticipant(match.opponent1, 'opponent1', originHint, matchLocation, roundNumber);\n    const participant2 = this.createParticipant(match.opponent2, 'opponent2', originHint, matchLocation, roundNumber);\n    if (label) opponents.append(dom.createMatchLabel(label, lang.getMatchStatus(match.status)));\n    if (match.child_count > 0 && this.config.separatedChildCountLabel) opponents.append(dom.createChildCountLabel(lang.bestOfX(match.child_count)));\n    opponents.append(participant1, participant2);\n    matchContainer.append(opponents);\n    if (!connection) return matchContainer;\n    dom.setupConnection(opponents, matchContainer, connection);\n    return matchContainer;\n  }\n  /**\n   * Creates a participant for a match.\n   *\n   * @param participant Information about the participant.\n   * @param side Side of the participant.\n   * @param originHint Origin hint for the match.\n   * @param matchLocation Location of the match.\n   * @param roundNumber Number of the round.\n   */\n\n\n  createParticipant(participant, side, originHint, matchLocation, roundNumber) {\n    const containers = {\n      participant: dom.createParticipantContainer(participant && participant.id),\n      name: dom.createNameContainer(),\n      result: dom.createResultContainer()\n    };\n    if (participant === null || participant === undefined) containers.name.innerText = lang.BYE;else this.renderParticipant(containers, participant, side, originHint, matchLocation, roundNumber);\n    containers.participant.append(containers.name, containers.result);\n    if (participant && participant.id !== null) this.setupMouseHover(participant.id, containers.participant);\n    return containers.participant;\n  }\n  /**\n   * Renders a participant.\n   *\n   * @param containers Containers for the participant.\n   * @param participant The participant result.\n   * @param side Side of the participant.\n   * @param originHint Origin hint for the match.\n   * @param matchLocation Location of the match.\n   * @param roundNumber Number of the round.\n   */\n\n\n  renderParticipant(containers, participant, side, originHint, matchLocation, roundNumber) {\n    const found = this.participants.find(item => item.id === participant.id);\n\n    if (found) {\n      containers.name.innerText = found.name;\n      containers.participant.setAttribute('title', found.name);\n      this.renderParticipantImage(containers.name, found.id);\n      this.renderParticipantOrigin(containers.name, participant, side, matchLocation, roundNumber);\n    } else this.renderHint(containers.name, participant, originHint, matchLocation);\n\n    containers.result.innerText = `${participant.score === undefined ? '-' : participant.score}`;\n    dom.setupWin(containers.participant, containers.result, participant);\n    dom.setupLoss(containers.participant, containers.result, participant);\n  }\n  /**\n   * Renders a participant image.\n   *\n   * @param nameContainer The name container.\n   * @param participantId ID of the participant.\n   */\n\n\n  renderParticipantImage(nameContainer, participantId) {\n    const found = this.participantImages.find(item => item.participantId === participantId);\n    if (found) dom.addParticipantImage(nameContainer, found.imageUrl);\n  }\n  /**\n   * Renders an origin hint for a participant.\n   *\n   * @param nameContainer The name container.\n   * @param participant The participant result.\n   * @param originHint Origin hint for the participant.\n   * @param matchLocation Location of the match.\n   */\n\n\n  renderHint(nameContainer, participant, originHint, matchLocation) {\n    if (originHint === undefined || participant.position === undefined) return;\n    if (!this.config.showSlotsOrigin) return;\n    if (!this.config.showLowerBracketSlotsOrigin && matchLocation === 'loser-bracket') return;\n    dom.setupHint(nameContainer, originHint(participant.position));\n  }\n  /**\n   * Renders a participant's origin.\n   *\n   * @param nameContainer The name container.\n   * @param participant The participant result.\n   * @param side Side of the participant.Side of the participant.\n   * @param matchLocation Location of the match.\n   * @param roundNumber Number of the round.\n   */\n\n\n  renderParticipantOrigin(nameContainer, participant, side, matchLocation, roundNumber) {\n    if (participant.position === undefined || matchLocation === undefined) return;\n    if (!this.config.participantOriginPlacement || this.config.participantOriginPlacement === 'none') return;\n    if (!this.config.showSlotsOrigin) return;\n    if (!this.config.showLowerBracketSlotsOrigin && matchLocation === 'loser-bracket') return;\n    const abbreviation = helpers_1.getOriginAbbreviation(matchLocation, this.skipFirstRound, roundNumber, side);\n    if (!abbreviation) return;\n    const origin = abbreviation + participant.position;\n    dom.addParticipantOrigin(nameContainer, origin, this.config.participantOriginPlacement);\n  }\n  /**\n   * Sets mouse hover events for a participant.\n   *\n   * @param participantId ID of the participant.\n   * @param element The dom element to add events to.\n   */\n\n\n  setupMouseHover(participantId, element) {\n    if (!this.config.highlightParticipantOnHover) return;\n    const refs = this.participantRefs[participantId];\n    if (!refs) throw Error(`The participant (id: ${participantId}) does not exist in the participants table.`);\n    refs.push(element); // https://flaviocopes.com/how-to-add-event-listener-multiple-elements-javascript/\n    // Use bubbling to have only one callback\n\n    element.addEventListener('mouseover', () => {\n      refs.forEach(el => el.classList.add('hover'));\n    });\n    element.addEventListener('mouseleave', () => {\n      refs.forEach(el => el.classList.remove('hover'));\n    });\n  }\n\n}\n\nexports.default = BracketsViewer;\n\n//# sourceURL=webpack://brackets-viewer/./src/viewer/braketsViewer.ts?");

/***/ }),

/***/ "./src/viewer/dom.ts":
/*!***************************!*\
  !*** ./src/viewer/dom.ts ***!
  \***************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("\n\nObject.defineProperty(exports, \"__esModule\", ({\n  value: true\n}));\nexports.setupConnection = exports.getFinalConnection = exports.getBracketConnection = exports.addParticipantImage = exports.addParticipantOrigin = exports.setupLoss = exports.setupWin = exports.setupHint = exports.createRankingHeaders = exports.createCell = exports.createRow = exports.createTable = exports.createResultContainer = exports.createNameContainer = exports.createParticipantContainer = exports.createOpponentsContainer = exports.createChildCountLabel = exports.createMatchLabel = exports.createMatchContainer = exports.createRoundContainer = exports.createGroupContainer = exports.createBracketContainer = exports.createEliminationContainer = exports.createRoundRobinContainer = exports.createTitle = void 0;\n\nconst helpers_1 = __webpack_require__(/*! ./helpers */ \"./src/viewer/helpers.ts\");\n\nconst lang_1 = __webpack_require__(/*! ./lang */ \"./src/viewer/lang.ts\");\n/**\n * Creates the title of the viewer.\n *\n * @param title The title to set.\n */\n\n\nfunction createTitle(title) {\n  const h1 = document.createElement('h1');\n  h1.innerText = title;\n  return h1;\n}\n\nexports.createTitle = createTitle;\n/**\n * Creates a container which contains a round-robin stage.\n *\n * @param stageId ID of the stage.\n */\n\nfunction createRoundRobinContainer(stageId) {\n  const stage = document.createElement('div');\n  stage.classList.add('round-robin');\n  stage.setAttribute('data-stage-id', stageId.toString());\n  return stage;\n}\n\nexports.createRoundRobinContainer = createRoundRobinContainer;\n/**\n * Creates a container which contains an elimination stage.\n *\n * @param stageId ID of the stage.\n */\n\nfunction createEliminationContainer(stageId) {\n  const stage = document.createElement('div');\n  stage.classList.add('elimination');\n  stage.setAttribute('data-stage-id', stageId.toString());\n  return stage;\n}\n\nexports.createEliminationContainer = createEliminationContainer;\n/**\n * Creates a container which contains one bracket of a single or double elimination.\n *\n * @param groupId ID of the group.\n */\n\nfunction createBracketContainer(groupId) {\n  const bracket = document.createElement('section');\n  bracket.classList.add('bracket');\n  bracket.setAttribute('data-group-id', groupId.toString());\n  return bracket;\n}\n\nexports.createBracketContainer = createBracketContainer;\n/**\n * Creates a container which contains a group.\n *\n * @param groupId ID of the group.\n * @param title Title of the group.\n */\n\nfunction createGroupContainer(groupId, title) {\n  const h2 = document.createElement('h2');\n  h2.innerText = title;\n  const group = document.createElement('section');\n  group.classList.add('group');\n  group.setAttribute('data-group-id', groupId.toString());\n  group.append(h2);\n  return group;\n}\n\nexports.createGroupContainer = createGroupContainer;\n/**\n * Creates a container which contains a round.\n *\n * @param roundId ID of the round.\n * @param title Title of the round.\n */\n\nfunction createRoundContainer(roundId, title) {\n  const h3 = document.createElement('h3');\n  h3.innerText = title;\n  const round = document.createElement('article');\n  round.classList.add('round');\n  round.setAttribute('data-round-id', roundId.toString());\n  round.append(h3);\n  return round;\n}\n\nexports.createRoundContainer = createRoundContainer;\n/**\n * Creates a container which contains a match.\n *\n * @param matchId ID of the match.\n * @param status Status of the match.\n */\n\nfunction createMatchContainer(matchId, status) {\n  const match = document.createElement('div');\n  match.classList.add('match');\n  matchId !== undefined && match.setAttribute('data-match-id', matchId.toString());\n  status !== undefined && match.setAttribute('data-match-status', status.toString());\n  return match;\n}\n\nexports.createMatchContainer = createMatchContainer;\n/**\n * Creates a container which contains the label of a match.\n *\n * @param label The label of the match.\n * @param status The status to set as tooltip.\n */\n\nfunction createMatchLabel(label, status) {\n  const span = document.createElement('span');\n  span.innerText = label;\n  span.title = status;\n  return span;\n}\n\nexports.createMatchLabel = createMatchLabel;\n/**\n * Creates a container which contains the child count label of a match.\n *\n * @param label The child count label of the match.\n */\n\nfunction createChildCountLabel(label) {\n  const span = document.createElement('span');\n  span.innerText = label;\n  return span;\n}\n\nexports.createChildCountLabel = createChildCountLabel;\n/**\n * Creates a container which contains the opponents of a match.\n *\n * @param onClick Called when the match is clicked.\n */\n\nfunction createOpponentsContainer(onClick) {\n  const opponents = document.createElement('div');\n  opponents.classList.add('opponents');\n  onClick && opponents.addEventListener('click', onClick);\n  return opponents;\n}\n\nexports.createOpponentsContainer = createOpponentsContainer;\n/**\n * Creates a container which contains a participant.\n *\n * @param participantId ID of the participant.\n */\n\nfunction createParticipantContainer(participantId) {\n  const participant = document.createElement('div');\n  participant.classList.add('participant');\n  if (participantId !== null && participantId !== undefined) participant.setAttribute('data-participant-id', participantId.toString());\n  return participant;\n}\n\nexports.createParticipantContainer = createParticipantContainer;\n/**\n * Creates a container which contains the name of a participant.\n */\n\nfunction createNameContainer() {\n  const name = document.createElement('div');\n  name.classList.add('name');\n  return name;\n}\n\nexports.createNameContainer = createNameContainer;\n/**\n * Creates a container which contains the result of a match for a participant.\n */\n\nfunction createResultContainer() {\n  const result = document.createElement('div');\n  result.classList.add('result');\n  return result;\n}\n\nexports.createResultContainer = createResultContainer;\n/**\n * Creates a table.\n */\n\nfunction createTable() {\n  return document.createElement('table');\n}\n\nexports.createTable = createTable;\n/**\n * Creates a table row.\n */\n\nfunction createRow() {\n  return document.createElement('tr');\n}\n\nexports.createRow = createRow;\n/**\n * Creates a table cell.\n *\n * @param data The data in the cell.\n */\n\nfunction createCell(data) {\n  const td = document.createElement('td');\n  td.innerText = String(data);\n  return td;\n}\n\nexports.createCell = createCell;\n/**\n * Creates the headers for a ranking table.\n *\n * @param ranking The object containing the ranking.\n */\n\nfunction createRankingHeaders(ranking) {\n  const headers = document.createElement('tr');\n  const firstItem = ranking[0];\n\n  for (const key in firstItem) {\n    const prop = key;\n    const header = helpers_1.rankingHeader(prop);\n    const th = document.createElement('th');\n    th.innerText = header.text;\n    th.setAttribute('title', header.tooltip);\n    headers.append(th);\n  }\n\n  return headers;\n}\n\nexports.createRankingHeaders = createRankingHeaders;\n/**\n * Sets a hint on a name container.\n *\n * @param nameContainer The name container.\n * @param hint The hint to set.\n */\n\nfunction setupHint(nameContainer, hint) {\n  nameContainer.classList.add('hint');\n  nameContainer.innerText = hint;\n}\n\nexports.setupHint = setupHint;\n/**\n * Sets a win for a participant.\n *\n * @param participantContainer The participant container.\n * @param resultContainer The result container.\n * @param participant The participant result.\n */\n\nfunction setupWin(participantContainer, resultContainer, participant) {\n  if (participant.result && participant.result === 'win') {\n    participantContainer.classList.add('win');\n    if (participant.score === undefined) resultContainer.innerText = lang_1.abbreviations.win;\n  }\n}\n\nexports.setupWin = setupWin;\n/**\n * Sets a loss for a participant.\n *\n * @param participantContainer The participant container.\n * @param resultContainer The result container.\n * @param participant The participant result.\n */\n\nfunction setupLoss(participantContainer, resultContainer, participant) {\n  if (participant.result && participant.result === 'loss' || participant.forfeit) {\n    participantContainer.classList.add('loss');\n    if (participant.forfeit) resultContainer.innerText = lang_1.abbreviations.forfeit;else if (participant.score === undefined) resultContainer.innerText = lang_1.abbreviations.loss;\n  }\n}\n\nexports.setupLoss = setupLoss;\n/**\n * Adds the participant origin to a name.\n *\n * @param nameContainer The name container.\n * @param text The text to set (origin).\n * @param placement The placement of the participant origin.\n */\n\nfunction addParticipantOrigin(nameContainer, text, placement) {\n  const span = document.createElement('span');\n\n  if (placement === 'before') {\n    span.innerText = `${text} `;\n    nameContainer.prepend(span);\n  } else if (placement === 'after') {\n    span.innerText = ` (${text})`;\n    nameContainer.append(span);\n  }\n}\n\nexports.addParticipantOrigin = addParticipantOrigin;\n/**\n * Adds the participant image to a name.\n *\n * @param nameContainer The name container.\n * @param src Source of the image.\n */\n\nfunction addParticipantImage(nameContainer, src) {\n  const img = document.createElement('img');\n  img.src = src;\n  nameContainer.prepend(img);\n}\n\nexports.addParticipantImage = addParticipantImage;\n/**\n * Returns the connection for a given round in a bracket.\n *\n * @param alwaysConnectFirstRound Whether to always connect the first round with the second round.\n * @param roundNumber Number of the round.\n * @param roundCount Count of rounds.\n * @param match The match to connect to other matches.\n * @param matchLocation Location of the match.\n * @param connectFinal Whether to connect to the final.\n */\n\nfunction getBracketConnection(alwaysConnectFirstRound, roundNumber, roundCount, match, matchLocation, connectFinal) {\n  var _a, _b, _c;\n\n  const connection = {\n    connectPrevious: false,\n    connectNext: false\n  };\n\n  if (matchLocation === 'loser-bracket') {\n    connection.connectPrevious = roundNumber > 1 && (roundNumber % 2 === 1 ? 'square' : 'straight');\n    connection.connectNext = roundNumber < roundCount && (roundNumber % 2 === 0 ? 'square' : 'straight');\n  } else {\n    connection.connectPrevious = roundNumber > 1 && 'square';\n    connection.connectNext = roundNumber < roundCount ? 'square' : connectFinal ? 'straight' : false;\n  }\n\n  if (alwaysConnectFirstRound || roundNumber !== 2) return connection;\n  const upperBracket = matchLocation === 'single-bracket' || matchLocation === 'winner-bracket';\n  if (upperBracket && ((_a = match.opponent1) === null || _a === void 0 ? void 0 : _a.position) === undefined && ((_b = match.opponent2) === null || _b === void 0 ? void 0 : _b.position) === undefined) connection.connectPrevious = false;\n  if (matchLocation === 'loser-bracket' && ((_c = match.opponent2) === null || _c === void 0 ? void 0 : _c.position) === undefined) connection.connectPrevious = false;\n  return connection;\n}\n\nexports.getBracketConnection = getBracketConnection;\n/**\n * Returns the connection for a given round in the final.\n *\n * @param finalType Type of final.\n * @param roundNumber Number of the round.\n * @param matchCount The count of matches.\n */\n\nfunction getFinalConnection(finalType, roundNumber, matchCount) {\n  return {\n    connectPrevious: finalType === 'grand_final' && roundNumber === 1 && 'straight',\n    connectNext: matchCount === 2 && roundNumber === 1 && 'straight'\n  };\n}\n\nexports.getFinalConnection = getFinalConnection;\n/**\n * Sets the connection a match containers.\n *\n * @param opponentsContainer The opponents container.\n * @param matchContainer The match container.\n * @param connection The connection to set.\n */\n\nfunction setupConnection(opponentsContainer, matchContainer, connection) {\n  if (connection.connectPrevious) opponentsContainer.classList.add('connect-previous');\n  if (connection.connectNext) matchContainer.classList.add('connect-next');\n  if (connection.connectPrevious === 'straight') opponentsContainer.classList.add('straight');\n  if (connection.connectNext === 'straight') matchContainer.classList.add('straight');\n}\n\nexports.setupConnection = setupConnection;\n\n//# sourceURL=webpack://brackets-viewer/./src/viewer/dom.ts?");

/***/ }),

/***/ "./src/viewer/helpers.ts":
/*!*******************************!*\
  !*** ./src/viewer/helpers.ts ***!
  \*******************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("\n\nObject.defineProperty(exports, \"__esModule\", ({\n  value: true\n}));\nexports.getRanking = exports.rankingHeader = exports.isMajorRound = exports.getOriginAbbreviation = exports.completeWithBlankMatches = exports.findRoot = exports.splitBy = void 0;\n\nconst lang_1 = __webpack_require__(/*! ./lang */ \"./src/viewer/lang.ts\");\n/**\n * Splits an array based on values of a given key of the objects of the array.\n *\n * @param array The array to split.\n * @param key The key of T.\n */\n\n\nfunction splitBy(array, key) {\n  const obj = Object();\n\n  for (const value of array) {\n    if (!obj[value[key]]) obj[value[key]] = [];\n    obj[value[key]].push(value);\n  }\n\n  return Object.values(obj);\n}\n\nexports.splitBy = splitBy;\n/**\n * Finds the root element\n *\n * @param selector An optional selector to select the root element.\n */\n\nfunction findRoot(selector) {\n  const queryResult = document.querySelectorAll(selector || '.brackets-viewer');\n  if (queryResult.length === 0) throw Error('Root not found. You must have at least one root element.');\n  if (queryResult.length > 1) throw Error('Multiple possible roots were found. Please use `config.selector` to choose a specific root.');\n  const root = queryResult[0];\n  if (!root.classList.contains('brackets-viewer')) throw Error('The selected root must have a `.brackets-viewer` class.');\n  return root;\n}\n\nexports.findRoot = findRoot;\n/**\n * Completes a list of matches with blank matches based on the next matches.\n *\n * Toornament can generate first rounds with an odd number of matches and the seeding is partially distributed in the second round.\n * This function adds a blank match in the first round as if it was the source match of a seeded match of the second round.\n *\n * @param matches The list of first round matches.\n * @param nextMatches The list of second round matches.\n * @param bracketType Type of the bracket.\n */\n\nfunction completeWithBlankMatches(matches, nextMatches, bracketType) {\n  let sources = [];\n  if (bracketType === 'single-bracket' || bracketType === 'winner-bracket') sources = nextMatches.map(match => {\n    var _a, _b;\n\n    return [((_a = match.opponent1) === null || _a === void 0 ? void 0 : _a.position) || null, ((_b = match.opponent2) === null || _b === void 0 ? void 0 : _b.position) || null];\n  }).flat();\n  if (bracketType === 'loser-bracket') sources = nextMatches.map(match => {\n    var _a;\n\n    return ((_a = match.opponent2) === null || _a === void 0 ? void 0 : _a.position) || null;\n  }); // The manager does not set positions where the Toornament layer does.\n\n  if (sources.filter(source => source !== null).length === 0) return {\n    matches,\n    fromToornament: false\n  };\n  return {\n    matches: sources.map(source => source && matches.find(match => match.number === source) || null),\n    fromToornament: true\n  };\n}\n\nexports.completeWithBlankMatches = completeWithBlankMatches;\n/**\n * Returns the abbreviation for a participant origin.\n *\n * @param matchLocation Location of the match.\n * @param skipFirstRound Whether to skip the first round.\n * @param roundNumber Number of the round.\n * @param side Side of the participant.\n */\n\nfunction getOriginAbbreviation(matchLocation, skipFirstRound, roundNumber, side) {\n  roundNumber = roundNumber || -1;\n  if (skipFirstRound && matchLocation === 'loser-bracket' && roundNumber === 1) return lang_1.abbreviations.seed;\n  if (matchLocation === 'single-bracket' || matchLocation === 'winner-bracket' && roundNumber === 1) return lang_1.abbreviations.seed;\n  if (matchLocation === 'loser-bracket' && roundNumber % 2 === 0 && side === 'opponent1') return lang_1.abbreviations.position;\n  return null;\n}\n\nexports.getOriginAbbreviation = getOriginAbbreviation;\n/**\n * Indicates whether a round is major.\n *\n * @param roundNumber Number of the round.\n */\n\nfunction isMajorRound(roundNumber) {\n  return roundNumber === 1 || roundNumber % 2 === 0;\n}\n\nexports.isMajorRound = isMajorRound;\n/**\n * Returns the header for a ranking property.\n *\n * @param itemName Name of the ranking property.\n */\n\nfunction rankingHeader(itemName) {\n  return lang_1.headers[itemName];\n}\n\nexports.rankingHeader = rankingHeader;\n/**\n * Calculates the ranking based on a list of matches and a formula.\n *\n * @param matches The list of matches.\n * @param formula The points formula to apply.\n */\n\nfunction getRanking(matches, formula) {\n  formula = formula || (item => 3 * item.wins + 1 * item.draws + 0 * item.losses);\n\n  const rankingMap = {};\n\n  for (const match of matches) {\n    processParticipant(rankingMap, formula, match.opponent1, match.opponent2);\n    processParticipant(rankingMap, formula, match.opponent2, match.opponent1);\n  }\n\n  return createRanking(rankingMap);\n}\n\nexports.getRanking = getRanking;\n/**\n * Processes a participant and edits the ranking map.\n *\n * @param rankingMap The ranking map to edit.\n * @param formula The points formula to apply.\n * @param current The current participant.\n * @param other The opponent.\n */\n\nfunction processParticipant(rankingMap, formula, current, other) {\n  if (!current || current.id === null) return;\n  const state = rankingMap[current.id] || {\n    rank: 0,\n    id: 0,\n    played: 0,\n    wins: 0,\n    draws: 0,\n    losses: 0,\n    forfeits: 0,\n    scoreFor: 0,\n    scoreAgainst: 0,\n    scoreDifference: 0,\n    points: 0\n  };\n  state.id = current.id;\n  if (current.forfeit || current.result) state.played++;\n  if (current.result === 'win') state.wins++;\n  if (current.result === 'draw') state.draws++;\n  if (current.result === 'loss') state.losses++;\n  if (current.forfeit) state.forfeits++;\n  state.scoreFor += current.score || 0;\n  state.scoreAgainst += other && other.score || 0;\n  state.scoreDifference = state.scoreFor - state.scoreAgainst;\n  state.points = formula(state);\n  rankingMap[current.id] = state;\n}\n/**\n * Creates the final ranking based on a ranking map. (Sort + Total points)\n *\n * @param rankingMap The ranking map (object).\n */\n\n\nfunction createRanking(rankingMap) {\n  const ranking = Object.values(rankingMap).sort((a, b) => a.points !== b.points ? b.points - a.points : b.played - a.played);\n  const rank = {\n    value: 0,\n    lastPoints: -1\n  };\n\n  for (const item of ranking) {\n    item.rank = rank.lastPoints !== item.points ? ++rank.value : rank.value;\n    rank.lastPoints = item.points;\n  }\n\n  return ranking;\n}\n\n//# sourceURL=webpack://brackets-viewer/./src/viewer/helpers.ts?");

/***/ }),

/***/ "./src/viewer/lang.ts":
/*!****************************!*\
  !*** ./src/viewer/lang.ts ***!
  \****************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";
eval("\n\nvar __importDefault = this && this.__importDefault || function (mod) {\n  return mod && mod.__esModule ? mod : {\n    \"default\": mod\n  };\n};\n\nObject.defineProperty(exports, \"__esModule\", ({\n  value: true\n}));\nexports.headers = exports.BYE = exports.bestOfX = exports.abbreviations = exports.getLoserBracketRoundName = exports.getWinnerBracketRoundName = exports.getRoundName = exports.getGroupName = exports.getMatchStatus = exports.getFinalMatchLabel = exports.getMatchLabel = exports.getFinalOriginHint = exports.getOriginHint = exports.i18n = exports.i18next = exports.locales = void 0;\n\nconst i18next_1 = __importDefault(__webpack_require__(/*! i18next */ \"./node_modules/i18next/dist/esm/i18next.js\"));\n\nexports.i18next = i18next_1.default;\n\nconst i18next_browser_languagedetector_1 = __importDefault(__webpack_require__(/*! i18next-browser-languagedetector */ \"./node_modules/i18next-browser-languagedetector/dist/esm/i18nextBrowserLanguageDetector.js\"));\n\nconst brackets_model_1 = __webpack_require__(/*! brackets-model */ \"./node_modules/brackets-model/dist/index.js\");\n\nconst helpers_1 = __webpack_require__(/*! ./helpers */ \"./src/viewer/helpers.ts\");\n\nconst translation_json_1 = __importDefault(__webpack_require__(/*! ../i18n/en/translation.json */ \"./src/i18n/en/translation.json\"));\n\nconst translation_json_2 = __importDefault(__webpack_require__(/*! ../i18n/fr/translation.json */ \"./src/i18n/fr/translation.json\"));\n\nexports.locales = {\n  en: translation_json_1.default,\n  fr: translation_json_2.default\n};\ni18next_1.default.use(i18next_browser_languagedetector_1.default).init({\n  fallbackLng: 'en',\n  debug: false,\n  resources: {\n    en: {\n      translation: exports.locales.en\n    },\n    fr: {\n      translation: exports.locales.fr\n    }\n  }\n}, undefined);\n/**\n * Returns an internationalized version of a locale key.\n *\n * @param scope A locale scope.\n * @param key A locale key.\n * @param options Data to pass to the i18n process or a boolean.\n */\n\nfunction i18n(scope, key, options) {\n  if (typeof options === 'boolean') return i18next_1.default.t(`${scope}.${key}`, {\n    returnObjects: true\n  });\n  return i18next_1.default.t(`${scope}.${key}`, options);\n}\n\nexports.i18n = i18n;\n/**\n * Returns an origin hint function based on rounds information.\n *\n * @param roundNumber Number of the round.\n * @param roundCount Count of rounds.\n * @param skipFirstRound Whether to skip the first round.\n * @param matchLocation Location of the match.\n */\n\nfunction getOriginHint(roundNumber, roundCount, skipFirstRound, matchLocation) {\n  if (roundNumber === 1) {\n    if (matchLocation === 'single-bracket') return position => i18n('origin-hint', 'seed', {\n      position\n    });\n    if (matchLocation === 'winner-bracket') return position => i18n('origin-hint', 'seed', {\n      position\n    });\n    if (matchLocation === 'loser-bracket' && skipFirstRound) return position => i18n('origin-hint', 'seed', {\n      position\n    });\n  }\n\n  if (helpers_1.isMajorRound(roundNumber) && matchLocation === 'loser-bracket') {\n    if (roundNumber === roundCount - 2) return position => i18n('origin-hint', 'winner-bracket-semi-final', {\n      position\n    });\n    if (roundNumber === roundCount) return () => i18n('origin-hint', 'winner-bracket-final');\n    const roundNumberWB = Math.ceil((roundNumber + 1) / 2);\n    if (skipFirstRound) return position => i18n('origin-hint', 'winner-bracket', {\n      round: roundNumberWB - 1,\n      position\n    });\n    return position => i18n('origin-hint', 'winner-bracket', {\n      round: roundNumberWB,\n      position\n    });\n  }\n\n  return undefined;\n}\n\nexports.getOriginHint = getOriginHint;\n/**\n * Returns an origin hint function for a match in final.\n *\n * @param finalType Type of the final.\n * @param roundNumber Number of the round.\n */\n\nfunction getFinalOriginHint(finalType, roundNumber) {\n  // Single elimination.\n  if (finalType === 'consolation_final') return position => i18n('origin-hint', 'consolation-final', {\n    position\n  }); // Double elimination.\n\n  if (roundNumber === 1) // Grand Final round 1\n    return () => i18n('origin-hint', 'grand-final'); // Grand Final round 2 (no hint because it's obvious both participants come from the previous round)\n\n  return undefined;\n}\n\nexports.getFinalOriginHint = getFinalOriginHint;\n/**\n * Returns the label of a match.\n *\n * @param matchNumber Number of the match.\n * @param roundNumber Number of the round.\n * @param roundCount Count of rounds.\n * @param matchLocation Location of the match.\n */\n\nfunction getMatchLabel(matchNumber, roundNumber, roundCount, matchLocation) {\n  const matchPrefix = matchLocation === 'winner-bracket' ? i18n('match-label', 'winner-bracket') : matchLocation === 'loser-bracket' ? i18n('match-label', 'loser-bracket') : i18n('match-label', 'standard-bracket');\n  const inSemiFinalRound = roundNumber === roundCount - 1;\n  const inFinalRound = roundNumber === roundCount;\n\n  if (matchLocation === 'single-bracket') {\n    if (inSemiFinalRound) return i18n('match-label', 'standard-bracket-semi-final', {\n      matchNumber\n    });\n    if (inFinalRound) return i18n('match-label', 'standard-bracket-final');\n  }\n\n  if (inSemiFinalRound) return i18n('match-label', 'double-elimination-semi-final', {\n    matchPrefix,\n    matchNumber\n  });\n  if (inFinalRound) return i18n('match-label', 'double-elimination-final', {\n    matchPrefix\n  });\n  return i18n('match-label', 'double-elimination', {\n    matchPrefix,\n    roundNumber,\n    matchNumber\n  });\n}\n\nexports.getMatchLabel = getMatchLabel;\n/**\n * Returns the label of a match in final.\n *\n * @param finalType Type of the final.\n * @param roundNumber Number of the round.\n * @param roundCount Count of rounds.\n */\n\nfunction getFinalMatchLabel(finalType, roundNumber, roundCount) {\n  // Single elimination.\n  if (finalType === 'consolation_final') return i18n('match-label', 'consolation-final'); // Double elimination.\n\n  if (roundCount === 1) return i18n('match-label', 'grand-final-single');\n  return i18n('match-label', 'grand-final', {\n    roundNumber\n  });\n}\n\nexports.getFinalMatchLabel = getFinalMatchLabel;\n/**\n * Returns the status of a match.\n *\n * @param status The match status.\n */\n\nfunction getMatchStatus(status) {\n  switch (status) {\n    case brackets_model_1.Status.Locked:\n      return i18n('match-status', 'locked');\n\n    case brackets_model_1.Status.Waiting:\n      return i18n('match-status', 'waiting');\n\n    case brackets_model_1.Status.Ready:\n      return i18n('match-status', 'ready');\n\n    case brackets_model_1.Status.Running:\n      return i18n('match-status', 'running');\n\n    case brackets_model_1.Status.Completed:\n      return i18n('match-status', 'completed');\n\n    case brackets_model_1.Status.Archived:\n      return i18n('match-status', 'archived');\n\n    default:\n      return 'Unknown status';\n  }\n}\n\nexports.getMatchStatus = getMatchStatus;\n/**\n * Returns the name of a group.\n *\n * @param groupNumber Number of the group.\n */\n\nfunction getGroupName(groupNumber) {\n  return i18n('common', 'group-name', {\n    groupNumber\n  });\n}\n\nexports.getGroupName = getGroupName;\n/**\n * Returns the name of a round.\n *\n * @param roundNumber Number of the round.\n * @param roundCount Count of rounds.\n */\n\nfunction getRoundName(roundNumber, roundCount) {\n  return roundNumber === roundCount ? i18n('common', 'round-name-final') : i18n('common', 'round-name', {\n    roundNumber\n  });\n}\n\nexports.getRoundName = getRoundName;\n/**\n * Returns the name of a round in the winner bracket of a double elimination stage.\n *\n * @param roundNumber Number of the round.\n * @param roundCount Count of rounds.\n */\n\nfunction getWinnerBracketRoundName(roundNumber, roundCount) {\n  return roundNumber === roundCount ? i18n('common', 'round-name-winner-bracket-final') : i18n('common', 'round-name-winner-bracket', {\n    roundNumber\n  });\n}\n\nexports.getWinnerBracketRoundName = getWinnerBracketRoundName;\n/**\n * Returns the name of a round in the loser bracket of a double elimination stage.\n *\n * @param roundNumber Number of the round.\n * @param roundCount Count of rounds.\n */\n\nfunction getLoserBracketRoundName(roundNumber, roundCount) {\n  return roundNumber === roundCount ? i18n('common', 'round-name-loser-bracket-final') : i18n('common', 'round-name-loser-bracket', {\n    roundNumber\n  });\n}\n\nexports.getLoserBracketRoundName = getLoserBracketRoundName;\n/**\n * Abbreviations used in the viewer.\n */\n\nexports.abbreviations = {\n  win: i18n('abbreviations', 'win'),\n  loss: i18n('abbreviations', 'loss'),\n  forfeit: i18n('abbreviations', 'forfeit'),\n  position: i18n('abbreviations', 'position'),\n  seed: i18n('abbreviations', 'seed')\n};\n/**\n * The Best of X literal.\n *\n * @param x Child count.\n */\n\nconst bestOfX = x => i18n('common', 'best-of-x', {\n  x\n});\n\nexports.bestOfX = bestOfX;\n/**\n * The BYE literal.\n */\n\nexports.BYE = i18n('common', 'bye');\n/**\n * Headers of the ranking.\n */\n\nexports.headers = {\n  rank: i18n('ranking', 'rank', true),\n  id: i18n('ranking', 'id', true),\n  played: i18n('ranking', 'played', true),\n  wins: i18n('ranking', 'wins', true),\n  draws: i18n('ranking', 'draws', true),\n  losses: i18n('ranking', 'losses', true),\n  forfeits: i18n('ranking', 'forfeits', true),\n  scoreFor: i18n('ranking', 'score-for', true),\n  scoreAgainst: i18n('ranking', 'score-against', true),\n  scoreDifference: i18n('ranking', 'score-difference', true),\n  points: i18n('ranking', 'points', true)\n};\n\n//# sourceURL=webpack://brackets-viewer/./src/viewer/lang.ts?");

/***/ }),

/***/ "./node_modules/brackets-manager/dist/base/getter.js":
/*!***********************************************************!*\
  !*** ./node_modules/brackets-manager/dist/base/getter.js ***!
  \***********************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.BaseGetter = void 0;\nconst helpers = __webpack_require__(/*! ../helpers */ \"./node_modules/brackets-manager/dist/helpers.js\");\nclass BaseGetter {\n    /**\n     * Creates an instance of a Storage getter.\n     *\n     * @param storage The implementation of Storage.\n     */\n    constructor(storage) {\n        this.storage = storage;\n    }\n    /**\n     * Gets all the rounds that contain ordered participants.\n     *\n     * @param stage The stage to get rounds from.\n     */\n    async getOrderedRounds(stage) {\n        if (!(stage === null || stage === void 0 ? void 0 : stage.settings.size))\n            throw Error('The stage has no size.');\n        if (stage.type === 'single_elimination')\n            return this.getOrderedRoundsSingleElimination(stage.id);\n        return this.getOrderedRoundsDoubleElimination(stage.id);\n    }\n    /**\n     * Gets all the rounds that contain ordered participants in a single elimination stage.\n     *\n     * @param stageId ID of the stage.\n     */\n    async getOrderedRoundsSingleElimination(stageId) {\n        return [await this.getUpperBracketFirstRound(stageId)];\n    }\n    /**\n     * Gets all the rounds that contain ordered participants in a double elimination stage.\n     *\n     * @param stageId ID of the stage.\n     */\n    async getOrderedRoundsDoubleElimination(stageId) {\n        // Getting all rounds instead of cherry-picking them is the least expensive.\n        const rounds = await this.storage.select('round', { stage_id: stageId });\n        if (!rounds)\n            throw Error('Error getting rounds.');\n        const loserBracket = await this.getLoserBracket(stageId);\n        if (!loserBracket)\n            throw Error('Loser bracket not found.');\n        const firstRoundWB = rounds[0];\n        const roundsLB = rounds.filter(r => r.group_id === loserBracket.id);\n        const orderedRoundsLB = roundsLB.filter(r => helpers.isOrderingSupportedLoserBracket(r.number, roundsLB.length));\n        return [firstRoundWB, ...orderedRoundsLB];\n    }\n    /**\n     * Gets the positional information (number in group and total number of rounds in group) of a round based on its id.\n     *\n     * @param roundId ID of the round.\n     */\n    async getRoundPositionalInfo(roundId) {\n        const round = await this.storage.select('round', roundId);\n        if (!round)\n            throw Error('Round not found.');\n        const rounds = await this.storage.select('round', { group_id: round.group_id });\n        if (!rounds)\n            throw Error('Error getting rounds.');\n        return {\n            roundNumber: round.number,\n            roundCount: rounds.length,\n        };\n    }\n    /**\n     * Gets the matches leading to the given match.\n     *\n     * @param match The current match.\n     * @param matchLocation Location of the current match.\n     * @param stage The parent stage.\n     * @param roundNumber Number of the round.\n     */\n    async getPreviousMatches(match, matchLocation, stage, roundNumber) {\n        if (matchLocation === 'loser_bracket')\n            return this.getPreviousMatchesLB(match, stage, roundNumber);\n        if (matchLocation === 'final_group')\n            return this.getPreviousMatchesFinal(match, roundNumber);\n        if (roundNumber === 1)\n            return []; // The match is in the first round of an upper bracket.\n        return this.getMatchesBeforeMajorRound(match, roundNumber);\n    }\n    /**\n     * Gets the matches leading to the given match, which is in a final group (consolation final or grand final).\n     *\n     * @param match The current match.\n     * @param roundNumber Number of the current round.\n     */\n    async getPreviousMatchesFinal(match, roundNumber) {\n        if (roundNumber > 1)\n            return [await this.findMatch(match.group_id, roundNumber - 1, 1)];\n        const upperBracket = await this.getUpperBracket(match.stage_id);\n        const lastRound = await this.getLastRound(upperBracket.id);\n        const upperBracketFinalMatch = await this.storage.selectFirst('match', {\n            round_id: lastRound.id,\n            number: 1,\n        });\n        if (upperBracketFinalMatch === null)\n            throw Error('Match not found.');\n        return [upperBracketFinalMatch];\n    }\n    /**\n     * Gets the matches leading to a given match from the loser bracket.\n     *\n     * @param match The current match.\n     * @param stage The parent stage.\n     * @param roundNumber Number of the round.\n     */\n    async getPreviousMatchesLB(match, stage, roundNumber) {\n        if (stage.settings.skipFirstRound && roundNumber === 1)\n            return [];\n        if (helpers.hasBye(match))\n            return []; // Shortcut because we are coming from propagateByes().\n        const winnerBracket = await this.getUpperBracket(match.stage_id);\n        const actualRoundNumberWB = Math.ceil((roundNumber + 1) / 2);\n        const roundNumberWB = stage.settings.skipFirstRound ? actualRoundNumberWB - 1 : actualRoundNumberWB;\n        if (roundNumber === 1)\n            return this.getMatchesBeforeFirstRoundLB(match, winnerBracket.id, roundNumberWB);\n        if (roundNumber % 2 === 0)\n            return this.getMatchesBeforeMinorRoundLB(match, winnerBracket.id, roundNumber, roundNumberWB);\n        return this.getMatchesBeforeMajorRound(match, roundNumber);\n    }\n    /**\n     * Gets the matches leading to a given match in a major round (every round of upper bracket or specific ones in lower bracket).\n     *\n     * @param match The current match.\n     * @param roundNumber Number of the round.\n     */\n    async getMatchesBeforeMajorRound(match, roundNumber) {\n        return [\n            await this.findMatch(match.group_id, roundNumber - 1, match.number * 2 - 1),\n            await this.findMatch(match.group_id, roundNumber - 1, match.number * 2),\n        ];\n    }\n    /**\n     * Gets the matches leading to a given match in the first round of the loser bracket.\n     *\n     * @param match The current match.\n     * @param winnerBracketId ID of the winner bracket.\n     * @param roundNumberWB The number of the previous round in the winner bracket.\n     */\n    async getMatchesBeforeFirstRoundLB(match, winnerBracketId, roundNumberWB) {\n        return [\n            await this.findMatch(winnerBracketId, roundNumberWB, helpers.getOriginPosition(match, 'opponent1')),\n            await this.findMatch(winnerBracketId, roundNumberWB, helpers.getOriginPosition(match, 'opponent2')),\n        ];\n    }\n    /**\n     * Gets the matches leading to a given match in a minor round of the loser bracket.\n     *\n     * @param match The current match.\n     * @param winnerBracketId ID of the winner bracket.\n     * @param roundNumber Number of the current round.\n     * @param roundNumberWB The number of the previous round in the winner bracket.\n     */\n    async getMatchesBeforeMinorRoundLB(match, winnerBracketId, roundNumber, roundNumberWB) {\n        const matchNumber = helpers.getOriginPosition(match, 'opponent1');\n        return [\n            await this.findMatch(winnerBracketId, roundNumberWB, matchNumber),\n            await this.findMatch(match.group_id, roundNumber - 1, match.number),\n        ];\n    }\n    /**\n     * Gets the match(es) where the opponents of the current match will go just after.\n     *\n     * @param match The current match.\n     * @param matchLocation Location of the current match.\n     * @param stage The parent stage.\n     * @param roundNumber The number of the current round.\n     * @param roundCount Count of rounds.\n     */\n    async getNextMatches(match, matchLocation, stage, roundNumber, roundCount) {\n        switch (matchLocation) {\n            case 'single_bracket':\n                return this.getNextMatchesUpperBracket(match, stage.type, roundNumber, roundCount);\n            case 'winner_bracket':\n                return this.getNextMatchesWB(match, stage, roundNumber, roundCount);\n            case 'loser_bracket':\n                return this.getNextMatchesLB(match, stage.type, roundNumber, roundCount);\n            case 'final_group':\n                return this.getNextMatchesFinal(match, roundNumber, roundCount);\n            default:\n                throw Error('Unknown bracket kind.');\n        }\n    }\n    /**\n     * Gets the match(es) where the opponents of the current match of winner bracket will go just after.\n     *\n     * @param match The current match.\n     * @param stage The parent stage.\n     * @param roundNumber The number of the current round.\n     * @param roundCount Count of rounds.\n     */\n    async getNextMatchesWB(match, stage, roundNumber, roundCount) {\n        const loserBracket = await this.getLoserBracket(match.stage_id);\n        if (loserBracket === null) // Only one match in the stage, there is no loser bracket.\n            return [];\n        const actualRoundNumber = stage.settings.skipFirstRound ? roundNumber + 1 : roundNumber;\n        const roundNumberLB = actualRoundNumber > 1 ? (actualRoundNumber - 1) * 2 : 1;\n        const matchNumberLB = actualRoundNumber > 1 ? match.number : helpers.getDiagonalMatchNumber(match.number);\n        const participantCount = stage.settings.size;\n        const method = helpers.getLoserOrdering(stage.settings.seedOrdering, roundNumberLB);\n        const actualMatchNumberLB = helpers.findLoserMatchNumber(participantCount, roundNumberLB, matchNumberLB, method);\n        return [\n            ...await this.getNextMatchesUpperBracket(match, stage.type, roundNumber, roundCount),\n            await this.findMatch(loserBracket.id, roundNumberLB, actualMatchNumberLB),\n        ];\n    }\n    /**\n     * Gets the match(es) where the opponents of the current match of an upper bracket will go just after.\n     *\n     * @param match The current match.\n     * @param stageType Type of the stage.\n     * @param roundNumber The number of the current round.\n     * @param roundCount Count of rounds.\n     */\n    async getNextMatchesUpperBracket(match, stageType, roundNumber, roundCount) {\n        if (stageType === 'single_elimination')\n            return this.getNextMatchesUpperBracketSingleElimination(match, stageType, roundNumber, roundCount);\n        if (stageType === 'double_elimination' && roundNumber === roundCount)\n            return [await this.getFirstMatchFinal(match, stageType)];\n        return [await this.getDiagonalMatch(match.group_id, roundNumber, match.number)];\n    }\n    /**\n     * Gets the match(es) where the opponents of the current match of the unique bracket of a single elimination will go just after.\n     *\n     * @param match The current match.\n     * @param stageType Type of the stage.\n     * @param roundNumber The number of the current round.\n     * @param roundCount Count of rounds.\n     */\n    async getNextMatchesUpperBracketSingleElimination(match, stageType, roundNumber, roundCount) {\n        if (roundNumber === roundCount - 1) {\n            const final = await this.getFirstMatchFinal(match, stageType);\n            return [\n                await this.getDiagonalMatch(match.group_id, roundNumber, match.number),\n                ...final ? [final] : [],\n            ];\n        }\n        if (roundNumber === roundCount)\n            return [];\n        return [await this.getDiagonalMatch(match.group_id, roundNumber, match.number)];\n    }\n    /**\n     * Gets the match(es) where the opponents of the current match of loser bracket will go just after.\n     *\n     * @param match The current match.\n     * @param stageType Type of the stage.\n     * @param roundNumber The number of the current round.\n     * @param roundCount Count of rounds.\n     */\n    async getNextMatchesLB(match, stageType, roundNumber, roundCount) {\n        if (roundNumber === roundCount) {\n            const final = await this.getFirstMatchFinal(match, stageType);\n            return final ? [final] : [];\n        }\n        if (roundNumber % 2 === 1)\n            return this.getMatchAfterMajorRoundLB(match, roundNumber);\n        return this.getMatchAfterMinorRoundLB(match, roundNumber);\n    }\n    /**\n     * Gets the first match of the final group (consolation final or grand final).\n     *\n     * @param match The current match.\n     * @param stageType Type of the stage.\n     */\n    async getFirstMatchFinal(match, stageType) {\n        const finalGroupId = await this.getFinalGroupId(match.stage_id, stageType);\n        if (finalGroupId === null)\n            return null;\n        return this.findMatch(finalGroupId, 1, 1);\n    }\n    /**\n     * Gets the matches following the current match, which is in the final group (consolation final or grand final).\n     *\n     * @param match The current match.\n     * @param roundNumber The number of the current round.\n     * @param roundCount The count of rounds.\n     */\n    async getNextMatchesFinal(match, roundNumber, roundCount) {\n        if (roundNumber === roundCount)\n            return [];\n        return [await this.findMatch(match.group_id, roundNumber + 1, 1)];\n    }\n    /**\n     * Gets the match(es) where the opponents of the current match of a winner bracket's major round will go just after.\n     *\n     * @param match The current match.\n     * @param roundNumber The number of the current round.\n     */\n    async getMatchAfterMajorRoundLB(match, roundNumber) {\n        return [await this.getParallelMatch(match.group_id, roundNumber, match.number)];\n    }\n    /**\n     * Gets the match(es) where the opponents of the current match of a winner bracket's minor round will go just after.\n     *\n     * @param match The current match.\n     * @param roundNumber The number of the current round.\n     */\n    async getMatchAfterMinorRoundLB(match, roundNumber) {\n        return [await this.getDiagonalMatch(match.group_id, roundNumber, match.number)];\n    }\n    /**\n     * Returns the good seeding ordering based on the stage's type.\n     *\n     * @param stageType The type of the stage.\n     * @param create A reference to a Create instance.\n     */\n    static getSeedingOrdering(stageType, create) {\n        return stageType === 'round_robin' ? create.getRoundRobinOrdering() : create.getStandardBracketFirstRoundOrdering();\n    }\n    /**\n     * Returns the matches which contain the seeding of a stage based on its type.\n     *\n     * @param stageId ID of the stage.\n     * @param stageType The type of the stage.\n     */\n    async getSeedingMatches(stageId, stageType) {\n        if (stageType === 'round_robin')\n            return this.storage.select('match', { stage_id: stageId });\n        const firstRound = await this.getUpperBracketFirstRound(stageId);\n        return this.storage.select('match', { round_id: firstRound.id });\n    }\n    /**\n     * Gets the first round of the upper bracket.\n     *\n     * @param stageId ID of the stage.\n     */\n    async getUpperBracketFirstRound(stageId) {\n        // Considering the database is ordered, this round will always be the first round of the upper bracket.\n        const firstRound = await this.storage.selectFirst('round', { stage_id: stageId, number: 1 });\n        if (!firstRound)\n            throw Error('Round not found.');\n        return firstRound;\n    }\n    /**\n     * Gets the last round of a group.\n     *\n     * @param groupId ID of the group.\n     */\n    async getLastRound(groupId) {\n        const round = await this.storage.selectLast('round', { group_id: groupId });\n        if (!round)\n            throw Error('Error getting rounds.');\n        return round;\n    }\n    /**\n     * Returns the id of the final group (consolation final or grand final).\n     *\n     * @param stageId ID of the stage.\n     * @param stageType Type of the stage.\n     */\n    async getFinalGroupId(stageId, stageType) {\n        const groupNumber = stageType === 'single_elimination' ? 2 /* Consolation final */ : 3 /* Grand final */;\n        const finalGroup = await this.storage.selectFirst('group', { stage_id: stageId, number: groupNumber });\n        if (!finalGroup)\n            return null;\n        return finalGroup.id;\n    }\n    /**\n     * Gets the upper bracket (the only bracket if single elimination or the winner bracket in double elimination).\n     *\n     * @param stageId ID of the stage.\n     */\n    async getUpperBracket(stageId) {\n        const winnerBracket = await this.storage.selectFirst('group', { stage_id: stageId, number: 1 });\n        if (!winnerBracket)\n            throw Error('Winner bracket not found.');\n        return winnerBracket;\n    }\n    /**\n     * Gets the loser bracket.\n     *\n     * @param stageId ID of the stage.\n     */\n    async getLoserBracket(stageId) {\n        return this.storage.selectFirst('group', { stage_id: stageId, number: 2 });\n    }\n    /**\n     * Gets the corresponding match in the next round (\"diagonal match\") the usual way.\n     *\n     * Just like from Round 1 to Round 2 in a single elimination stage.\n     *\n     * @param groupId ID of the group.\n     * @param roundNumber Number of the round in its parent group.\n     * @param matchNumber Number of the match in its parent round.\n     */\n    async getDiagonalMatch(groupId, roundNumber, matchNumber) {\n        return this.findMatch(groupId, roundNumber + 1, helpers.getDiagonalMatchNumber(matchNumber));\n    }\n    /**\n     * Gets the corresponding match in the next round (\"parallel match\") the \"major round to minor round\" way.\n     *\n     * Just like from Round 1 to Round 2 in the loser bracket of a double elimination stage.\n     *\n     * @param groupId ID of the group.\n     * @param roundNumber Number of the round in its parent group.\n     * @param matchNumber Number of the match in its parent round.\n     */\n    async getParallelMatch(groupId, roundNumber, matchNumber) {\n        return this.findMatch(groupId, roundNumber + 1, matchNumber);\n    }\n    /**\n     * Finds a match in a given group. The match must have the given number in a round of which the number in group is given.\n     *\n     * **Example:** In group of id 1, give me the 4th match in the 3rd round.\n     *\n     * @param groupId ID of the group.\n     * @param roundNumber Number of the round in its parent group.\n     * @param matchNumber Number of the match in its parent round.\n     */\n    async findMatch(groupId, roundNumber, matchNumber) {\n        const round = await this.storage.selectFirst('round', {\n            group_id: groupId,\n            number: roundNumber,\n        });\n        if (!round)\n            throw Error('Round not found.');\n        const match = await this.storage.selectFirst('match', {\n            round_id: round.id,\n            number: matchNumber,\n        });\n        if (!match)\n            throw Error('Match not found.');\n        return match;\n    }\n    /**\n     * Finds a match game based on its `id` or based on the combination of its `parent_id` and `number`.\n     *\n     * @param game Values to change in a match game.\n     */\n    async findMatchGame(game) {\n        if (game.id !== undefined) {\n            const stored = await this.storage.select('match_game', game.id);\n            if (!stored)\n                throw Error('Match game not found.');\n            return stored;\n        }\n        if (game.parent_id !== undefined && game.number) {\n            const stored = await this.storage.selectFirst('match_game', {\n                parent_id: game.parent_id,\n                number: game.number,\n            });\n            if (!stored)\n                throw Error('Match game not found.');\n            return stored;\n        }\n        throw Error('No match game id nor parent id and number given.');\n    }\n}\nexports.BaseGetter = BaseGetter;\n//# sourceMappingURL=getter.js.map\n\n//# sourceURL=webpack://brackets-viewer/./node_modules/brackets-manager/dist/base/getter.js?");

/***/ }),

/***/ "./node_modules/brackets-manager/dist/base/updater.js":
/*!************************************************************!*\
  !*** ./node_modules/brackets-manager/dist/base/updater.js ***!
  \************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.BaseUpdater = void 0;\nconst brackets_model_1 = __webpack_require__(/*! brackets-model */ \"./node_modules/brackets-model/dist/index.js\");\nconst ordering_1 = __webpack_require__(/*! ../ordering */ \"./node_modules/brackets-manager/dist/ordering.js\");\nconst create_1 = __webpack_require__(/*! ../create */ \"./node_modules/brackets-manager/dist/create.js\");\nconst getter_1 = __webpack_require__(/*! ./getter */ \"./node_modules/brackets-manager/dist/base/getter.js\");\nconst helpers = __webpack_require__(/*! ../helpers */ \"./node_modules/brackets-manager/dist/helpers.js\");\nclass BaseUpdater extends getter_1.BaseGetter {\n    /**\n     * Updates or resets the seeding of a stage.\n     *\n     * @param stageId ID of the stage.\n     * @param seeding A new seeding or null to reset the existing seeding.\n     */\n    async updateSeeding(stageId, seeding) {\n        const stage = await this.storage.select('stage', stageId);\n        if (!stage)\n            throw Error('Stage not found.');\n        if (seeding && seeding.length !== stage.settings.size)\n            throw Error('The size of the seeding is incorrect.');\n        const create = new create_1.Create(this.storage, {\n            name: stage.name,\n            tournamentId: stage.tournament_id,\n            type: stage.type,\n            settings: stage.settings,\n            seeding: seeding || undefined,\n        });\n        create.setExisting(stageId);\n        const method = getter_1.BaseGetter.getSeedingOrdering(stage.type, create);\n        const slots = await create.getSlots();\n        const matches = await this.getSeedingMatches(stage.id, stage.type);\n        if (!matches)\n            throw Error('Error getting matches associated to the seeding.');\n        const ordered = ordering_1.ordering[method](slots);\n        await BaseUpdater.assertCanUpdateSeeding(matches, ordered);\n        await create.run();\n    }\n    /**\n     * Updates a parent match based on its child games.\n     *\n     * @param parentId ID of the parent match.\n     */\n    async updateParentMatch(parentId) {\n        const storedParent = await this.storage.select('match', parentId);\n        if (!storedParent)\n            throw Error('Parent not found.');\n        const games = await this.storage.select('match_game', { parent_id: parentId });\n        if (!games)\n            throw Error('No match games.');\n        const parentScores = helpers.getChildGamesResults(games);\n        const parent = helpers.getParentMatchResults(storedParent, parentScores);\n        const stage = await this.storage.select('stage', storedParent.stage_id);\n        if (!stage)\n            throw Error('Stage not found.');\n        const inRoundRobin = helpers.isRoundRobin(stage);\n        helpers.setParentMatchCompleted(parent, storedParent.child_count, inRoundRobin);\n        await this.updateMatch(storedParent, parent, true);\n    }\n    /**\n     * Throws an error if a match is locked and the new seeding will change this match's participants.\n     *\n     * @param matches The matches stored in the database.\n     * @param slots The slots to check from the new seeding.\n     */\n    static async assertCanUpdateSeeding(matches, slots) {\n        var _a, _b;\n        let index = 0;\n        for (const match of matches) {\n            const opponent1 = slots[index++];\n            const opponent2 = slots[index++];\n            const locked = helpers.isMatchParticipantLocked(match);\n            if (!locked)\n                continue;\n            if (((_a = match.opponent1) === null || _a === void 0 ? void 0 : _a.id) !== (opponent1 === null || opponent1 === void 0 ? void 0 : opponent1.id) || ((_b = match.opponent2) === null || _b === void 0 ? void 0 : _b.id) !== (opponent2 === null || opponent2 === void 0 ? void 0 : opponent2.id))\n                throw Error('A match is locked.');\n        }\n    }\n    /**\n     * Updates the matches related (previous and next) to a match.\n     *\n     * @param match A match.\n     * @param updatePrevious Whether to update the previous matches.\n     * @param updateNext Whether to update the next matches.\n     */\n    async updateRelatedMatches(match, updatePrevious, updateNext) {\n        const { roundNumber, roundCount } = await this.getRoundPositionalInfo(match.round_id);\n        const stage = await this.storage.select('stage', match.stage_id);\n        if (!stage)\n            throw Error('Stage not found.');\n        const group = await this.storage.select('group', match.group_id);\n        if (!group)\n            throw Error('Group not found.');\n        const matchLocation = helpers.getMatchLocation(stage.type, group.number);\n        updatePrevious && await this.updatePrevious(match, matchLocation, stage, roundNumber);\n        updateNext && await this.updateNext(match, matchLocation, stage, roundNumber, roundCount);\n    }\n    /**\n     * Updates a match based on a partial match.\n     *\n     * @param stored A reference to what will be updated in the storage.\n     * @param match Input of the update.\n     * @param force Whether to force update locked matches.\n     */\n    async updateMatch(stored, match, force) {\n        if (!force && helpers.isMatchUpdateLocked(stored))\n            throw Error('The match is locked.');\n        const { statusChanged, resultChanged } = helpers.setMatchResults(stored, match);\n        await this.applyMatchUpdate(stored);\n        // Don't update related matches if it's a simple score update.\n        if (!statusChanged && !resultChanged)\n            return;\n        const stage = await this.storage.select('stage', stored.stage_id);\n        if (!stage)\n            throw Error('Stage not found.');\n        if (!helpers.isRoundRobin(stage))\n            await this.updateRelatedMatches(stored, statusChanged, resultChanged);\n    }\n    /**\n     * Updates a match and its child games.\n     *\n     * @param match A match.\n     */\n    async applyMatchUpdate(match) {\n        if (!await this.storage.update('match', match.id, match))\n            throw Error('Could not update the match.');\n        if (match.child_count === 0)\n            return;\n        const update = {\n            opponent1: helpers.toResult(match.opponent1),\n            opponent2: helpers.toResult(match.opponent2),\n        };\n        if (match.status <= brackets_model_1.Status.Ready || match.status === brackets_model_1.Status.Archived)\n            update.status = match.status;\n        if (!await this.storage.update('match_game', { parent_id: match.id }, update))\n            throw Error('Could not update the match game.');\n    }\n    /**\n     * Updates the match(es) leading to the current match based on this match results.\n     *\n     * @param match Input of the update.\n     * @param matchLocation Location of the current match.\n     * @param stage The parent stage.\n     * @param roundNumber Number of the round.\n     */\n    async updatePrevious(match, matchLocation, stage, roundNumber) {\n        const previousMatches = await this.getPreviousMatches(match, matchLocation, stage, roundNumber);\n        if (previousMatches.length === 0)\n            return;\n        if (match.status >= brackets_model_1.Status.Running)\n            await this.archiveMatches(previousMatches);\n        else\n            await this.resetMatchesStatus(previousMatches);\n    }\n    /**\n     * Sets the status of a list of matches to archived.\n     *\n     * @param matches The matches to update.\n     */\n    async archiveMatches(matches) {\n        for (const match of matches) {\n            match.status = brackets_model_1.Status.Archived;\n            await this.applyMatchUpdate(match);\n        }\n    }\n    /**\n     * Resets the status of a list of matches to what it should currently be.\n     *\n     * @param matches The matches to update.\n     */\n    async resetMatchesStatus(matches) {\n        for (const match of matches) {\n            match.status = helpers.getMatchStatus(match);\n            await this.applyMatchUpdate(match);\n        }\n    }\n    /**\n     * Updates the match(es) following the current match based on this match results.\n     *\n     * @param match Input of the update.\n     * @param matchLocation Location of the current match.\n     * @param stage The parent stage.\n     * @param roundNumber Number of the round.\n     * @param roundCount Count of rounds.\n     */\n    async updateNext(match, matchLocation, stage, roundNumber, roundCount) {\n        const nextMatches = await this.getNextMatches(match, matchLocation, stage, roundNumber, roundCount);\n        if (nextMatches.length === 0)\n            return;\n        const winnerSide = helpers.getMatchResult(match);\n        const actualRoundNumber = (stage.settings.skipFirstRound && matchLocation === 'winner_bracket') ? roundNumber + 1 : roundNumber;\n        if (winnerSide)\n            await this.applyToNextMatches(helpers.setNextOpponent, match, matchLocation, actualRoundNumber, roundCount, nextMatches, winnerSide);\n        else\n            await this.applyToNextMatches(helpers.resetNextOpponent, match, matchLocation, actualRoundNumber, roundCount, nextMatches);\n    }\n    /**\n     * Applies a SetNextOpponent function to matches following the current match.\n     *\n     * @param setNextOpponent The SetNextOpponent function.\n     * @param match The current match.\n     * @param matchLocation Location of the current match.\n     * @param roundNumber Number of the current round.\n     * @param roundCount Count of rounds.\n     * @param nextMatches The matches following the current match.\n     * @param winnerSide Side of the winner in the current match.\n     */\n    async applyToNextMatches(setNextOpponent, match, matchLocation, roundNumber, roundCount, nextMatches, winnerSide) {\n        if (matchLocation === 'final_group') {\n            if (!nextMatches[0])\n                throw Error('First next match is null.');\n            setNextOpponent(nextMatches[0], 'opponent1', match, 'opponent1');\n            setNextOpponent(nextMatches[0], 'opponent2', match, 'opponent2');\n            await this.applyMatchUpdate(nextMatches[0]);\n            return;\n        }\n        const nextSide = helpers.getNextSide(match.number, roundNumber, roundCount, matchLocation);\n        if (nextMatches[0]) {\n            setNextOpponent(nextMatches[0], nextSide, match, winnerSide);\n            await this.propagateByeWinners(nextMatches[0]);\n        }\n        if (nextMatches.length !== 2)\n            return;\n        if (!nextMatches[1])\n            throw Error('Second next match is null.');\n        // The second match is either the consolation final (single elimination) or a loser bracket match (double elimination).\n        if (matchLocation === 'single_bracket') {\n            setNextOpponent(nextMatches[1], nextSide, match, winnerSide && helpers.getOtherSide(winnerSide));\n            await this.applyMatchUpdate(nextMatches[1]);\n        }\n        else {\n            const nextSideLB = helpers.getNextSideLoserBracket(match.number, nextMatches[1], roundNumber);\n            setNextOpponent(nextMatches[1], nextSideLB, match, winnerSide && helpers.getOtherSide(winnerSide));\n            await this.propagateByeWinners(nextMatches[1]);\n        }\n    }\n    /**\n     * Propagates winner against BYEs in related matches.\n     *\n     * @param match The current match.\n     */\n    async propagateByeWinners(match) {\n        helpers.setMatchResults(match, match);\n        await this.applyMatchUpdate(match);\n        if (helpers.hasBye(match))\n            await this.updateRelatedMatches(match, true, true);\n    }\n}\nexports.BaseUpdater = BaseUpdater;\n//# sourceMappingURL=updater.js.map\n\n//# sourceURL=webpack://brackets-viewer/./node_modules/brackets-manager/dist/base/updater.js?");

/***/ }),

/***/ "./node_modules/brackets-manager/dist/create.js":
/*!******************************************************!*\
  !*** ./node_modules/brackets-manager/dist/create.js ***!
  \******************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.Create = exports.create = void 0;\nconst ordering_1 = __webpack_require__(/*! ./ordering */ \"./node_modules/brackets-manager/dist/ordering.js\");\nconst helpers = __webpack_require__(/*! ./helpers */ \"./node_modules/brackets-manager/dist/helpers.js\");\n/**\n * Creates a stage.\n *\n * @param this Instance of BracketsManager.\n * @param stage The stage to create.\n */\nasync function create(stage) {\n    const instance = new Create(this.storage, stage);\n    await instance.run();\n}\nexports.create = create;\nclass Create {\n    /**\n     * Creates an instance of Create, which will handle the creation of the stage.\n     *\n     * @param storage The implementation of Storage.\n     * @param stage The stage to create.\n     */\n    constructor(storage, stage) {\n        this.storage = storage;\n        this.stage = stage;\n        this.stage.settings = this.stage.settings || {};\n        this.seedOrdering = this.stage.settings.seedOrdering || [];\n        this.updateMode = false;\n        if (!this.stage.name)\n            throw Error('You must provide a name for the stage.');\n        if (!Number.isInteger(this.stage.tournamentId))\n            throw Error('You must provide a tournament id for the stage.');\n        if (stage.type === 'round_robin')\n            this.stage.settings.roundRobinMode = this.stage.settings.roundRobinMode || 'simple';\n        if (stage.type === 'single_elimination')\n            this.stage.settings.consolationFinal = this.stage.settings.consolationFinal || false;\n        if (stage.type === 'double_elimination')\n            this.stage.settings.grandFinal = this.stage.settings.grandFinal || 'none';\n        this.stage.settings.matchesChildCount = this.stage.settings.matchesChildCount || 0;\n    }\n    /**\n     * Run the creation process.\n     */\n    async run() {\n        let stageId = -1;\n        switch (this.stage.type) {\n            case 'round_robin':\n                stageId = await this.roundRobin();\n                break;\n            case 'single_elimination':\n                stageId = await this.singleElimination();\n                break;\n            case 'double_elimination':\n                stageId = await this.doubleElimination();\n                break;\n            default:\n                throw Error('Unknown stage type.');\n        }\n        if (stageId === -1)\n            throw Error('Something went wrong when creating the stage.');\n        await this.ensureSeedOrdering(stageId);\n    }\n    /**\n     * Enables the update mode.\n     *\n     * @param stageId ID of the stage.\n     */\n    setExisting(stageId) {\n        this.updateMode = true;\n        this.currentStageId = stageId;\n    }\n    /**\n     * Creates a round-robin stage.\n     *\n     * Group count must be given. It will distribute participants in groups and rounds.\n     */\n    async roundRobin() {\n        const groups = await this.getRoundRobinGroups();\n        const stageId = await this.createStage();\n        for (let i = 0; i < groups.length; i++)\n            await this.createRoundRobinGroup(stageId, i + 1, groups[i]);\n        return stageId;\n    }\n    /**\n     * Creates a single elimination stage.\n     *\n     * One bracket and optionally a consolation final between semi-final losers.\n     */\n    async singleElimination() {\n        var _a, _b;\n        if (Array.isArray((_a = this.stage.settings) === null || _a === void 0 ? void 0 : _a.seedOrdering) &&\n            ((_b = this.stage.settings) === null || _b === void 0 ? void 0 : _b.seedOrdering.length) !== 1)\n            throw Error('You must specify one seed ordering method.');\n        const slots = await this.getSlots();\n        const stageId = await this.createStage();\n        const method = this.getStandardBracketFirstRoundOrdering();\n        const ordered = ordering_1.ordering[method](slots);\n        const { losers } = await this.createStandardBracket(stageId, 1, ordered);\n        await this.createConsolationFinal(stageId, losers);\n        return stageId;\n    }\n    /**\n     * Creates a double elimination stage.\n     *\n     * One upper bracket (winner bracket, WB), one lower bracket (loser bracket, LB) and optionally a grand final\n     * between the winner of both bracket, which can be simple or double.\n     */\n    async doubleElimination() {\n        var _a;\n        if (this.stage.settings && Array.isArray(this.stage.settings.seedOrdering) &&\n            this.stage.settings.seedOrdering.length < 1)\n            throw Error('You must specify at least one seed ordering method.');\n        const slots = await this.getSlots();\n        const stageId = await this.createStage();\n        const method = this.getStandardBracketFirstRoundOrdering();\n        const ordered = ordering_1.ordering[method](slots);\n        if ((_a = this.stage.settings) === null || _a === void 0 ? void 0 : _a.skipFirstRound)\n            return this.createDoubleEliminationSkipFirstRound(stageId, ordered);\n        return this.createDoubleElimination(stageId, ordered);\n    }\n    /**\n     * Creates a double elimination stage with skip first round option.\n     *\n     * @param stageId ID of the stage.\n     * @param slots A list of slots.\n     */\n    async createDoubleEliminationSkipFirstRound(stageId, slots) {\n        var _a;\n        const { even: directInWb, odd: directInLb } = helpers.splitByParity(slots);\n        const { losers: losersWb, winner: winnerWb } = await this.createStandardBracket(stageId, 1, directInWb);\n        if (helpers.isDoubleEliminationNecessary((_a = this.stage.settings) === null || _a === void 0 ? void 0 : _a.size)) {\n            const winnerLb = await this.createLowerBracket(stageId, 2, [directInLb, ...losersWb]);\n            await this.createGrandFinal(stageId, winnerWb, winnerLb);\n        }\n        return stageId;\n    }\n    /**\n     * Creates a double elimination stage.\n     *\n     * @param stageId ID of the stage.\n     * @param slots A list of slots.\n     */\n    async createDoubleElimination(stageId, slots) {\n        var _a;\n        const { losers: losersWb, winner: winnerWb } = await this.createStandardBracket(stageId, 1, slots);\n        if (helpers.isDoubleEliminationNecessary((_a = this.stage.settings) === null || _a === void 0 ? void 0 : _a.size)) {\n            const winnerLb = await this.createLowerBracket(stageId, 2, losersWb);\n            await this.createGrandFinal(stageId, winnerWb, winnerLb);\n        }\n        return stageId;\n    }\n    /**\n     * Creates a round-robin group.\n     *\n     * This will make as many rounds as needed to let each participant match every other once.\n     *\n     * @param stageId ID of the parent stage.\n     * @param number Number in the stage.\n     * @param slots A list of slots.\n     */\n    async createRoundRobinGroup(stageId, number, slots) {\n        var _a;\n        const groupId = await this.insertGroup({\n            stage_id: stageId,\n            number,\n        });\n        if (groupId === -1)\n            throw Error('Could not insert the group.');\n        const rounds = helpers.makeRoundRobinMatches(slots, (_a = this.stage.settings) === null || _a === void 0 ? void 0 : _a.roundRobinMode);\n        for (let i = 0; i < rounds.length; i++)\n            await this.createRound(stageId, groupId, i + 1, rounds[0].length, rounds[i]);\n    }\n    /**\n     * Creates a standard bracket, which is the only one in single elimination and the upper one in double elimination.\n     *\n     * This will make as many rounds as needed to end with one winner.\n     *\n     * @param stageId ID of the parent stage.\n     * @param number Number in the stage.\n     * @param slots A list of slots.\n     */\n    async createStandardBracket(stageId, number, slots) {\n        const roundCount = helpers.getUpperBracketRoundCount(slots.length);\n        const groupId = await this.insertGroup({\n            stage_id: stageId,\n            number,\n        });\n        if (groupId === -1)\n            throw Error('Could not insert the group.');\n        let duels = helpers.makePairs(slots);\n        let roundNumber = 1;\n        const losers = [];\n        for (let i = roundCount - 1; i >= 0; i--) {\n            const matchCount = Math.pow(2, i);\n            duels = this.getCurrentDuels(duels, matchCount);\n            losers.push(duels.map(helpers.byeLoser));\n            await this.createRound(stageId, groupId, roundNumber++, matchCount, duels);\n        }\n        return { losers, winner: helpers.byeWinner(duels[0]) };\n    }\n    /**\n     * Creates a lower bracket, alternating between major and minor rounds.\n     *\n     * - A major round is a regular round.\n     * - A minor round matches the previous (major) round's winners against upper bracket losers of the corresponding round.\n     *\n     * @param stageId ID of the parent stage.\n     * @param number Number in the stage.\n     * @param losers One list of losers per upper bracket round.\n     */\n    async createLowerBracket(stageId, number, losers) {\n        var _a;\n        const participantCount = (_a = this.stage.settings) === null || _a === void 0 ? void 0 : _a.size;\n        const roundPairCount = helpers.getRoundPairCount(participantCount);\n        let losersId = 0;\n        const method = this.getMajorOrdering(participantCount);\n        const ordered = ordering_1.ordering[method](losers[losersId++]);\n        const groupId = await this.insertGroup({\n            stage_id: stageId,\n            number,\n        });\n        if (groupId === -1)\n            throw Error('Could not insert the group.');\n        let duels = helpers.makePairs(ordered);\n        let roundNumber = 1;\n        for (let i = 0; i < roundPairCount; i++) {\n            const matchCount = Math.pow(2, roundPairCount - i - 1);\n            // Major round.\n            duels = this.getCurrentDuels(duels, matchCount, true);\n            await this.createRound(stageId, groupId, roundNumber++, matchCount, duels);\n            // Minor round.\n            const minorOrdering = this.getMinorOrdering(participantCount, i, roundPairCount);\n            duels = this.getCurrentDuels(duels, matchCount, false, losers[losersId++], minorOrdering);\n            await this.createRound(stageId, groupId, roundNumber++, matchCount, duels);\n        }\n        return helpers.byeWinnerToGrandFinal(duels[0]);\n    }\n    /**\n     * Creates a bracket with rounds that only have 1 match each. Used for finals.\n     *\n     * @param stageId ID of the parent stage.\n     * @param number Number in the stage.\n     * @param duels A list of duels.\n     */\n    async createUniqueMatchBracket(stageId, number, duels) {\n        const groupId = await this.insertGroup({\n            stage_id: stageId,\n            number,\n        });\n        if (groupId === -1)\n            throw Error('Could not insert the group.');\n        for (let i = 0; i < duels.length; i++)\n            await this.createRound(stageId, groupId, i + 1, 1, [duels[i]]);\n    }\n    /**\n     * Creates a round, which contain matches.\n     *\n     * @param stageId ID of the parent stage.\n     * @param groupId ID of the parent group.\n     * @param roundNumber Number in the group.\n     * @param matchCount Duel/match count.\n     * @param duels A list of duels.\n     */\n    async createRound(stageId, groupId, roundNumber, matchCount, duels) {\n        const matchesChildCount = this.getMatchesChildCount();\n        const roundId = await this.insertRound({\n            number: roundNumber,\n            stage_id: stageId,\n            group_id: groupId,\n        });\n        if (roundId === -1)\n            throw Error('Could not insert the round.');\n        for (let i = 0; i < matchCount; i++)\n            await this.createMatch(stageId, groupId, roundId, i + 1, duels[i], matchesChildCount);\n    }\n    /**\n     * Creates a match, possibly with match games.\n     *\n     * - If `childCount` is 0, then there is no children. The score of the match is directly its intrinsic score.\n     * - If `childCount` is greater than 0, then the score of the match will automatically be calculated based on its child games.\n     *\n     * @param stageId ID of the parent stage.\n     * @param groupId ID of the parent group.\n     * @param roundId ID of the parent round.\n     * @param matchNumber Number in the round.\n     * @param opponents The two opponents matching against each other.\n     * @param childCount Child count for this match (number of games).\n     */\n    async createMatch(stageId, groupId, roundId, matchNumber, opponents, childCount) {\n        const opponent1 = helpers.toResultWithPosition(opponents[0]);\n        const opponent2 = helpers.toResultWithPosition(opponents[1]);\n        // Round-robin matches can easily be removed. Prevent BYE vs. BYE matches.\n        if (this.stage.type === 'round_robin' && opponent1 === null && opponent2 === null)\n            return;\n        const status = helpers.getMatchByeStatus(opponents);\n        let existing = null;\n        if (this.updateMode) {\n            existing = await this.storage.selectFirst('match', {\n                round_id: roundId,\n                number: matchNumber,\n            });\n            const currentChildCount = existing === null || existing === void 0 ? void 0 : existing.child_count;\n            childCount = currentChildCount === undefined ? childCount : currentChildCount;\n        }\n        const parentId = await this.insertMatch({\n            number: matchNumber,\n            stage_id: stageId,\n            group_id: groupId,\n            round_id: roundId,\n            child_count: childCount,\n            status: status,\n            opponent1,\n            opponent2,\n        }, existing);\n        if (parentId === -1)\n            throw Error('Could not insert the match.');\n        for (let i = 0; i < childCount; i++) {\n            const id = await this.insertMatchGame({\n                number: i + 1,\n                stage_id: stageId,\n                parent_id: parentId,\n                status: status,\n                opponent1: helpers.toResult(opponents[0]),\n                opponent2: helpers.toResult(opponents[1]),\n            });\n            if (id === -1)\n                throw Error('Could not insert the match game.');\n        }\n    }\n    /**\n     * Generic implementation.\n     *\n     * @param previousDuels Always given.\n     * @param currentDuelCount Always given.\n     * @param major Only for loser bracket.\n     * @param losers Only for minor rounds of loser bracket.\n     * @param method Only for minor rounds. Ordering method for the losers.\n     */\n    getCurrentDuels(previousDuels, currentDuelCount, major, losers, method) {\n        if ((major === undefined || major) && previousDuels.length === currentDuelCount) {\n            // First round.\n            return previousDuels;\n        }\n        if (major === undefined || major) {\n            // From major to major (WB) or minor to major (LB).\n            return helpers.transitionToMajor(previousDuels);\n        }\n        // From major to minor (LB).\n        // Losers and method won't be undefined.\n        return helpers.transitionToMinor(previousDuels, losers, method);\n    }\n    /**\n     * Returns a list of slots.\n     * - If `seeding` was given, inserts them in the storage.\n     * - If `size` was given, only returns a list of empty slots.\n     *\n     * @param positions An optional list of positions (seeds) for a manual ordering.\n     */\n    async getSlots(positions) {\n        var _a, _b;\n        const size = ((_a = this.stage.settings) === null || _a === void 0 ? void 0 : _a.size) || ((_b = this.stage.seeding) === null || _b === void 0 ? void 0 : _b.length) || 0;\n        helpers.ensureValidSize(size);\n        if (size && !this.stage.seeding)\n            return Array.from(Array(size), (_, i) => ({ id: null, position: i + 1 }));\n        if (!this.stage.seeding)\n            throw Error('Either size or seeding must be given.');\n        this.stage.settings = {\n            ...this.stage.settings,\n            size, // Always set the size.\n        };\n        helpers.ensureNoDuplicates(this.stage.seeding);\n        this.stage.seeding = helpers.fixSeeding(this.stage.seeding, size);\n        if (this.stage.type !== 'round_robin' && this.stage.settings.balanceByes)\n            this.stage.seeding = helpers.balanceByes(this.stage.seeding, this.stage.settings.size);\n        if (helpers.isSeedingWithIds(this.stage.seeding))\n            return this.getSlotsUsingIds(this.stage.seeding, positions);\n        return this.getSlotsUsingNames(this.stage.seeding, positions);\n    }\n    /**\n     * Returns the list of slots with a seeding containing names. Participants may be added to database.\n     *\n     * @param seeding The seeding (names).\n     * @param positions An optional list of positions (seeds) for a manual ordering.\n     */\n    async getSlotsUsingNames(seeding, positions) {\n        const participants = helpers.extractParticipantsFromSeeding(this.stage.tournamentId, seeding);\n        if (!await this.registerParticipants(participants))\n            throw Error('Error registering the participants.');\n        // Get participants back with IDs.\n        const added = await this.storage.select('participant', { tournament_id: this.stage.tournamentId });\n        if (!added)\n            throw Error('Error getting registered participant.');\n        return helpers.mapParticipantsNamesToDatabase(seeding, added, positions);\n    }\n    /**\n     * Returns the list of slots with a seeding containing IDs. No database mutation.\n     *\n     * @param seeding The seeding (IDs).\n     * @param positions An optional list of positions (seeds) for a manual ordering.\n     */\n    async getSlotsUsingIds(seeding, positions) {\n        const participants = await this.storage.select('participant', { tournament_id: this.stage.tournamentId });\n        if (!participants)\n            throw Error('No available participants.');\n        return helpers.mapParticipantsIdsToDatabase(seeding, participants, positions);\n    }\n    /**\n     * Gets the current stage number based on existing stages.\n     */\n    async getStageNumber() {\n        const stages = await this.storage.select('stage', { tournament_id: this.stage.tournamentId });\n        const stageNumbers = stages === null || stages === void 0 ? void 0 : stages.map(stage => stage.number);\n        if (this.stage.number !== undefined) {\n            if (stageNumbers === null || stageNumbers === void 0 ? void 0 : stageNumbers.includes(this.stage.number))\n                throw Error('The given stage number already exists.');\n            return this.stage.number;\n        }\n        if (!(stageNumbers === null || stageNumbers === void 0 ? void 0 : stageNumbers.length))\n            return 1;\n        const maxNumber = Math.max(...stageNumbers);\n        return maxNumber + 1;\n    }\n    /**\n     * Safely gets `matchesChildCount` in the stage input settings.\n     */\n    getMatchesChildCount() {\n        var _a;\n        if (!((_a = this.stage.settings) === null || _a === void 0 ? void 0 : _a.matchesChildCount))\n            return 0;\n        return this.stage.settings.matchesChildCount;\n    }\n    /**\n     * Safely gets an ordering by its index in the stage input settings.\n     *\n     * @param orderingIndex Index of the ordering.\n     * @param stageType A value indicating if the method should be a group method or not.\n     * @param defaultMethod The default method to use if not given.\n     */\n    getOrdering(orderingIndex, stageType, defaultMethod) {\n        var _a;\n        if (!((_a = this.stage.settings) === null || _a === void 0 ? void 0 : _a.seedOrdering)) {\n            this.seedOrdering.push(defaultMethod);\n            return defaultMethod;\n        }\n        const method = this.stage.settings.seedOrdering[orderingIndex];\n        if (!method) {\n            this.seedOrdering.push(defaultMethod);\n            return defaultMethod;\n        }\n        if (stageType === 'elimination' && method.match(/^groups\\./))\n            throw Error('You must specify a seed ordering method without a \\'groups\\' prefix');\n        if (stageType === 'groups' && method !== 'natural' && !method.match(/^groups\\./))\n            throw Error('You must specify a seed ordering method with a \\'groups\\' prefix');\n        return method;\n    }\n    /**\n     * Gets the duels in groups for a round-robin stage.\n     */\n    async getRoundRobinGroups() {\n        var _a, _b, _c, _d, _e;\n        if (((_a = this.stage.settings) === null || _a === void 0 ? void 0 : _a.groupCount) === undefined)\n            throw Error('You must specify a group count for round-robin stages.');\n        if ((_b = this.stage.settings) === null || _b === void 0 ? void 0 : _b.manualOrdering) {\n            if (((_c = this.stage.settings) === null || _c === void 0 ? void 0 : _c.manualOrdering.length) !== ((_d = this.stage.settings) === null || _d === void 0 ? void 0 : _d.groupCount))\n                throw Error('Group count in the manual ordering does not correspond to the given group count.');\n            const positions = (_e = this.stage.settings) === null || _e === void 0 ? void 0 : _e.manualOrdering.flat();\n            const slots = await this.getSlots(positions);\n            return helpers.makeGroups(slots, this.stage.settings.groupCount);\n        }\n        if (Array.isArray(this.stage.settings.seedOrdering) && this.stage.settings.seedOrdering.length !== 1)\n            throw Error('You must specify one seed ordering method.');\n        const method = this.getRoundRobinOrdering();\n        const slots = await this.getSlots();\n        const ordered = ordering_1.ordering[method](slots, this.stage.settings.groupCount);\n        return helpers.makeGroups(ordered, this.stage.settings.groupCount);\n    }\n    /**\n     * Returns the ordering method for the groups in a round-robin stage.\n     */\n    getRoundRobinOrdering() {\n        return this.getOrdering(0, 'groups', 'groups.effort_balanced');\n    }\n    /**\n     * Returns the ordering method for the first round of the upper bracket of an elimination stage.\n     */\n    getStandardBracketFirstRoundOrdering() {\n        return this.getOrdering(0, 'elimination', 'inner_outer');\n    }\n    /**\n     * Safely gets the only major ordering for the lower bracket.\n     *\n     * @param participantCount Number of participants in the stage.\n     */\n    getMajorOrdering(participantCount) {\n        return this.getOrdering(1, 'elimination', ordering_1.defaultMinorOrdering[participantCount][0]);\n    }\n    /**\n     * Safely gets a minor ordering for the lower bracket by its index.\n     *\n     * @param participantCount Number of participants in the stage.\n     * @param index Index of the minor round.\n     * @param minorRoundCount Number of minor rounds.\n     */\n    getMinorOrdering(participantCount, index, minorRoundCount) {\n        // No ordering for the last minor round. There is only one participant to order.\n        if (index === minorRoundCount - 1)\n            return undefined;\n        return this.getOrdering(2 + index, 'elimination', ordering_1.defaultMinorOrdering[participantCount][1 + index]);\n    }\n    /**\n     * Inserts a stage or finds an existing one.\n     *\n     * @param stage The stage to insert.\n     */\n    async insertStage(stage) {\n        let existing = null;\n        if (this.updateMode)\n            existing = await this.storage.select('stage', this.currentStageId);\n        if (!existing)\n            return this.storage.insert('stage', stage);\n        return existing.id;\n    }\n    /**\n     * Inserts a group or finds an existing one.\n     *\n     * @param group The group to insert.\n     */\n    async insertGroup(group) {\n        let existing = null;\n        if (this.updateMode) {\n            existing = await this.storage.selectFirst('group', {\n                stage_id: group.stage_id,\n                number: group.number,\n            });\n        }\n        if (!existing)\n            return this.storage.insert('group', group);\n        return existing.id;\n    }\n    /**\n     * Inserts a round or finds an existing one.\n     *\n     * @param round The round to insert.\n     */\n    async insertRound(round) {\n        let existing = null;\n        if (this.updateMode) {\n            existing = await this.storage.selectFirst('round', {\n                group_id: round.group_id,\n                number: round.number,\n            });\n        }\n        if (!existing)\n            return this.storage.insert('round', round);\n        return existing.id;\n    }\n    /**\n     * Inserts a match or updates an existing one.\n     *\n     * @param match The match to insert.\n     * @param existing An existing match corresponding to the current one.\n     */\n    async insertMatch(match, existing) {\n        if (!existing)\n            return this.storage.insert('match', match);\n        if (!await this.storage.update('match', existing.id, { ...existing, ...helpers.getUpdatedMatchResults(match) }))\n            throw Error('Could not update the match.');\n        return existing.id;\n    }\n    /**\n     * Inserts a match game or finds an existing one (and updates it).\n     *\n     * @param matchGame The match game to insert.\n     */\n    async insertMatchGame(matchGame) {\n        let existing = null;\n        if (this.updateMode) {\n            existing = await this.storage.selectFirst('match_game', {\n                parent_id: matchGame.parent_id,\n                number: matchGame.number,\n            });\n        }\n        if (!existing)\n            return this.storage.insert('match_game', matchGame);\n        if (!await this.storage.update('match_game', existing.id, { ...existing, ...helpers.getUpdatedMatchResults(matchGame) }))\n            throw Error('Could not update the match game.');\n        return existing.id;\n    }\n    /**\n     * Inserts missing participants.\n     *\n     * @param participants The list of participants to process.\n     */\n    async registerParticipants(participants) {\n        const existing = await this.storage.select('participant', { tournament_id: this.stage.tournamentId });\n        // Insert all if nothing.\n        if (!existing || existing.length === 0)\n            return this.storage.insert('participant', participants);\n        // Insert only missing otherwise.\n        for (const participant of participants) {\n            if (existing.some(value => value.name === participant.name))\n                continue;\n            const result = await this.storage.insert('participant', participant);\n            if (result === -1)\n                return false;\n        }\n        return true;\n    }\n    /**\n     * Creates a new stage.\n     */\n    async createStage() {\n        const stageNumber = await this.getStageNumber();\n        const stageId = await this.insertStage({\n            tournament_id: this.stage.tournamentId,\n            name: this.stage.name,\n            type: this.stage.type,\n            number: stageNumber,\n            settings: this.stage.settings || {},\n        });\n        if (stageId === -1)\n            throw Error('Could not insert the stage.');\n        return stageId;\n    }\n    /**\n     * Creates a consolation final for the semi final losers of a single elimination stage.\n     *\n     * @param stageId ID of the stage.\n     * @param losers The semi final losers who will play the consolation final.\n     */\n    async createConsolationFinal(stageId, losers) {\n        var _a;\n        if (!((_a = this.stage.settings) === null || _a === void 0 ? void 0 : _a.consolationFinal))\n            return;\n        const semiFinalLosers = losers[losers.length - 2];\n        await this.createUniqueMatchBracket(stageId, 2, [semiFinalLosers]);\n    }\n    /**\n     * Creates a grand final (none, simple or double) for winners of both bracket in a double elimination stage.\n     *\n     * @param stageId ID of the stage.\n     * @param winnerWb The winner of the winner bracket.\n     * @param winnerLb The winner of the loser bracket.\n     */\n    async createGrandFinal(stageId, winnerWb, winnerLb) {\n        var _a;\n        // No Grand Final by default.\n        const grandFinal = (_a = this.stage.settings) === null || _a === void 0 ? void 0 : _a.grandFinal;\n        if (grandFinal === 'none')\n            return;\n        // One duel by default.\n        const finalDuels = [[winnerWb, winnerLb]];\n        // Second duel.\n        if (grandFinal === 'double')\n            finalDuels.push([{ id: null }, { id: null }]);\n        await this.createUniqueMatchBracket(stageId, 3, finalDuels);\n    }\n    /**\n     * Ensures that the seed ordering list is stored even if it was not given in the first place.\n     *\n     * @param stageId ID of the stage.\n     */\n    async ensureSeedOrdering(stageId) {\n        var _a, _b;\n        if (((_b = (_a = this.stage.settings) === null || _a === void 0 ? void 0 : _a.seedOrdering) === null || _b === void 0 ? void 0 : _b.length) === this.seedOrdering.length)\n            return;\n        const stage = await this.storage.select('stage', stageId);\n        if (!stage)\n            throw Error('Stage not found.');\n        stage.settings = {\n            ...stage.settings,\n            seedOrdering: this.seedOrdering,\n        };\n        if (!await this.storage.update('stage', stageId, stage))\n            throw Error('Could not update the stage.');\n    }\n}\nexports.Create = Create;\n//# sourceMappingURL=create.js.map\n\n//# sourceURL=webpack://brackets-viewer/./node_modules/brackets-manager/dist/create.js?");

/***/ }),

/***/ "./node_modules/brackets-manager/dist/delete.js":
/*!******************************************************!*\
  !*** ./node_modules/brackets-manager/dist/delete.js ***!
  \******************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.Delete = void 0;\nclass Delete {\n    /**\n     * Creates an instance of Delete, which will handle cleanly deleting data in the storage.\n     *\n     * @param storage The implementation of Storage.\n     */\n    constructor(storage) {\n        this.storage = storage;\n    }\n    /**\n     * Deletes a stage.\n     *\n     * @param stageId ID of the stage.\n     */\n    async stage(stageId) {\n        // The order is important because the abstract storage possibly has foreign checks.\n        if (!this.storage.delete('match_game', { stage_id: stageId }))\n            throw Error('Could not delete match games.');\n        if (!this.storage.delete('match', { stage_id: stageId }))\n            throw Error('Could not delete matches.');\n        if (!this.storage.delete('round', { stage_id: stageId }))\n            throw Error('Could not delete rounds.');\n        if (!this.storage.delete('group', { stage_id: stageId }))\n            throw Error('Could not delete groups.');\n        if (!this.storage.delete('stage', { id: stageId }))\n            throw Error('Could not delete stages.');\n    }\n}\nexports.Delete = Delete;\n//# sourceMappingURL=delete.js.map\n\n//# sourceURL=webpack://brackets-viewer/./node_modules/brackets-manager/dist/delete.js?");

/***/ }),

/***/ "./node_modules/brackets-manager/dist/find.js":
/*!****************************************************!*\
  !*** ./node_modules/brackets-manager/dist/find.js ***!
  \****************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.Find = void 0;\nconst getter_1 = __webpack_require__(/*! ./base/getter */ \"./node_modules/brackets-manager/dist/base/getter.js\");\nconst helpers = __webpack_require__(/*! ./helpers */ \"./node_modules/brackets-manager/dist/helpers.js\");\nclass Find extends getter_1.BaseGetter {\n    /**\n     * Gets the upper bracket (the only bracket if single elimination or the winner bracket in double elimination).\n     *\n     * @param stageId ID of the stage.\n     */\n    async upperBracket(stageId) {\n        const stage = await this.storage.select('stage', stageId);\n        if (!stage)\n            throw Error('Stage not found.');\n        switch (stage.type) {\n            case 'round_robin':\n                throw Error('Round robin stages do not have an upper bracket.');\n            case 'single_elimination':\n            case 'double_elimination':\n                return this.getUpperBracket(stageId);\n            default:\n                throw Error('Unknown stage type.');\n        }\n    }\n    /**\n     * Gets the loser bracket.\n     *\n     * @param stageId ID of the stage.\n     */\n    async loserBracket(stageId) {\n        const stage = await this.storage.select('stage', stageId);\n        if (!stage)\n            throw Error('Stage not found.');\n        switch (stage.type) {\n            case 'round_robin':\n                throw Error('Round robin stages do not have a loser bracket.');\n            case 'single_elimination':\n                throw Error('Single elimination stages do not have a loser bracket.');\n            case 'double_elimination':\n                this.getLoserBracket(stageId);\n            default:\n                throw Error('Unknown stage type.');\n        }\n    }\n    /**\n     * Returns the matches leading to the given match.\n     *\n     * @param matchId ID of the target match.\n     */\n    async previousMatches(matchId) {\n        const match = await this.storage.select('match', matchId);\n        if (!match)\n            throw Error('Match not found.');\n        const stage = await this.storage.select('stage', match.stage_id);\n        if (!stage)\n            throw Error('Stage not found.');\n        const group = await this.storage.select('group', match.group_id);\n        if (!group)\n            throw Error('Group not found.');\n        const round = await this.storage.select('round', match.round_id);\n        if (!round)\n            throw Error('Round not found.');\n        const matchLocation = helpers.getMatchLocation(stage.type, group.number);\n        return this.getPreviousMatches(match, matchLocation, stage, round.number);\n    }\n    /**\n     * Returns the matches following the given match.\n     *\n     * @param matchId ID of the target match.\n     */\n    async nextMatches(matchId) {\n        const match = await this.storage.select('match', matchId);\n        if (!match)\n            throw Error('Match not found.');\n        const stage = await this.storage.select('stage', match.stage_id);\n        if (!stage)\n            throw Error('Stage not found.');\n        const group = await this.storage.select('group', match.group_id);\n        if (!group)\n            throw Error('Group not found.');\n        const { roundNumber, roundCount } = await this.getRoundPositionalInfo(match.round_id);\n        const matchLocation = helpers.getMatchLocation(stage.type, group.number);\n        const nextMatches = await this.getNextMatches(match, matchLocation, stage, roundNumber, roundCount);\n        return helpers.getNonNull(nextMatches);\n    }\n    /**\n     * Finds a match in a given group. The match must have the given number in a round of which the number in group is given.\n     *\n     * **Example:** In group of id 1, give me the 4th match in the 3rd round.\n     *\n     * @param groupId ID of the group.\n     * @param roundNumber Number of the round in its parent group.\n     * @param matchNumber Number of the match in its parent round.\n     */\n    async match(groupId, roundNumber, matchNumber) {\n        return this.findMatch(groupId, roundNumber, matchNumber);\n    }\n    /**\n     * Finds a match game based on its `id` or based on the combination of its `parent_id` and `number`.\n     *\n     * @param game Values to change in a match game.\n     */\n    async matchGame(game) {\n        return this.findMatchGame(game);\n    }\n}\nexports.Find = Find;\n//# sourceMappingURL=find.js.map\n\n//# sourceURL=webpack://brackets-viewer/./node_modules/brackets-manager/dist/find.js?");

/***/ }),

/***/ "./node_modules/brackets-manager/dist/get.js":
/*!***************************************************!*\
  !*** ./node_modules/brackets-manager/dist/get.js ***!
  \***************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.Get = void 0;\nconst getter_1 = __webpack_require__(/*! ./base/getter */ \"./node_modules/brackets-manager/dist/base/getter.js\");\nconst helpers = __webpack_require__(/*! ./helpers */ \"./node_modules/brackets-manager/dist/helpers.js\");\nclass Get extends getter_1.BaseGetter {\n    /**\n     * Returns the data needed to display a stage.\n     *\n     * @param stageId ID of the stage.\n     */\n    async stageData(stageId) {\n        const stage = await this.storage.select('stage', stageId);\n        if (!stage)\n            throw Error('Stage not found.');\n        const groups = await this.storage.select('group', { stage_id: stageId });\n        if (!groups)\n            throw Error('Error getting groups.');\n        const rounds = await this.storage.select('round', { stage_id: stageId });\n        if (!rounds)\n            throw Error('Error getting rounds.');\n        const matches = await this.storage.select('match', { stage_id: stageId });\n        if (!matches)\n            throw Error('Error getting matches.');\n        const participants = await this.storage.select('participant', { tournament_id: stage.tournament_id });\n        if (!participants)\n            throw Error('Error getting participants.');\n        const matchGames = await this.matchGames(matches);\n        return {\n            stage: [stage],\n            group: groups,\n            round: rounds,\n            match: matches,\n            match_game: matchGames,\n            participant: participants,\n        };\n    }\n    /**\n     * Returns the match games associated to a list of matches.\n     *\n     * @param matches A list of matches.\n     */\n    async matchGames(matches) {\n        const parentMatches = matches.filter(match => match.child_count > 0);\n        const matchGamesQueries = await Promise.all(parentMatches.map(match => this.storage.select('match_game', { parent_id: match.id })));\n        if (matchGamesQueries.some(game => game === null))\n            throw Error('Error getting match games.');\n        return helpers.getNonNull(matchGamesQueries).flat();\n    }\n    /**\n     * Returns the seeding of a stage.\n     *\n     * @param stageId ID of the stage.\n     */\n    async seeding(stageId) {\n        const stage = await this.storage.select('stage', stageId);\n        if (!stage)\n            throw Error('Stage not found.');\n        if (stage.type === 'round_robin')\n            return this.roundRobinSeeding(stage);\n        return this.eliminationSeeding(stage);\n    }\n    /**\n     * Returns the final standings of a stage.\n     *\n     * @param stageId ID of the stage.\n     */\n    async finalStandings(stageId) {\n        const stage = await this.storage.select('stage', stageId);\n        if (!stage)\n            throw Error('Stage not found.');\n        switch (stage.type) {\n            case 'round_robin':\n                throw Error('A round-robin stage does not have standings.');\n            case 'single_elimination':\n                return this.singleEliminationStandings(stageId);\n            case 'double_elimination':\n                return this.doubleEliminationStandings(stageId);\n            default:\n                throw Error('Unknown stage type.');\n        }\n    }\n    /**\n     * Returns the seeding of a round-robin stage.\n     *\n     * @param stage The stage.\n     */\n    async roundRobinSeeding(stage) {\n        if (stage.settings.size === undefined)\n            throw Error('The size of the seeding is undefined.');\n        const matches = await this.storage.select('match', { stage_id: stage.id });\n        if (!matches)\n            throw Error('Error getting matches.');\n        const slots = helpers.matchesToSeeding(matches);\n        // BYE vs. BYE matches of a round-robin stage are removed\n        // when the stage is created. We need to add them back temporarily.\n        if (slots.length < stage.settings.size) {\n            const diff = stage.settings.size - slots.length;\n            for (let i = 0; i < diff; i++)\n                slots.push(null);\n        }\n        const unique = helpers.uniqueBy(slots, item => item && item.position);\n        const seeding = helpers.setArraySize(unique, stage.settings.size, null);\n        return seeding;\n    }\n    /**\n     * Returns the seeding of an elimination stage.\n     *\n     * @param stage The stage.\n     */\n    async eliminationSeeding(stage) {\n        const round = await this.storage.selectFirst('round', { stage_id: stage.id, number: 1 });\n        if (!round)\n            throw Error('Error getting the first round.');\n        const matches = await this.storage.select('match', { round_id: round.id });\n        if (!matches)\n            throw Error('Error getting matches.');\n        return helpers.matchesToSeeding(matches);\n    }\n    /**\n     * Returns the final standings of a single elimination stage.\n     *\n     * @param stageId ID of the stage.\n     */\n    async singleEliminationStandings(stageId) {\n        var _a;\n        const grouped = [];\n        const { stage: stages, group: groups, match: matches, participant: participants } = await this.stageData(stageId);\n        const [stage] = stages;\n        const [singleBracket, finalGroup] = groups;\n        const final = matches.filter(match => match.group_id === singleBracket.id).pop();\n        if (!final)\n            throw Error('Final not found.');\n        // 1st place: Final winner.\n        grouped[0] = [helpers.findParticipant(participants, helpers.getWinner(final))];\n        // Rest: every loser in reverse order.\n        const losers = helpers.getLosers(participants, matches.filter(match => match.group_id === singleBracket.id));\n        grouped.push(...losers.reverse());\n        if ((_a = stage.settings) === null || _a === void 0 ? void 0 : _a.consolationFinal) {\n            const consolationFinal = matches.filter(match => match.group_id === finalGroup.id).pop();\n            if (!consolationFinal)\n                throw Error('Consolation final not found.');\n            // Overwrite semi-final losers with the consolation final results.\n            grouped[2][0] = helpers.findParticipant(participants, helpers.getWinner(consolationFinal));\n            grouped[2][1] = helpers.findParticipant(participants, helpers.getLoser(consolationFinal));\n        }\n        return helpers.makeFinalStandings(grouped);\n    }\n    /**\n     * Returns the final standings of a double elimination stage.\n     *\n     * @param stageId ID of the stage.\n     */\n    async doubleEliminationStandings(stageId) {\n        var _a, _b;\n        const grouped = [];\n        const { stage: stages, group: groups, match: matches, participant: participants } = await this.stageData(stageId);\n        const [stage] = stages;\n        const [winnerBracket, loserBracket, finalGroup] = groups;\n        if (((_a = stage.settings) === null || _a === void 0 ? void 0 : _a.grandFinal) === 'none') {\n            const finalWB = matches.filter(match => match.group_id === winnerBracket.id).pop();\n            if (!finalWB)\n                throw Error('WB final not found.');\n            const finalLB = matches.filter(match => match.group_id === loserBracket.id).pop();\n            if (!finalLB)\n                throw Error('LB final not found.');\n            // 1st place: WB Final winner.\n            grouped[0] = [helpers.findParticipant(participants, helpers.getWinner(finalWB))];\n            // 2nd place: LB Final winner.\n            grouped[1] = [helpers.findParticipant(participants, helpers.getWinner(finalLB))];\n        }\n        else {\n            const grandFinalMatches = matches.filter(match => match.group_id === finalGroup.id);\n            const decisiveMatch = helpers.getGrandFinalDecisiveMatch(((_b = stage.settings) === null || _b === void 0 ? void 0 : _b.grandFinal) || 'none', grandFinalMatches);\n            // 1st place: Grand Final winner.\n            grouped[0] = [helpers.findParticipant(participants, helpers.getWinner(decisiveMatch))];\n            // 2nd place: Grand Final loser.\n            grouped[1] = [helpers.findParticipant(participants, helpers.getLoser(decisiveMatch))];\n        }\n        // Rest: every loser in reverse order.\n        const losers = helpers.getLosers(participants, matches.filter(match => match.group_id === loserBracket.id));\n        grouped.push(...losers.reverse());\n        return helpers.makeFinalStandings(grouped);\n    }\n}\nexports.Get = Get;\n//# sourceMappingURL=get.js.map\n\n//# sourceURL=webpack://brackets-viewer/./node_modules/brackets-manager/dist/get.js?");

/***/ }),

/***/ "./node_modules/brackets-manager/dist/helpers.js":
/*!*******************************************************!*\
  !*** ./node_modules/brackets-manager/dist/helpers.js ***!
  \*******************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.getNextSideLoserBracket = exports.getNextSide = exports.findParticipant = exports.getGrandFinalDecisiveMatch = exports.makeFinalStandings = exports.getLosers = exports.getOriginPosition = exports.getOpponentId = exports.resetMatchResults = exports.setMatchResults = exports.getMatchStatus = exports.hasBye = exports.getMatchByeStatus = exports.isMatchParticipantLocked = exports.isMatchUpdateLocked = exports.isMatchByeCompleted = exports.isMatchWinCompleted = exports.isMatchDrawCompleted = exports.isMatchResultCompleted = exports.isMatchForfeitCompleted = exports.isMatchCompleted = exports.isMatchStarted = exports.getOtherSide = exports.getSide = exports.findPosition = exports.getMatchResult = exports.byeLoser = exports.byeWinnerToGrandFinal = exports.byeWinner = exports.getLoser = exports.getWinner = exports.toResultWithPosition = exports.toResult = exports.ensureNotTied = exports.ensureValidSize = exports.fixSeeding = exports.ensureEquallySized = exports.ensureNoDuplicates = exports.ensureEvenSized = exports.makePairs = exports.setArraySize = exports.normalizeParticipant = exports.makeNormalizedIdMapping = exports.normalizeIds = exports.balanceByes = exports.makeGroups = exports.assertRoundRobin = exports.makeRoundRobinDistribution = exports.makeRoundRobinMatches = exports.splitByParity = void 0;\nexports.getMatchLocation = exports.isFinalGroup = exports.isLoserBracket = exports.isWinnerBracket = exports.ensureNotRoundRobin = exports.isRoundRobin = exports.getNearestPowerOfTwo = exports.getDiagonalMatchNumber = exports.lowerBracketRoundCount = exports.getLoserOrdering = exports.getLoserRoundMatchCount = exports.findLoserMatchNumber = exports.isDoubleEliminationNecessary = exports.getRoundPairCount = exports.getUpperBracketRoundCount = exports.isOrderingSupportedLoserBracket = exports.isOrderingSupportedUpperBracket = exports.ensureOrderingSupported = exports.getSeedCount = exports.getSeeds = exports.getChildGamesResults = exports.getUpdatedMatchResults = exports.getParentMatchResults = exports.setParentMatchCompleted = exports.transitionToMinor = exports.transitionToMajor = exports.uniqueBy = exports.getNonNull = exports.sortSeeding = exports.matchesToSeeding = exports.mapParticipantsToDatabase = exports.mapParticipantsIdsToDatabase = exports.mapParticipantsNamesToDatabase = exports.extractParticipantsFromSeeding = exports.isSeedingWithIds = exports.setForfeits = exports.setResults = exports.setCompleted = exports.setScores = exports.invertOpponents = exports.handleOpponentsInversion = exports.resetNextOpponent = exports.setNextOpponent = void 0;\nconst brackets_model_1 = __webpack_require__(/*! brackets-model */ \"./node_modules/brackets-model/dist/index.js\");\nconst ordering_1 = __webpack_require__(/*! ./ordering */ \"./node_modules/brackets-manager/dist/ordering.js\");\n/**\n * Splits an array in two parts: one with even indices and the other with odd indices.\n *\n * @param array The array to split.\n */\nfunction splitByParity(array) {\n    return {\n        even: array.filter((_, i) => i % 2 === 0),\n        odd: array.filter((_, i) => i % 2 === 1),\n    };\n}\nexports.splitByParity = splitByParity;\n/**\n * Makes a list of rounds containing the matches of a round-robin group.\n *\n * @param participants The participants to distribute.\n * @param mode The round-robin mode.\n */\nfunction makeRoundRobinMatches(participants, mode = 'simple') {\n    const distribution = makeRoundRobinDistribution(participants);\n    if (mode === 'simple')\n        return distribution;\n    // Reverse rounds and their content.\n    const symmetry = distribution.map(round => [...round].reverse()).reverse();\n    return [...distribution, ...symmetry];\n}\nexports.makeRoundRobinMatches = makeRoundRobinMatches;\n/**\n * Distributes participants in rounds for a round-robin group.\n *\n * Conditions:\n * - Each participant plays each other once.\n * - Each participant plays once in each round.\n *\n * @param participants The participants to distribute.\n */\nfunction makeRoundRobinDistribution(participants) {\n    const n = participants.length;\n    const n1 = n % 2 === 0 ? n : n + 1;\n    const roundCount = n1 - 1;\n    const matchPerRound = n1 / 2;\n    const rounds = [];\n    for (let roundId = 0; roundId < roundCount; roundId++) {\n        const matches = [];\n        for (let matchId = 0; matchId < matchPerRound; matchId++) {\n            if (matchId === 0 && n % 2 === 1)\n                continue;\n            const opponentsIds = [\n                (roundId - matchId - 1 + n1) % (n1 - 1),\n                matchId === 0 ? n1 - 1 : (roundId + matchId) % (n1 - 1),\n            ];\n            matches.push([\n                participants[opponentsIds[0]],\n                participants[opponentsIds[1]],\n            ]);\n        }\n        rounds.push(matches);\n    }\n    return rounds;\n}\nexports.makeRoundRobinDistribution = makeRoundRobinDistribution;\n/**\n * A helper to assert our generated round-robin is correct.\n *\n * @param input The input seeding.\n * @param output The resulting distribution of seeds in groups.\n */\nfunction assertRoundRobin(input, output) {\n    const n = input.length;\n    const matchPerRound = Math.floor(n / 2);\n    const roundCount = n % 2 === 0 ? n - 1 : n;\n    if (output.length !== roundCount)\n        throw Error('Round count is wrong');\n    if (!output.every(round => round.length === matchPerRound))\n        throw Error('Not every round has the good number of matches');\n    const checkAllOpponents = Object.fromEntries(input.map(element => [element, new Set()]));\n    for (const round of output) {\n        const checkUnique = new Set();\n        for (const match of round) {\n            if (match.length !== 2)\n                throw Error('One match is not a pair');\n            if (checkUnique.has(match[0]))\n                throw Error('This team is already playing');\n            checkUnique.add(match[0]);\n            if (checkUnique.has(match[1]))\n                throw Error('This team is already playing');\n            checkUnique.add(match[1]);\n            if (checkAllOpponents[match[0]].has(match[1]))\n                throw Error('The team has already matched this team');\n            checkAllOpponents[match[0]].add(match[1]);\n            if (checkAllOpponents[match[1]].has(match[0]))\n                throw Error('The team has already matched this team');\n            checkAllOpponents[match[1]].add(match[0]);\n        }\n    }\n}\nexports.assertRoundRobin = assertRoundRobin;\n/**\n * Distributes elements in groups of equal size.\n *\n * @param elements A list of elements to distribute in groups.\n * @param groupCount The group count.\n */\nfunction makeGroups(elements, groupCount) {\n    const groupSize = Math.ceil(elements.length / groupCount);\n    const result = [];\n    for (let i = 0; i < elements.length; i++) {\n        if (i % groupSize === 0)\n            result.push([]);\n        result[result.length - 1].push(elements[i]);\n    }\n    return result;\n}\nexports.makeGroups = makeGroups;\n/**\n * Balances BYEs to prevents having BYE against BYE in matches.\n *\n * @param seeding The seeding of the stage.\n * @param participantCount The number of participants in the stage.\n */\nfunction balanceByes(seeding, participantCount) {\n    seeding = seeding.filter(v => v !== null);\n    participantCount = participantCount || getNearestPowerOfTwo(seeding.length);\n    if (seeding.length < participantCount / 2) {\n        const flat = seeding.map(v => [v, null]).flat();\n        return setArraySize(flat, participantCount, null);\n    }\n    const nonNullCount = seeding.length;\n    const nullCount = participantCount - nonNullCount;\n    const againstEachOther = seeding.slice(0, nonNullCount - nullCount).filter((_, i) => i % 2 === 0).map((_, i) => [seeding[2 * i], seeding[2 * i + 1]]);\n    const againstNull = seeding.slice(nonNullCount - nullCount, nonNullCount).map(v => [v, null]);\n    const flat = [...againstEachOther.flat(), ...againstNull.flat()];\n    return setArraySize(flat, participantCount, null);\n}\nexports.balanceByes = balanceByes;\n/**\n * Normalizes IDs in a database.\n *\n * Every ID - and references to it - is remapped to consecutive IDs starting from 0.\n *\n * @param data Data to normalize.\n */\nfunction normalizeIds(data) {\n    const mappings = {\n        participant: makeNormalizedIdMapping(data.participant),\n        stage: makeNormalizedIdMapping(data.stage),\n        group: makeNormalizedIdMapping(data.group),\n        round: makeNormalizedIdMapping(data.round),\n        match: makeNormalizedIdMapping(data.match),\n        match_game: makeNormalizedIdMapping(data.match_game),\n    };\n    return {\n        participant: data.participant.map(value => ({\n            ...value,\n            id: mappings.participant[value.id],\n        })),\n        stage: data.stage.map(value => ({\n            ...value,\n            id: mappings.stage[value.id],\n        })),\n        group: data.group.map(value => ({\n            ...value,\n            id: mappings.group[value.id],\n            stage_id: mappings.stage[value.stage_id],\n        })),\n        round: data.round.map(value => ({\n            ...value,\n            id: mappings.round[value.id],\n            stage_id: mappings.stage[value.stage_id],\n            group_id: mappings.group[value.group_id],\n        })),\n        match: data.match.map(value => ({\n            ...value,\n            id: mappings.match[value.id],\n            stage_id: mappings.stage[value.stage_id],\n            group_id: mappings.group[value.group_id],\n            round_id: mappings.round[value.round_id],\n            opponent1: normalizeParticipant(value.opponent1, mappings.participant),\n            opponent2: normalizeParticipant(value.opponent2, mappings.participant),\n        })),\n        match_game: data.match_game.map(value => ({\n            ...value,\n            id: mappings.match_game[value.id],\n            stage_id: mappings.stage[value.stage_id],\n            parent_id: mappings.match[value.parent_id],\n            opponent1: normalizeParticipant(value.opponent1, mappings.participant),\n            opponent2: normalizeParticipant(value.opponent2, mappings.participant),\n        })),\n    };\n}\nexports.normalizeIds = normalizeIds;\n/**\n * Makes a mapping between old IDs and new normalized IDs.\n *\n * @param elements A list of elements with IDs.\n */\nfunction makeNormalizedIdMapping(elements) {\n    let currentId = 0;\n    return elements.reduce((acc, current) => ({\n        ...acc,\n        [current.id]: currentId++,\n    }), {});\n}\nexports.makeNormalizedIdMapping = makeNormalizedIdMapping;\n/**\n * Apply a normalizing mapping to a participant.\n *\n * @param participant The participant.\n * @param mapping The mapping of IDs.\n */\nfunction normalizeParticipant(participant, mapping) {\n    if (participant === null)\n        return null;\n    return {\n        ...participant,\n        id: participant.id !== null ? mapping[participant.id] : null,\n    };\n}\nexports.normalizeParticipant = normalizeParticipant;\n/**\n * Sets the size of an array with a placeholder if the size is bigger.\n *\n * @param array The original array.\n * @param length The new length.\n * @param placeholder A placeholder to use to fill the empty space.\n */\nfunction setArraySize(array, length, placeholder) {\n    return Array.from(Array(length), (_, i) => array[i] || placeholder);\n}\nexports.setArraySize = setArraySize;\n/**\n * Makes pairs with each element and its next one.\n *\n * @example [1, 2, 3, 4] --> [[1, 2], [3, 4]]\n * @param array A list of elements.\n */\nfunction makePairs(array) {\n    return array.map((_, i) => (i % 2 === 0) ? [array[i], array[i + 1]] : []).filter((v) => v.length === 2);\n}\nexports.makePairs = makePairs;\n/**\n * Ensures that a list of elements has an even size.\n *\n * @param array A list of elements.\n */\nfunction ensureEvenSized(array) {\n    if (array.length % 2 === 1)\n        throw Error('Array size must be even.');\n}\nexports.ensureEvenSized = ensureEvenSized;\n/**\n * Ensures there are no duplicates in a list of elements.\n *\n * @param array A list of elements.\n */\nfunction ensureNoDuplicates(array) {\n    const nonNull = getNonNull(array);\n    const unique = [...new Set(nonNull)];\n    if (unique.length < nonNull.length)\n        throw new Error('The seeding has a duplicate participant.');\n}\nexports.ensureNoDuplicates = ensureNoDuplicates;\n/**\n * Ensures that two lists of elements have the same size.\n *\n * @param left The first list of elements.\n * @param right The second list of elements.\n */\nfunction ensureEquallySized(left, right) {\n    if (left.length !== right.length)\n        throw Error('Arrays\\' size must be equal.');\n}\nexports.ensureEquallySized = ensureEquallySized;\n/**\n * Fixes the seeding by enlarging it if it's not complete.\n *\n * @param seeding The seeding of the stage.\n * @param participantCount The number of participants in the stage.\n */\nfunction fixSeeding(seeding, participantCount) {\n    if (seeding.length > participantCount)\n        throw Error('The seeding has more participants than the size of the stage.');\n    if (seeding.length < participantCount)\n        return setArraySize(seeding, participantCount, null);\n    return seeding;\n}\nexports.fixSeeding = fixSeeding;\n/**\n * Ensures that the participant count is valid.\n *\n * @param participantCount The number to test.\n */\nfunction ensureValidSize(participantCount) {\n    if (participantCount === 0)\n        throw Error('Impossible to create an empty stage. If you want an empty seeding, just set the size of the stage.');\n    if (participantCount < 2)\n        throw Error('Impossible to create a stage with less than 2 participants.');\n    if (!Number.isInteger(Math.log2(participantCount)))\n        throw Error('The library only supports a participant count which is a power of two.');\n}\nexports.ensureValidSize = ensureValidSize;\n/**\n * Ensures that a match scores aren't tied.\n *\n * @param scores Two numbers which are scores.\n */\nfunction ensureNotTied(scores) {\n    if (scores[0] === scores[1])\n        throw Error(`${scores[0]} and ${scores[1]} are tied. It cannot be.`);\n}\nexports.ensureNotTied = ensureNotTied;\n/**\n * Converts a participant slot to a result stored in storage.\n *\n * @param slot A participant slot.\n */\nfunction toResult(slot) {\n    return slot && {\n        id: slot.id,\n    };\n}\nexports.toResult = toResult;\n/**\n * Converts a participant slot to a result stored in storage, with the position the participant is coming from.\n *\n * @param slot A participant slot.\n */\nfunction toResultWithPosition(slot) {\n    return slot && {\n        id: slot.id,\n        position: slot.position,\n    };\n}\nexports.toResultWithPosition = toResultWithPosition;\n/**\n * Returns the winner of a match.\n *\n * @param match The match.\n */\nfunction getWinner(match) {\n    const winnerSide = getMatchResult(match);\n    if (!winnerSide)\n        return null;\n    return match[winnerSide];\n}\nexports.getWinner = getWinner;\n/**\n * Returns the loser of a match.\n *\n * @param match The match.\n */\nfunction getLoser(match) {\n    const winnerSide = getMatchResult(match);\n    if (!winnerSide)\n        return null;\n    return match[getOtherSide(winnerSide)];\n}\nexports.getLoser = getLoser;\n/**\n * Returns the pre-computed winner for a match because of BYEs.\n *\n * @param opponents Two opponents.\n */\nfunction byeWinner(opponents) {\n    if (opponents[0] === null && opponents[1] === null) // Double BYE.\n        return null; // BYE.\n    if (opponents[0] === null && opponents[1] !== null) // opponent1 BYE.\n        return { id: opponents[1].id }; // opponent2.\n    if (opponents[0] !== null && opponents[1] === null) // opponent2 BYE.\n        return { id: opponents[0].id }; // opponent1.\n    return { id: null }; // Normal.\n}\nexports.byeWinner = byeWinner;\n/**\n * Returns the pre-computed winner for a match because of BYEs in a lower bracket.\n *\n * @param opponents Two opponents.\n */\nfunction byeWinnerToGrandFinal(opponents) {\n    const winner = byeWinner(opponents);\n    if (winner)\n        winner.position = 1;\n    return winner;\n}\nexports.byeWinnerToGrandFinal = byeWinnerToGrandFinal;\n/**\n * Returns the pre-computed loser for a match because of BYEs.\n *\n * Only used for loser bracket.\n *\n * @param opponents Two opponents.\n * @param index The index of the duel in the round.\n */\nfunction byeLoser(opponents, index) {\n    if (opponents[0] === null || opponents[1] === null) // At least one BYE.\n        return null; // BYE.\n    return { id: null, position: index + 1 }; // Normal.\n}\nexports.byeLoser = byeLoser;\n/**\n * Returns the winner side or `null` if no winner.\n *\n * @param match A match's results.\n */\nfunction getMatchResult(match) {\n    var _a, _b;\n    if (!isMatchCompleted(match))\n        return null;\n    if (isMatchDrawCompleted(match))\n        return null;\n    if (match.opponent1 === null && match.opponent2 === null)\n        return null;\n    let winner = null;\n    if (((_a = match.opponent1) === null || _a === void 0 ? void 0 : _a.result) === 'win' || match.opponent2 === null || match.opponent2.forfeit)\n        winner = 'opponent1';\n    if (((_b = match.opponent2) === null || _b === void 0 ? void 0 : _b.result) === 'win' || match.opponent1 === null || match.opponent1.forfeit) {\n        if (winner !== null)\n            throw Error('There are two winners.');\n        winner = 'opponent2';\n    }\n    return winner;\n}\nexports.getMatchResult = getMatchResult;\n/**\n * Finds a position in a list of matches.\n *\n * @param matches A list of matches to search into.\n * @param position The position to find.\n */\nfunction findPosition(matches, position) {\n    var _a, _b;\n    for (const match of matches) {\n        if (((_a = match.opponent1) === null || _a === void 0 ? void 0 : _a.position) === position)\n            return match.opponent1;\n        if (((_b = match.opponent2) === null || _b === void 0 ? void 0 : _b.position) === position)\n            return match.opponent2;\n    }\n    return null;\n}\nexports.findPosition = findPosition;\n/**\n * Gets the side where the winner of the given match will go in the next match.\n *\n * @param matchNumber Number of the match.\n */\nfunction getSide(matchNumber) {\n    return matchNumber % 2 === 1 ? 'opponent1' : 'opponent2';\n}\nexports.getSide = getSide;\n/**\n * Gets the other side of a match.\n *\n * @param side The side that we don't want.\n */\nfunction getOtherSide(side) {\n    return side === 'opponent1' ? 'opponent2' : 'opponent1';\n}\nexports.getOtherSide = getOtherSide;\n/**\n * Checks if a match is started.\n *\n * @param match Partial match results.\n */\nfunction isMatchStarted(match) {\n    var _a, _b;\n    return ((_a = match.opponent1) === null || _a === void 0 ? void 0 : _a.score) !== undefined || ((_b = match.opponent2) === null || _b === void 0 ? void 0 : _b.score) !== undefined;\n}\nexports.isMatchStarted = isMatchStarted;\n/**\n * Checks if a match is completed.\n *\n * @param match Partial match results.\n */\nfunction isMatchCompleted(match) {\n    return isMatchByeCompleted(match) || isMatchForfeitCompleted(match) || isMatchResultCompleted(match);\n}\nexports.isMatchCompleted = isMatchCompleted;\n/**\n * Checks if a match is completed because of a forfeit.\n *\n * @param match Partial match results.\n */\nfunction isMatchForfeitCompleted(match) {\n    var _a, _b;\n    return ((_a = match.opponent1) === null || _a === void 0 ? void 0 : _a.forfeit) !== undefined || ((_b = match.opponent2) === null || _b === void 0 ? void 0 : _b.forfeit) !== undefined;\n}\nexports.isMatchForfeitCompleted = isMatchForfeitCompleted;\n/**\n * Checks if a match is completed because of a either a draw or a win.\n *\n * @param match Partial match results.\n */\nfunction isMatchResultCompleted(match) {\n    return isMatchDrawCompleted(match) || isMatchWinCompleted(match);\n}\nexports.isMatchResultCompleted = isMatchResultCompleted;\n/**\n * Checks if a match is completed because of a draw.\n *\n * @param match Partial match results.\n */\nfunction isMatchDrawCompleted(match) {\n    var _a, _b;\n    return ((_a = match.opponent1) === null || _a === void 0 ? void 0 : _a.result) === 'draw' && ((_b = match.opponent2) === null || _b === void 0 ? void 0 : _b.result) === 'draw';\n}\nexports.isMatchDrawCompleted = isMatchDrawCompleted;\n/**\n * Checks if a match is completed because of a win.\n *\n * @param match Partial match results.\n */\nfunction isMatchWinCompleted(match) {\n    var _a, _b, _c, _d;\n    return ((_a = match.opponent1) === null || _a === void 0 ? void 0 : _a.result) === 'win' || ((_b = match.opponent2) === null || _b === void 0 ? void 0 : _b.result) === 'win'\n        || ((_c = match.opponent1) === null || _c === void 0 ? void 0 : _c.result) === 'loss' || ((_d = match.opponent2) === null || _d === void 0 ? void 0 : _d.result) === 'loss';\n}\nexports.isMatchWinCompleted = isMatchWinCompleted;\n/**\n * Checks if a match is completed because of at least one BYE.\n *\n * A match \"BYE vs. TBD\" isn't considered completed yet.\n *\n * @param match Partial match results.\n */\nfunction isMatchByeCompleted(match) {\n    var _a, _b;\n    return (match.opponent1 === null && ((_a = match.opponent2) === null || _a === void 0 ? void 0 : _a.id) !== null) // BYE vs. someone\n        || (match.opponent2 === null && ((_b = match.opponent1) === null || _b === void 0 ? void 0 : _b.id) !== null) // someone vs. BYE\n        || (match.opponent1 === null && match.opponent2 === null); // BYE vs. BYE\n}\nexports.isMatchByeCompleted = isMatchByeCompleted;\n/**\n * Checks if a match's results can't be updated.\n *\n * @param match The match to check.\n */\nfunction isMatchUpdateLocked(match) {\n    return match.status === brackets_model_1.Status.Locked || match.status === brackets_model_1.Status.Waiting || match.status === brackets_model_1.Status.Archived;\n}\nexports.isMatchUpdateLocked = isMatchUpdateLocked;\n/**\n * Checks if a match's participants can't be updated.\n *\n * @param match The match to check.\n */\nfunction isMatchParticipantLocked(match) {\n    return match.status >= brackets_model_1.Status.Running;\n}\nexports.isMatchParticipantLocked = isMatchParticipantLocked;\n/**\n * Returns the status of a match based on the presence of the opponents.\n *\n * @param opponents The opponents of a match.\n */\nfunction getMatchByeStatus(opponents) {\n    return getMatchStatus({\n        opponent1: opponents[0],\n        opponent2: opponents[1],\n    });\n}\nexports.getMatchByeStatus = getMatchByeStatus;\n/**\n * Indicates whether a match has at least one BYE or not.\n *\n * @param match Partial match results.\n */\nfunction hasBye(match) {\n    return match.opponent1 === null || match.opponent2 === null;\n}\nexports.hasBye = hasBye;\n/**\n * Returns the status of a match based on the results of a match.\n *\n * @param match Partial match results.\n */\nfunction getMatchStatus(match) {\n    var _a, _b, _c, _d;\n    if (hasBye(match)) // At least one BYE.\n        return brackets_model_1.Status.Locked;\n    if (((_a = match.opponent1) === null || _a === void 0 ? void 0 : _a.id) === null && ((_b = match.opponent2) === null || _b === void 0 ? void 0 : _b.id) === null) // Two TBD opponents.\n        return brackets_model_1.Status.Locked;\n    if (((_c = match.opponent1) === null || _c === void 0 ? void 0 : _c.id) === null || ((_d = match.opponent2) === null || _d === void 0 ? void 0 : _d.id) === null) // One TBD opponent.\n        return brackets_model_1.Status.Waiting;\n    if (isMatchCompleted(match))\n        return brackets_model_1.Status.Completed;\n    if (isMatchStarted(match))\n        return brackets_model_1.Status.Running;\n    return brackets_model_1.Status.Ready;\n}\nexports.getMatchStatus = getMatchStatus;\n/**\n * Updates a match results based on an input.\n *\n * @param stored A reference to what will be updated in the storage.\n * @param match Input of the update.\n */\nfunction setMatchResults(stored, match) {\n    const completed = isMatchCompleted(match);\n    const currentlyCompleted = isMatchCompleted(stored);\n    handleOpponentsInversion(stored, match);\n    const statusChanged = setScores(stored, match);\n    if (completed && currentlyCompleted) {\n        // Ensure everything is good.\n        setCompleted(stored, match);\n        return { statusChanged: false, resultChanged: true };\n    }\n    if (completed && !currentlyCompleted) {\n        setCompleted(stored, match);\n        return { statusChanged: true, resultChanged: true };\n    }\n    if (!completed && currentlyCompleted) {\n        resetMatchResults(stored);\n        return { statusChanged: true, resultChanged: true };\n    }\n    return { statusChanged, resultChanged: false };\n}\nexports.setMatchResults = setMatchResults;\n/**\n * Resets the results of a match. (status, forfeit, result)\n *\n * @param stored A reference to what will be updated in the storage.\n */\nfunction resetMatchResults(stored) {\n    if (stored.opponent1) {\n        stored.opponent1.forfeit = undefined;\n        stored.opponent1.result = undefined;\n    }\n    if (stored.opponent2) {\n        stored.opponent2.forfeit = undefined;\n        stored.opponent2.result = undefined;\n    }\n    stored.status = getMatchStatus(stored);\n}\nexports.resetMatchResults = resetMatchResults;\n/**\n * Gets the id of the opponent at the given side of the given match.\n *\n * @param match The match to get the opponent from.\n * @param side The side where to get the opponent from.\n */\nfunction getOpponentId(match, side) {\n    const opponent = match[side];\n    return opponent && opponent.id;\n}\nexports.getOpponentId = getOpponentId;\n/**\n * Gets the origin position of a side of a match.\n *\n * @param match The match.\n * @param side The side.\n */\nfunction getOriginPosition(match, side) {\n    var _a;\n    const matchNumber = (_a = match[side]) === null || _a === void 0 ? void 0 : _a.position;\n    if (matchNumber === undefined)\n        throw Error('Position is undefined.');\n    return matchNumber;\n}\nexports.getOriginPosition = getOriginPosition;\n/**\n * Returns every loser in a list of matches.\n *\n * @param participants The list of participants.\n * @param matches A list of matches to get losers of.\n */\nfunction getLosers(participants, matches) {\n    const losers = [];\n    let currentRound = null;\n    let roundIndex = -1;\n    for (const match of matches) {\n        if (match.round_id !== currentRound) {\n            currentRound = match.round_id;\n            roundIndex++;\n            losers[roundIndex] = [];\n        }\n        const loser = getLoser(match);\n        if (loser === null)\n            continue;\n        losers[roundIndex].push(findParticipant(participants, loser));\n    }\n    return losers;\n}\nexports.getLosers = getLosers;\n/**\n * Makes final standings based on participants grouped by ranking.\n *\n * @param grouped A list of participants grouped by ranking.\n */\nfunction makeFinalStandings(grouped) {\n    const standings = [];\n    let rank = 1;\n    for (const group of grouped) {\n        for (const participant of group) {\n            standings.push({\n                id: participant.id,\n                name: participant.name,\n                rank,\n            });\n        }\n        rank++;\n    }\n    return standings;\n}\nexports.makeFinalStandings = makeFinalStandings;\n/**\n * Returns the decisive match of a Grand Final.\n *\n * @param type The type of Grand Final.\n * @param matches The matches in the Grand Final.\n */\nfunction getGrandFinalDecisiveMatch(type, matches) {\n    if (type === 'simple')\n        return matches[0];\n    if (type === 'double') {\n        const result = getMatchResult(matches[0]);\n        if (result === 'opponent2')\n            return matches[1];\n        return matches[0];\n    }\n    throw Error('The Grand Final is disabled.');\n}\nexports.getGrandFinalDecisiveMatch = getGrandFinalDecisiveMatch;\n/**\n * Finds a participant in a list.\n *\n * @param participants The list of participants.\n * @param slot The slot of the participant to find.\n */\nfunction findParticipant(participants, slot) {\n    const participant = participants.find(participant => participant.id === (slot === null || slot === void 0 ? void 0 : slot.id));\n    if (!participant)\n        throw Error('Participant not found.');\n    return participant;\n}\nexports.findParticipant = findParticipant;\n/**\n * Gets the side the winner of the current match will go to in the next match.\n *\n * @param matchNumber Number of the current match.\n * @param roundNumber Number of the current round.\n * @param roundCount Count of rounds.\n * @param matchLocation Location of the current match.\n */\nfunction getNextSide(matchNumber, roundNumber, roundCount, matchLocation) {\n    // The nextSide comes from the same bracket.\n    if (matchLocation === 'loser_bracket' && roundNumber % 2 === 1)\n        return 'opponent2';\n    // The nextSide comes from the loser bracket to the final group.\n    if (matchLocation === 'loser_bracket' && roundNumber === roundCount)\n        return 'opponent2';\n    return getSide(matchNumber);\n}\nexports.getNextSide = getNextSide;\n/**\n * Gets the side the winner of the current match in loser bracket will go in the next match.\n *\n * @param matchNumber Number of the match.\n * @param nextMatch The next match.\n * @param roundNumber Number of the current round.\n */\nfunction getNextSideLoserBracket(matchNumber, nextMatch, roundNumber) {\n    var _a;\n    // The nextSide comes from the WB.\n    if (roundNumber > 1)\n        return 'opponent1';\n    // The nextSide comes from the WB round 1. \n    if (((_a = nextMatch.opponent1) === null || _a === void 0 ? void 0 : _a.position) === matchNumber)\n        return 'opponent1';\n    return 'opponent2';\n}\nexports.getNextSideLoserBracket = getNextSideLoserBracket;\n/**\n * Sets an opponent in the next match he has to go.\n *\n * @param nextMatch A match which follows the current one.\n * @param nextSide The side the opponent will be on in the next match.\n * @param match The current match.\n * @param currentSide The side the opponent is currently on.\n */\nfunction setNextOpponent(nextMatch, nextSide, match, currentSide) {\n    var _a;\n    nextMatch[nextSide] = match[currentSide] && {\n        id: getOpponentId(match, currentSide),\n        position: (_a = nextMatch[nextSide]) === null || _a === void 0 ? void 0 : _a.position, // Keep position.\n    };\n    nextMatch.status = getMatchStatus(nextMatch);\n}\nexports.setNextOpponent = setNextOpponent;\n/**\n * Resets an opponent in the match following the current one.\n *\n * @param nextMatch A match which follows the current one.\n * @param nextSide The side the opponent will be on in the next match.\n */\nfunction resetNextOpponent(nextMatch, nextSide) {\n    var _a;\n    nextMatch[nextSide] = nextMatch[nextSide] && {\n        id: null,\n        position: (_a = nextMatch[nextSide]) === null || _a === void 0 ? void 0 : _a.position, // Keep position.\n    };\n    nextMatch.status = brackets_model_1.Status.Locked;\n}\nexports.resetNextOpponent = resetNextOpponent;\n/**\n * Inverts opponents if requested by the input.\n *\n * @param stored A reference to what will be updated in the storage.\n * @param match Input of the update.\n */\nfunction handleOpponentsInversion(stored, match) {\n    var _a, _b, _c, _d;\n    const id1 = (_a = match.opponent1) === null || _a === void 0 ? void 0 : _a.id;\n    const id2 = (_b = match.opponent2) === null || _b === void 0 ? void 0 : _b.id;\n    const storedId1 = (_c = stored.opponent1) === null || _c === void 0 ? void 0 : _c.id;\n    const storedId2 = (_d = stored.opponent2) === null || _d === void 0 ? void 0 : _d.id;\n    if (Number.isInteger(id1) && id1 !== storedId1 && id1 !== storedId2)\n        throw Error('The given opponent1 ID does not exist in this match.');\n    if (Number.isInteger(id2) && id2 !== storedId1 && id2 !== storedId2)\n        throw Error('The given opponent2 ID does not exist in this match.');\n    if (Number.isInteger(id1) && id1 === storedId2 || Number.isInteger(id2) && id2 === storedId1)\n        invertOpponents(match);\n}\nexports.handleOpponentsInversion = handleOpponentsInversion;\n/**\n * Inverts `opponent1` and `opponent2` in a match.\n *\n * @param match A match to update.\n */\nfunction invertOpponents(match) {\n    [match.opponent1, match.opponent2] = [match.opponent2, match.opponent1];\n}\nexports.invertOpponents = invertOpponents;\n/**\n * Updates the scores of a match.\n *\n * @param stored A reference to what will be updated in the storage.\n * @param match Input of the update.\n * @returns `true` if the status of the match changed, `false` otherwise.\n */\nfunction setScores(stored, match) {\n    var _a, _b, _c, _d;\n    // Skip if no score update.\n    if (((_a = match.opponent1) === null || _a === void 0 ? void 0 : _a.score) === ((_b = stored.opponent1) === null || _b === void 0 ? void 0 : _b.score) && ((_c = match.opponent2) === null || _c === void 0 ? void 0 : _c.score) === ((_d = stored.opponent2) === null || _d === void 0 ? void 0 : _d.score))\n        return false;\n    const oldStatus = stored.status;\n    stored.status = brackets_model_1.Status.Running;\n    if (match.opponent1 && stored.opponent1)\n        stored.opponent1.score = match.opponent1.score;\n    if (match.opponent2 && stored.opponent2)\n        stored.opponent2.score = match.opponent2.score;\n    return stored.status !== oldStatus;\n}\nexports.setScores = setScores;\n/**\n * Completes a match and handles results and forfeits.\n *\n * @param stored A reference to what will be updated in the storage.\n * @param match Input of the update.\n */\nfunction setCompleted(stored, match) {\n    stored.status = brackets_model_1.Status.Completed;\n    setResults(stored, match, 'win', 'loss');\n    setResults(stored, match, 'loss', 'win');\n    setResults(stored, match, 'draw', 'draw');\n    if (stored.opponent1 && !stored.opponent2)\n        stored.opponent1.result = 'win'; // Win against opponent 2 BYE.\n    if (!stored.opponent1 && stored.opponent2)\n        stored.opponent2.result = 'win'; // Win against opponent 1 BYE.\n    setForfeits(stored, match);\n}\nexports.setCompleted = setCompleted;\n/**\n * Enforces the symmetry between opponents.\n *\n * Sets an opponent's result to something, based on the result on the other opponent.\n *\n * @param stored A reference to what will be updated in the storage.\n * @param match Input of the update.\n * @param check A result to check in each opponent.\n * @param change A result to set in each other opponent if `check` is correct.\n */\nfunction setResults(stored, match, check, change) {\n    var _a, _b;\n    if (match.opponent1 && match.opponent2) {\n        if (match.opponent1.result === 'win' && match.opponent2.result === 'win')\n            throw Error('There are two winners.');\n        if (match.opponent1.result === 'loss' && match.opponent2.result === 'loss')\n            throw Error('There are two losers.');\n        if (match.opponent1.forfeit === true && match.opponent2.forfeit === true)\n            throw Error('There are two forfeits.');\n    }\n    if (((_a = match.opponent1) === null || _a === void 0 ? void 0 : _a.result) === check) {\n        if (stored.opponent1)\n            stored.opponent1.result = check;\n        else\n            stored.opponent1 = { id: null, result: check };\n        if (stored.opponent2)\n            stored.opponent2.result = change;\n        else\n            stored.opponent2 = { id: null, result: change };\n    }\n    if (((_b = match.opponent2) === null || _b === void 0 ? void 0 : _b.result) === check) {\n        if (stored.opponent2)\n            stored.opponent2.result = check;\n        else\n            stored.opponent2 = { id: null, result: check };\n        if (stored.opponent1)\n            stored.opponent1.result = change;\n        else\n            stored.opponent1 = { id: null, result: change };\n    }\n}\nexports.setResults = setResults;\n/**\n * Sets forfeits for each opponent (if needed).\n *\n * @param stored A reference to what will be updated in the storage.\n * @param match Input of the update.\n */\nfunction setForfeits(stored, match) {\n    var _a, _b;\n    if (((_a = match.opponent1) === null || _a === void 0 ? void 0 : _a.forfeit) === true) {\n        if (stored.opponent1)\n            stored.opponent1.forfeit = true;\n        if (stored.opponent2)\n            stored.opponent2.result = 'win';\n        else\n            stored.opponent2 = { id: null, result: 'win' };\n    }\n    if (((_b = match.opponent2) === null || _b === void 0 ? void 0 : _b.forfeit) === true) {\n        if (stored.opponent2)\n            stored.opponent2.forfeit = true;\n        if (stored.opponent1)\n            stored.opponent1.result = 'win';\n        else\n            stored.opponent1 = { id: null, result: 'win' };\n    }\n}\nexports.setForfeits = setForfeits;\n/**\n * Indicates if a seeding is filled with participants' names or IDs.\n *\n * @param seeding The seeding.\n */\nfunction isSeedingWithIds(seeding) {\n    return seeding.some((value) => typeof value === 'number');\n}\nexports.isSeedingWithIds = isSeedingWithIds;\n/**\n * Extracts participants from a seeding, without the byes.\n *\n * @param tournamentId ID of the tournament.\n * @param seeding The seeding.\n */\nfunction extractParticipantsFromSeeding(tournamentId, seeding) {\n    const withoutByes = seeding.filter(name => name !== null);\n    const participants = withoutByes.map(name => ({\n        tournament_id: tournamentId,\n        name,\n    }));\n    return participants;\n}\nexports.extractParticipantsFromSeeding = extractParticipantsFromSeeding;\n/**\n * Returns participant slots mapped to the instances stored in the database thanks to their name.\n *\n * @param seeding The seeding.\n * @param database The participants stored in the database.\n * @param positions An optional list of positions (seeds) for a manual ordering.\n */\nfunction mapParticipantsNamesToDatabase(seeding, database, positions) {\n    return mapParticipantsToDatabase('name', seeding, database, positions);\n}\nexports.mapParticipantsNamesToDatabase = mapParticipantsNamesToDatabase;\n/**\n * Returns participant slots mapped to the instances stored in the database thanks to their id.\n *\n * @param seeding The seeding.\n * @param database The participants stored in the database.\n * @param positions An optional list of positions (seeds) for a manual ordering.\n */\nfunction mapParticipantsIdsToDatabase(seeding, database, positions) {\n    return mapParticipantsToDatabase('id', seeding, database, positions);\n}\nexports.mapParticipantsIdsToDatabase = mapParticipantsIdsToDatabase;\n/**\n * Returns participant slots mapped to the instances stored in the database thanks to a property of theirs.\n *\n * @param prop The property to search participants with.\n * @param seeding The seeding.\n * @param database The participants stored in the database.\n * @param positions An optional list of positions (seeds) for a manual ordering.\n */\nfunction mapParticipantsToDatabase(prop, seeding, database, positions) {\n    const slots = seeding.map((slot, i) => {\n        if (slot === null)\n            return null; // BYE.\n        const found = database.find(participant => participant[prop] === slot);\n        if (!found)\n            throw Error(`Participant ${prop} not found in database.`);\n        return { id: found.id, position: i + 1 };\n    });\n    if (!positions)\n        return slots;\n    if (positions.length !== slots.length)\n        throw Error('Not enough seeds in at least one group of the manual ordering.');\n    return positions.map(position => slots[position - 1]); // position = i + 1\n}\nexports.mapParticipantsToDatabase = mapParticipantsToDatabase;\n/**\n * Converts a list of matches to a seeding.\n *\n * @param matches The input matches.\n */\nfunction matchesToSeeding(matches) {\n    const flattened = [].concat(...matches.map(match => [match.opponent1, match.opponent2]));\n    return sortSeeding(flattened);\n}\nexports.matchesToSeeding = matchesToSeeding;\n/**\n * Sorts the seeding with the BYEs in the correct position.\n *\n * @param slots A list of slots to sort.\n */\nfunction sortSeeding(slots) {\n    const withoutByes = slots.filter(v => v !== null);\n    // a and b are not null because of the filter.\n    // The slots are from seeding slots, thus they have a position.\n    withoutByes.sort((a, b) => a.position - b.position);\n    if (withoutByes.length === slots.length)\n        return withoutByes;\n    // Same for v and position.\n    const placed = Object.fromEntries(withoutByes.map(v => [v.position - 1, v]));\n    const sortedWithByes = Array.from({ length: slots.length }, (_, i) => placed[i] || null);\n    return sortedWithByes;\n}\nexports.sortSeeding = sortSeeding;\n/**\n * Returns only the non null elements.\n *\n * @param array The array to process.\n */\nfunction getNonNull(array) {\n    // Use a TS type guard to exclude null from the resulting type.\n    const nonNull = array.filter((element) => element !== null);\n    return nonNull;\n}\nexports.getNonNull = getNonNull;\n/**\n * Returns a list of objects which have unique values of a specific key.\n *\n * @param array The array to process.\n * @param key The key to filter by.\n */\nfunction uniqueBy(array, key) {\n    const seen = new Set();\n    return array.filter(item => {\n        const value = key(item);\n        if (!value)\n            return true;\n        if (seen.has(value))\n            return false;\n        seen.add(value);\n        return true;\n    });\n}\nexports.uniqueBy = uniqueBy;\n/**\n * Makes the transition to a major round for duels of the previous round. The duel count is divided by 2.\n *\n * @param previousDuels The previous duels to transition from.\n */\nfunction transitionToMajor(previousDuels) {\n    const currentDuelCount = previousDuels.length / 2;\n    const currentDuels = [];\n    for (let duelIndex = 0; duelIndex < currentDuelCount; duelIndex++) {\n        const prevDuelId = duelIndex * 2;\n        currentDuels.push([\n            byeWinner(previousDuels[prevDuelId]),\n            byeWinner(previousDuels[prevDuelId + 1]),\n        ]);\n    }\n    return currentDuels;\n}\nexports.transitionToMajor = transitionToMajor;\n/**\n * Makes the transition to a minor round for duels of the previous round. The duel count stays the same.\n *\n * @param previousDuels The previous duels to transition from.\n * @param losers Losers from the previous major round.\n * @param method The ordering method for the losers.\n */\nfunction transitionToMinor(previousDuels, losers, method) {\n    const orderedLosers = method ? ordering_1.ordering[method](losers) : losers;\n    const currentDuelCount = previousDuels.length;\n    const currentDuels = [];\n    for (let duelIndex = 0; duelIndex < currentDuelCount; duelIndex++) {\n        const prevDuelId = duelIndex;\n        currentDuels.push([\n            orderedLosers[prevDuelId],\n            byeWinner(previousDuels[prevDuelId]),\n        ]);\n    }\n    return currentDuels;\n}\nexports.transitionToMinor = transitionToMinor;\n/**\n * Sets the parent match to a completed status if all its child games are completed.\n *\n * @param parent The partial parent match to update.\n * @param childCount Child count of this parent match.\n * @param inRoundRobin Indicates whether the parent match is in a round-robin stage.\n */\nfunction setParentMatchCompleted(parent, childCount, inRoundRobin) {\n    var _a, _b;\n    if (((_a = parent.opponent1) === null || _a === void 0 ? void 0 : _a.score) === undefined || ((_b = parent.opponent2) === null || _b === void 0 ? void 0 : _b.score) === undefined)\n        throw Error('Either opponent1, opponent2 or their scores are falsy.');\n    const minToWin = minScoreToWinBestOfX(childCount);\n    if (parent.opponent1.score >= minToWin) {\n        parent.opponent1.result = 'win';\n        return;\n    }\n    if (parent.opponent2.score >= minToWin) {\n        parent.opponent2.result = 'win';\n        return;\n    }\n    if (parent.opponent1.score === parent.opponent2.score && parent.opponent1.score + parent.opponent2.score > childCount - 1) {\n        if (inRoundRobin) {\n            parent.opponent1.result = 'draw';\n            parent.opponent2.result = 'draw';\n            return;\n        }\n        throw Error('Match games result in a tie for the parent match.');\n    }\n}\nexports.setParentMatchCompleted = setParentMatchCompleted;\n/**\n * Returns a parent match results based on its child games scores.\n *\n * @param storedParent The parent match stored in the database.\n * @param scores The scores of the match child games.\n */\nfunction getParentMatchResults(storedParent, scores) {\n    return {\n        opponent1: {\n            id: storedParent.opponent1 && storedParent.opponent1.id,\n            score: scores.opponent1,\n        },\n        opponent2: {\n            id: storedParent.opponent2 && storedParent.opponent2.id,\n            score: scores.opponent2,\n        },\n    };\n}\nexports.getParentMatchResults = getParentMatchResults;\n/**\n * Gets the values which need to be updated in a match when it's updated on insertion.\n *\n * @param match The up to date match.\n */\nfunction getUpdatedMatchResults(match) {\n    return {\n        status: match.status,\n        opponent1: match.opponent1,\n        opponent2: match.opponent2,\n    };\n}\nexports.getUpdatedMatchResults = getUpdatedMatchResults;\n/**\n * Calculates the score of a parent match based on its child games.\n *\n * @param games The child games to process.\n */\nfunction getChildGamesResults(games) {\n    const scores = {\n        opponent1: 0,\n        opponent2: 0,\n    };\n    for (const game of games) {\n        const result = getMatchResult(game);\n        if (result === 'opponent1')\n            scores.opponent1++;\n        else if (result === 'opponent2')\n            scores.opponent2++;\n    }\n    return scores;\n}\nexports.getChildGamesResults = getChildGamesResults;\n/**\n * Gets the default list of seeds for a round's matches.\n *\n * @param inLoserBracket Whether the match is in the loser bracket.\n * @param roundNumber The number of the current round.\n * @param roundCountLB The count of rounds in loser bracket.\n * @param matchCount The count of matches in the round.\n */\nfunction getSeeds(inLoserBracket, roundNumber, roundCountLB, matchCount) {\n    const seedCount = getSeedCount(inLoserBracket, roundNumber, roundCountLB, matchCount);\n    return Array.from(Array(seedCount), (_, i) => i + 1);\n}\nexports.getSeeds = getSeeds;\n/**\n * Gets the number of seeds for a round's matches.\n *\n * @param inLoserBracket Whether the match is in the loser bracket.\n * @param roundNumber The number of the current round.\n * @param roundCountLB The count of rounds in loser bracket.\n * @param matchCount The count of matches in the round.\n */\nfunction getSeedCount(inLoserBracket, roundNumber, roundCountLB, matchCount) {\n    ensureOrderingSupported(inLoserBracket, roundNumber, roundCountLB);\n    return roundNumber === 1 ?\n        matchCount * 2 : // Two per match for upper or lower bracket round 1.\n        matchCount; // One per match for loser bracket minor rounds.\n}\nexports.getSeedCount = getSeedCount;\n/**\n * Throws if the ordering is not supported on the given round number.\n *\n * @param inLoserBracket Whether the match is in the loser bracket.\n * @param roundNumber The number of the round.\n * @param roundCountLB The count of rounds in loser bracket.\n */\nfunction ensureOrderingSupported(inLoserBracket, roundNumber, roundCountLB) {\n    if (inLoserBracket && !isOrderingSupportedLoserBracket(roundNumber, roundCountLB))\n        throw Error('This round does not support ordering.');\n    if (!inLoserBracket && !isOrderingSupportedUpperBracket(roundNumber))\n        throw Error('This round does not support ordering.');\n}\nexports.ensureOrderingSupported = ensureOrderingSupported;\n/**\n * Indicates whether the ordering is supported in upper bracket, given the round number.\n *\n * @param roundNumber The number of the round.\n */\nfunction isOrderingSupportedUpperBracket(roundNumber) {\n    return roundNumber === 1;\n}\nexports.isOrderingSupportedUpperBracket = isOrderingSupportedUpperBracket;\n/**\n * Indicates whether the ordering is supported in loser bracket, given the round number.\n *\n * @param roundNumber The number of the round.\n * @param roundCount The count of rounds.\n */\nfunction isOrderingSupportedLoserBracket(roundNumber, roundCount) {\n    return roundNumber === 1 || (roundNumber % 2 === 0 && roundNumber < roundCount);\n}\nexports.isOrderingSupportedLoserBracket = isOrderingSupportedLoserBracket;\n/**\n * Returns the number of rounds an upper bracket has given the number of participants in the stage.\n *\n * @param participantCount The number of participants in the stage.\n */\nfunction getUpperBracketRoundCount(participantCount) {\n    return Math.log2(participantCount);\n}\nexports.getUpperBracketRoundCount = getUpperBracketRoundCount;\n/**\n * Returns the count of round pairs (major & minor) in a loser bracket.\n *\n * @param participantCount The number of participants in the stage.\n */\nfunction getRoundPairCount(participantCount) {\n    return getUpperBracketRoundCount(participantCount) - 1;\n}\nexports.getRoundPairCount = getRoundPairCount;\n/**\n * Determines whether a double elimination stage is really necessary.\n *\n * If the size is only two (less is impossible), then a lower bracket and a grand final are not necessary.\n *\n * @param participantCount The number of participants in the stage.\n */\nfunction isDoubleEliminationNecessary(participantCount) {\n    return participantCount > 2;\n}\nexports.isDoubleEliminationNecessary = isDoubleEliminationNecessary;\n/**\n * Returns the real (because of loser ordering) number of a match in a loser bracket.\n *\n * @param participantCount The number of participants in a stage.\n * @param roundNumber Number of the round.\n * @param matchNumber Number of the match.\n * @param method The method used for the round.\n */\nfunction findLoserMatchNumber(participantCount, roundNumber, matchNumber, method) {\n    const matchCount = getLoserRoundMatchCount(participantCount, roundNumber);\n    const matchNumbers = Array.from(Array(matchCount), (_, i) => i + 1);\n    const ordered = method ? ordering_1.ordering[method](matchNumbers) : matchNumbers;\n    const actualMatchNumberLB = ordered.indexOf(matchNumber) + 1;\n    return actualMatchNumberLB;\n}\nexports.findLoserMatchNumber = findLoserMatchNumber;\n/**\n * Returns the count of matches in a round of a loser bracket.\n *\n * @param participantCount The number of participants in a stage.\n * @param roundNumber Number of the round.\n */\nfunction getLoserRoundMatchCount(participantCount, roundNumber) {\n    const roundPairIndex = Math.ceil(roundNumber / 2) - 1;\n    const roundPairCount = getRoundPairCount(participantCount);\n    const matchCount = Math.pow(2, roundPairCount - roundPairIndex - 1);\n    return matchCount;\n}\nexports.getLoserRoundMatchCount = getLoserRoundMatchCount;\n/**\n * Returns the ordering method of a round of a loser bracket.\n *\n * @param seedOrdering The list of seed orderings.\n * @param roundNumber Number of the round.\n */\nfunction getLoserOrdering(seedOrdering, roundNumber) {\n    const orderingIndex = 1 + Math.floor(roundNumber / 2);\n    return seedOrdering[orderingIndex];\n}\nexports.getLoserOrdering = getLoserOrdering;\n/**\n * Returns the number of rounds a lower bracket has given the number of participants in a double elimination stage.\n *\n * @param participantCount The number of participants in the stage.\n */\nfunction lowerBracketRoundCount(participantCount) {\n    const roundPairCount = getRoundPairCount(participantCount);\n    return roundPairCount * 2;\n}\nexports.lowerBracketRoundCount = lowerBracketRoundCount;\n/**\n * Returns the match number of the corresponding match in the next round by dividing by two.\n *\n * @param matchNumber The current match number.\n */\nfunction getDiagonalMatchNumber(matchNumber) {\n    return Math.ceil(matchNumber / 2);\n}\nexports.getDiagonalMatchNumber = getDiagonalMatchNumber;\n/**\n * Returns the nearest power of two **greater than** or equal to the given number.\n *\n * @param input The input number.\n */\nfunction getNearestPowerOfTwo(input) {\n    return Math.pow(2, Math.ceil(Math.log2(input)));\n}\nexports.getNearestPowerOfTwo = getNearestPowerOfTwo;\n/**\n * Returns the minimum score a participant must have to win a Best Of X series match.\n *\n * @param x The count of child games in the series.\n */\nfunction minScoreToWinBestOfX(x) {\n    return (x + 1) / 2;\n}\n/**\n * Checks if a stage is a round-robin stage.\n *\n * @param stage The stage to check.\n */\nfunction isRoundRobin(stage) {\n    return stage.type === 'round_robin';\n}\nexports.isRoundRobin = isRoundRobin;\n/**\n * Throws if a stage is round-robin.\n *\n * @param stage The stage to check.\n */\nfunction ensureNotRoundRobin(stage) {\n    const inRoundRobin = isRoundRobin(stage);\n    if (inRoundRobin)\n        throw Error('Impossible to update ordering in a round-robin stage.');\n}\nexports.ensureNotRoundRobin = ensureNotRoundRobin;\n/**\n * Checks if a group is a winner bracket.\n *\n * It's not always the opposite of `inLoserBracket()`: it could be the only bracket of a single elimination stage.\n *\n * @param stageType Type of the stage.\n * @param groupNumber Number of the group.\n */\nfunction isWinnerBracket(stageType, groupNumber) {\n    return stageType === 'double_elimination' && groupNumber === 1;\n}\nexports.isWinnerBracket = isWinnerBracket;\n/**\n * Checks if a group is a loser bracket.\n *\n * @param stageType Type of the stage.\n * @param groupNumber Number of the group.\n */\nfunction isLoserBracket(stageType, groupNumber) {\n    return stageType === 'double_elimination' && groupNumber === 2;\n}\nexports.isLoserBracket = isLoserBracket;\n/**\n * Checks if a group is a final group (consolation final or grand final).\n *\n * @param stageType Type of the stage.\n * @param groupNumber Number of the group.\n */\nfunction isFinalGroup(stageType, groupNumber) {\n    return stageType === 'single_elimination' && groupNumber === 2 ||\n        stageType === 'double_elimination' && groupNumber === 3;\n}\nexports.isFinalGroup = isFinalGroup;\n/**\n * Returns the type of group the match is located into.\n *\n * @param stageType Type of the stage.\n * @param groupNumber Number of the group.\n */\nfunction getMatchLocation(stageType, groupNumber) {\n    if (isWinnerBracket(stageType, groupNumber))\n        return 'winner_bracket';\n    if (isLoserBracket(stageType, groupNumber))\n        return 'loser_bracket';\n    if (isFinalGroup(stageType, groupNumber))\n        return 'final_group';\n    return 'single_bracket';\n}\nexports.getMatchLocation = getMatchLocation;\n//# sourceMappingURL=helpers.js.map\n\n//# sourceURL=webpack://brackets-viewer/./node_modules/brackets-manager/dist/helpers.js?");

/***/ }),

/***/ "./node_modules/brackets-manager/dist/index.js":
/*!*****************************************************!*\
  !*** ./node_modules/brackets-manager/dist/index.js ***!
  \*****************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.JsonDatabase = exports.BracketsManager = void 0;\nconst manager_1 = __webpack_require__(/*! ./manager */ \"./node_modules/brackets-manager/dist/manager.js\");\nObject.defineProperty(exports, \"BracketsManager\", ({ enumerable: true, get: function () { return manager_1.BracketsManager; } }));\nconst json_1 = __webpack_require__(/*! ./storage/json */ \"./node_modules/brackets-manager/dist/storage/json.js\");\nObject.defineProperty(exports, \"JsonDatabase\", ({ enumerable: true, get: function () { return json_1.JsonDatabase; } }));\n//# sourceMappingURL=index.js.map\n\n//# sourceURL=webpack://brackets-viewer/./node_modules/brackets-manager/dist/index.js?");

/***/ }),

/***/ "./node_modules/brackets-manager/dist/manager.js":
/*!*******************************************************!*\
  !*** ./node_modules/brackets-manager/dist/manager.js ***!
  \*******************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.BracketsManager = void 0;\nconst create_1 = __webpack_require__(/*! ./create */ \"./node_modules/brackets-manager/dist/create.js\");\nconst get_1 = __webpack_require__(/*! ./get */ \"./node_modules/brackets-manager/dist/get.js\");\nconst update_1 = __webpack_require__(/*! ./update */ \"./node_modules/brackets-manager/dist/update.js\");\nconst delete_1 = __webpack_require__(/*! ./delete */ \"./node_modules/brackets-manager/dist/delete.js\");\nconst find_1 = __webpack_require__(/*! ./find */ \"./node_modules/brackets-manager/dist/find.js\");\nconst reset_1 = __webpack_require__(/*! ./reset */ \"./node_modules/brackets-manager/dist/reset.js\");\nconst helpers = __webpack_require__(/*! ./helpers */ \"./node_modules/brackets-manager/dist/helpers.js\");\n/**\n * A class to handle tournament management at those levels: `stage`, `group`, `round`, `match` and `match_game`.\n */\nclass BracketsManager {\n    /**\n     * Creates an instance of BracketsManager, which will handle all the stuff from the library.\n     *\n     * @param storageInterface An implementation of CrudInterface.\n     */\n    constructor(storageInterface) {\n        const storage = storageInterface;\n        storage.selectFirst = async (table, filter) => {\n            const results = await this.storage.select(table, filter);\n            if (!results || results.length === 0)\n                return null;\n            return results[0];\n        };\n        storage.selectLast = async (table, filter) => {\n            const results = await this.storage.select(table, filter);\n            if (!results || results.length === 0)\n                return null;\n            return results[results.length - 1];\n        };\n        this.storage = storage;\n        this.get = new get_1.Get(this.storage);\n        this.update = new update_1.Update(this.storage);\n        this.delete = new delete_1.Delete(this.storage);\n        this.find = new find_1.Find(this.storage);\n        this.reset = new reset_1.Reset(this.storage);\n    }\n    /**\n     * Creates a stage for an existing tournament. The tournament won't be created.\n     *\n     * @param stage A stage to create.\n     */\n    async create(stage) {\n        await create_1.create.call(this, stage);\n    }\n    /**\n     * Imports data in the database.\n     *\n     * @param data Data to import.\n     */\n    async import(data) {\n        data = helpers.normalizeIds(data);\n        if (!await this.storage.delete('participant'))\n            throw Error('Could not empty the participant table.');\n        if (!await this.storage.insert('participant', data.participant))\n            throw Error('Could not import participants.');\n        if (!await this.storage.delete('stage'))\n            throw Error('Could not empty the stage table.');\n        if (!await this.storage.insert('stage', data.stage))\n            throw Error('Could not import stages.');\n        if (!await this.storage.delete('group'))\n            throw Error('Could not empty the group table.');\n        if (!await this.storage.insert('group', data.group))\n            throw Error('Could not import groups.');\n        if (!await this.storage.delete('round'))\n            throw Error('Could not empty the round table.');\n        if (!await this.storage.insert('round', data.round))\n            throw Error('Could not import rounds.');\n        if (!await this.storage.delete('match'))\n            throw Error('Could not empty the match table.');\n        if (!await this.storage.insert('match', data.match))\n            throw Error('Could not import matches.');\n        if (!await this.storage.delete('match_game'))\n            throw Error('Could not empty the match_game table.');\n        if (!await this.storage.insert('match_game', data.match_game))\n            throw Error('Could not import match games.');\n    }\n    /**\n     * Exports data from the database.\n     */\n    async export() {\n        const participants = await this.storage.select('participant');\n        if (!participants)\n            throw Error('Error getting participants.');\n        const stages = await this.storage.select('stage');\n        if (!stages)\n            throw Error('Error getting stages.');\n        const groups = await this.storage.select('group');\n        if (!groups)\n            throw Error('Error getting groups.');\n        const rounds = await this.storage.select('round');\n        if (!rounds)\n            throw Error('Error getting rounds.');\n        const matches = await this.storage.select('match');\n        if (!matches)\n            throw Error('Error getting matches.');\n        const matchGames = await this.get.matchGames(matches);\n        return {\n            participant: participants,\n            stage: stages,\n            group: groups,\n            round: rounds,\n            match: matches,\n            match_game: matchGames,\n        };\n    }\n}\nexports.BracketsManager = BracketsManager;\n//# sourceMappingURL=manager.js.map\n\n//# sourceURL=webpack://brackets-viewer/./node_modules/brackets-manager/dist/manager.js?");

/***/ }),

/***/ "./node_modules/brackets-manager/dist/ordering.js":
/*!********************************************************!*\
  !*** ./node_modules/brackets-manager/dist/ordering.js ***!
  \********************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";
eval("\n// https://web.archive.org/web/20200601102344/https://tl.net/forum/sc2-tournaments/202139-superior-double-elimination-losers-bracket-seeding\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.defaultMinorOrdering = exports.ordering = void 0;\nexports.ordering = {\n    'natural': (array) => [...array],\n    'reverse': (array) => [...array].reverse(),\n    'half_shift': (array) => [...array.slice(array.length / 2), ...array.slice(0, array.length / 2)],\n    'reverse_half_shift': (array) => [...array.slice(0, array.length / 2).reverse(), ...array.slice(array.length / 2).reverse()],\n    'pair_flip': (array) => {\n        const result = [];\n        for (let i = 0; i < array.length; i += 2)\n            result.push(array[i + 1], array[i]);\n        return result;\n    },\n    'inner_outer': (array) => {\n        if (array.length === 2)\n            return array;\n        const size = array.length / 4;\n        const innerPart = [array.slice(size, 2 * size), array.slice(2 * size, 3 * size)]; // [_, X, X, _]\n        const outerPart = [array.slice(0, size), array.slice(3 * size, 4 * size)]; // [X, _, _, X]\n        const methods = {\n            inner(part) {\n                return [part[0].pop(), part[1].shift()];\n            },\n            outer(part) {\n                return [part[0].shift(), part[1].pop()];\n            },\n        };\n        const result = [];\n        /**\n         * Adds a part (inner or outer) of a part.\n         *\n         * @param part The part to process.\n         * @param method The method to use.\n         */\n        function add(part, method) {\n            if (part[0].length > 0 && part[1].length > 0)\n                result.push(...methods[method](part));\n        }\n        for (let i = 0; i < size / 2; i++) {\n            add(outerPart, 'outer'); // Outer part's outer\n            add(innerPart, 'inner'); // Inner part's inner\n            add(outerPart, 'inner'); // Outer part's inner\n            add(innerPart, 'outer'); // Inner part's outer\n        }\n        return result;\n    },\n    'groups.effort_balanced': (array, groupCount) => {\n        const result = [];\n        let i = 0, j = 0;\n        while (result.length < array.length) {\n            result.push(array[i]);\n            i += groupCount;\n            if (i >= array.length)\n                i = ++j;\n        }\n        return result;\n    },\n    'groups.seed_optimized': (array, groupCount) => {\n        const groups = Array.from(Array(groupCount), (_) => []);\n        for (let run = 0; run < array.length / groupCount; run++) {\n            if (run % 2 === 0) {\n                for (let group = 0; group < groupCount; group++)\n                    groups[group].push(array[run * groupCount + group]);\n            }\n            else {\n                for (let group = 0; group < groupCount; group++)\n                    groups[groupCount - group - 1].push(array[run * groupCount + group]);\n            }\n        }\n        return groups.flat();\n    },\n    'groups.bracket_optimized': () => {\n        throw Error('Not implemented.');\n    },\n};\nexports.defaultMinorOrdering = {\n    // 1 or 2: Not possible.\n    4: ['natural', 'reverse'],\n    8: ['natural', 'reverse', 'natural'],\n    16: ['natural', 'reverse_half_shift', 'reverse', 'natural'],\n    32: ['natural', 'reverse', 'half_shift', 'natural', 'natural'],\n    64: ['natural', 'reverse', 'half_shift', 'reverse', 'natural', 'natural'],\n    128: ['natural', 'reverse', 'half_shift', 'pair_flip', 'pair_flip', 'pair_flip', 'natural'],\n};\n//# sourceMappingURL=ordering.js.map\n\n//# sourceURL=webpack://brackets-viewer/./node_modules/brackets-manager/dist/ordering.js?");

/***/ }),

/***/ "./node_modules/brackets-manager/dist/reset.js":
/*!*****************************************************!*\
  !*** ./node_modules/brackets-manager/dist/reset.js ***!
  \*****************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.Reset = void 0;\nconst brackets_model_1 = __webpack_require__(/*! brackets-model */ \"./node_modules/brackets-model/dist/index.js\");\nconst updater_1 = __webpack_require__(/*! ./base/updater */ \"./node_modules/brackets-manager/dist/base/updater.js\");\nconst helpers = __webpack_require__(/*! ./helpers */ \"./node_modules/brackets-manager/dist/helpers.js\");\nclass Reset extends updater_1.BaseUpdater {\n    /**\n     * Resets the results of a match.\n     *\n     * This will update related matches accordingly.\n     *\n     * @param matchId ID of the match.\n     */\n    async matchResults(matchId) {\n        const stored = await this.storage.select('match', matchId);\n        if (!stored)\n            throw Error('Match not found.');\n        if (stored.child_count > 0)\n            throw Error('The parent match is controlled by its child games and its result cannot be reset.');\n        const stage = await this.storage.select('stage', stored.stage_id);\n        if (!stage)\n            throw Error('Stage not found.');\n        const group = await this.storage.select('group', stored.group_id);\n        if (!group)\n            throw Error('Group not found.');\n        const { roundNumber, roundCount } = await this.getRoundPositionalInfo(stored.round_id);\n        const matchLocation = helpers.getMatchLocation(stage.type, group.number);\n        const nextMatches = await this.getNextMatches(stored, matchLocation, stage, roundNumber, roundCount);\n        if (nextMatches.some(match => match && match.status >= brackets_model_1.Status.Running && !helpers.isMatchByeCompleted(match)))\n            throw Error('The match is locked.');\n        helpers.resetMatchResults(stored);\n        await this.applyMatchUpdate(stored);\n        if (!helpers.isRoundRobin(stage))\n            await this.updateRelatedMatches(stored, true, true);\n    }\n    /**\n     * Resets the results of a match game.\n     *\n     * @param gameId ID of the match game.\n     */\n    async matchGameResults(gameId) {\n        const stored = await this.storage.select('match_game', gameId);\n        if (!stored)\n            throw Error('Match game not found.');\n        helpers.resetMatchResults(stored);\n        if (!await this.storage.update('match_game', stored.id, stored))\n            throw Error('Could not update the match game.');\n        await this.updateParentMatch(stored.parent_id);\n    }\n    /**\n     * Resets the seeding of a stage.\n     *\n     * @param stageId ID of the stage.\n     */\n    async seeding(stageId) {\n        await this.updateSeeding(stageId, null);\n    }\n}\nexports.Reset = Reset;\n//# sourceMappingURL=reset.js.map\n\n//# sourceURL=webpack://brackets-viewer/./node_modules/brackets-manager/dist/reset.js?");

/***/ }),

/***/ "./node_modules/brackets-manager/dist/storage/json.js":
/*!************************************************************!*\
  !*** ./node_modules/brackets-manager/dist/storage/json.js ***!
  \************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.JsonDatabase = void 0;\nconst node_json_db_1 = __webpack_require__(/*! node-json-db */ \"./node_modules/node-json-db/dist/JsonDB.js\");\nconst clone = __webpack_require__(/*! rfdc */ \"./node_modules/rfdc/index.js\")();\nclass JsonDatabase {\n    /**\n     * Creates an instance of JsonDatabase, an implementation of CrudInterface for a json file.\n     *\n     * @param filename An optional filename for the database.\n     */\n    constructor(filename) {\n        this.internal = new node_json_db_1.JsonDB(filename || 'db.json', true, true);\n        this.init();\n    }\n    /**\n     * Creates the array if it doesn't exist.\n     *\n     * @param table The table to check.\n     */\n    ensureArrayExists(table) {\n        const path = JsonDatabase.makePath(table);\n        if (!this.internal.exists(path))\n            this.internal.push(path, []);\n    }\n    /**\n     * Initiates the storage.\n     */\n    init() {\n        this.ensureArrayExists('participant');\n        this.ensureArrayExists('stage');\n        this.ensureArrayExists('group');\n        this.ensureArrayExists('round');\n        this.ensureArrayExists('match');\n        this.ensureArrayExists('match_game');\n    }\n    /**\n     * Creates the path of a table.\n     *\n     * @param table Name of the table.\n     */\n    static makePath(table) {\n        return `/${table}`;\n    }\n    /**\n     * Creates the path of an array.\n     *\n     * @param table Name of the table.\n     */\n    static makeArrayPath(table) {\n        return `/${table}[]`;\n    }\n    /**\n     * Creates the path of an element at a given index in an array.\n     *\n     * @param table Name of the table.\n     * @param index Index of the element.\n     */\n    static makeArrayIndexPath(table, index) {\n        return `/${table}[${index}]`;\n    }\n    /**\n     * Makes the filter function associated to the partial object.\n     *\n     * @param partial A partial object with given values as query.\n     */\n    makeFilter(partial) {\n        return (obj) => {\n            let result = true;\n            for (const [key, value] of Object.entries(partial))\n                result = result && obj[key] === value;\n            return result;\n        };\n    }\n    /**\n     * Empties the database and `init()` it back.\n     */\n    reset() {\n        this.internal.resetData({});\n        this.init();\n    }\n    /**\n     * Inserts a unique value or multiple values in a table.\n     *\n     * @param table Name of the table.\n     * @param arg A single value or an array of values.\n     */\n    async insert(table, arg) {\n        const existing = this.internal.getData(JsonDatabase.makePath(table));\n        let id = Math.max(-1, ...existing.map(element => element.id)) + 1;\n        if (!Array.isArray(arg)) {\n            try {\n                this.internal.push(JsonDatabase.makeArrayPath(table), { id, ...arg });\n            }\n            catch (error) {\n                return -1;\n            }\n            return id;\n        }\n        try {\n            this.internal.push(JsonDatabase.makePath(table), arg.map(object => ({ id: id++, ...object })), false);\n        }\n        catch (error) {\n            return false;\n        }\n        return true;\n    }\n    /**\n     * Gets a unique elements, elements matching a filter or all the elements in a table.\n     *\n     * @param table Name of the table.\n     * @param arg An index or a filter.\n     */\n    async select(table, arg) {\n        try {\n            if (arg === undefined)\n                return this.internal.getData(JsonDatabase.makePath(table)).map(clone);\n            if (typeof arg === 'number') {\n                const index = this.internal.getIndex(JsonDatabase.makePath(table), arg);\n                return clone(this.internal.getData(JsonDatabase.makeArrayIndexPath(table, index)));\n            }\n            const values = this.internal.filter(JsonDatabase.makePath(table), this.makeFilter(arg)) || null;\n            return values && values.map(clone);\n        }\n        catch (error) {\n            return null;\n        }\n    }\n    /**\n     * Updates one or multiple elements in a table.\n     *\n     * @param table Name of the table.\n     * @param arg An index or a filter.\n     * @param value The whole object if arg is an index or the values to change if arg is a filter.\n     */\n    async update(table, arg, value) {\n        if (typeof arg === 'number') {\n            try {\n                const index = this.internal.getIndex(JsonDatabase.makePath(table), arg);\n                this.internal.push(JsonDatabase.makeArrayIndexPath(table, index), value);\n                return true;\n            }\n            catch (error) {\n                return false;\n            }\n        }\n        const values = this.internal.filter(JsonDatabase.makePath(table), this.makeFilter(arg));\n        if (!values)\n            return false;\n        values.forEach(v => this.internal.push(JsonDatabase.makeArrayIndexPath(table, v.id), value, false));\n        return true;\n    }\n    /**\n     * Delete data in a table, based on a filter.\n     *\n     * @param table Where to delete in.\n     * @param filter An object to filter data or undefined to empty the table.\n     */\n    async delete(table, filter) {\n        const path = JsonDatabase.makePath(table);\n        if (!filter) {\n            this.internal.push(path, []);\n            return true;\n        }\n        const values = this.internal.getData(path);\n        if (!values)\n            return false;\n        const predicate = this.makeFilter(filter);\n        this.internal.push(path, values.filter(value => !predicate(value)));\n        return true;\n    }\n}\nexports.JsonDatabase = JsonDatabase;\n//# sourceMappingURL=json.js.map\n\n//# sourceURL=webpack://brackets-viewer/./node_modules/brackets-manager/dist/storage/json.js?");

/***/ }),

/***/ "./node_modules/brackets-manager/dist/update.js":
/*!******************************************************!*\
  !*** ./node_modules/brackets-manager/dist/update.js ***!
  \******************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.Update = void 0;\nconst brackets_model_1 = __webpack_require__(/*! brackets-model */ \"./node_modules/brackets-model/dist/index.js\");\nconst ordering_1 = __webpack_require__(/*! ./ordering */ \"./node_modules/brackets-manager/dist/ordering.js\");\nconst updater_1 = __webpack_require__(/*! ./base/updater */ \"./node_modules/brackets-manager/dist/base/updater.js\");\nconst helpers = __webpack_require__(/*! ./helpers */ \"./node_modules/brackets-manager/dist/helpers.js\");\nclass Update extends updater_1.BaseUpdater {\n    /**\n     * Updates partial information of a match. Its id must be given.\n     *\n     * This will update related matches accordingly.\n     *\n     * @param match Values to change in a match.\n     */\n    async match(match) {\n        if (match.id === undefined)\n            throw Error('No match id given.');\n        const stored = await this.storage.select('match', match.id);\n        if (!stored)\n            throw Error('Match not found.');\n        await this.updateMatch(stored, match);\n    }\n    /**\n     * Updates partial information of a match game. Its id must be given.\n     *\n     * This will update the parent match accordingly.\n     *\n     * @param game Values to change in a match game.\n     */\n    async matchGame(game) {\n        const stored = await this.findMatchGame(game);\n        if (helpers.isMatchUpdateLocked(stored))\n            throw Error('The match game is locked.');\n        helpers.setMatchResults(stored, game);\n        if (!await this.storage.update('match_game', stored.id, stored))\n            throw Error('Could not update the match game.');\n        await this.updateParentMatch(stored.parent_id);\n    }\n    /**\n     * Updates the seed ordering of every ordered round in a stage.\n     *\n     * @param stageId ID of the stage.\n     * @param seedOrdering A list of ordering methods.\n     */\n    async ordering(stageId, seedOrdering) {\n        const stage = await this.storage.select('stage', stageId);\n        if (!stage)\n            throw Error('Stage not found.');\n        helpers.ensureNotRoundRobin(stage);\n        const roundsToOrder = await this.getOrderedRounds(stage);\n        if (seedOrdering.length !== roundsToOrder.length)\n            throw Error('The count of seed orderings is incorrect.');\n        for (let i = 0; i < roundsToOrder.length; i++)\n            await this.updateRoundOrdering(roundsToOrder[i], seedOrdering[i]);\n    }\n    /**\n     * Updates the seed ordering of a round.\n     *\n     * @param roundId ID of the round.\n     * @param method Seed ordering method.\n     */\n    async roundOrdering(roundId, method) {\n        const round = await this.storage.select('round', roundId);\n        if (!round)\n            throw Error('This round does not exist.');\n        const stage = await this.storage.select('stage', round.stage_id);\n        if (!stage)\n            throw Error('Stage not found.');\n        helpers.ensureNotRoundRobin(stage);\n        await this.updateRoundOrdering(round, method);\n    }\n    /**\n     * Updates child count of all matches of a given level.\n     *\n     * @param level The level at which to act.\n     * @param id ID of the chosen level.\n     * @param childCount The target child count.\n     */\n    async matchChildCount(level, id, childCount) {\n        switch (level) {\n            case 'stage':\n                await this.updateStageMatchChildCount(id, childCount);\n                break;\n            case 'group':\n                await this.updateGroupMatchChildCount(id, childCount);\n                break;\n            case 'round':\n                await this.updateRoundMatchChildCount(id, childCount);\n                break;\n            case 'match':\n                const match = await this.storage.select('match', id);\n                if (!match)\n                    throw Error('Match not found.');\n                await this.adjustMatchChildGames(match, childCount);\n                break;\n            default:\n                throw Error('Unknown child count level.');\n        }\n    }\n    /**\n     * Updates the seeding of a stage.\n     *\n     * @param stageId ID of the stage.\n     * @param seeding The new seeding.\n     */\n    async seeding(stageId, seeding) {\n        await this.updateSeeding(stageId, seeding);\n    }\n    /**\n     * Update the seed ordering of a round.\n     *\n     * @param round The round of which to update the ordering.\n     * @param method The new ordering method.\n     */\n    async updateRoundOrdering(round, method) {\n        const matches = await this.storage.select('match', { round_id: round.id });\n        if (!matches)\n            throw Error('This round has no match.');\n        if (matches.some(match => match.status > brackets_model_1.Status.Ready))\n            throw Error('At least one match has started or is completed.');\n        const stage = await this.storage.select('stage', round.stage_id);\n        if (!stage)\n            throw Error('Stage not found.');\n        if (stage.settings.size === undefined)\n            throw Error('Undefined stage size.');\n        const group = await this.storage.select('group', round.group_id);\n        if (!group)\n            throw Error('Group not found.');\n        const inLoserBracket = helpers.isLoserBracket(stage.type, group.number);\n        const roundCountLB = helpers.lowerBracketRoundCount(stage.settings.size);\n        const seeds = helpers.getSeeds(inLoserBracket, round.number, roundCountLB, matches.length);\n        const positions = ordering_1.ordering[method](seeds);\n        await this.applyRoundOrdering(round.number, matches, positions);\n    }\n    /**\n     * Updates child count of all matches of a stage.\n     *\n     * @param stageId ID of the stage.\n     * @param childCount The target child count.\n     */\n    async updateStageMatchChildCount(stageId, childCount) {\n        if (!await this.storage.update('match', { stage_id: stageId }, { child_count: childCount }))\n            throw Error('Could not update the match.');\n        const matches = await this.storage.select('match', { stage_id: stageId });\n        if (!matches)\n            throw Error('This stage has no match.');\n        for (const match of matches)\n            await this.adjustMatchChildGames(match, childCount);\n    }\n    /**\n     * Updates child count of all matches of a group.\n     *\n     * @param groupId ID of the group.\n     * @param childCount The target child count.\n     */\n    async updateGroupMatchChildCount(groupId, childCount) {\n        if (!await this.storage.update('match', { group_id: groupId }, { child_count: childCount }))\n            throw Error('Could not update the match.');\n        const matches = await this.storage.select('match', { group_id: groupId });\n        if (!matches)\n            throw Error('This group has no match.');\n        for (const match of matches)\n            await this.adjustMatchChildGames(match, childCount);\n    }\n    /**\n     * Updates child count of all matches of a round.\n     *\n     * @param roundId ID of the round.\n     * @param childCount The target child count.\n     */\n    async updateRoundMatchChildCount(roundId, childCount) {\n        if (!await this.storage.update('match', { round_id: roundId }, { child_count: childCount }))\n            throw Error('Could not update the match.');\n        const matches = await this.storage.select('match', { round_id: roundId });\n        if (!matches)\n            throw Error('This round has no match.');\n        for (const match of matches)\n            await this.adjustMatchChildGames(match, childCount);\n    }\n    /**\n     * Updates the ordering of participants in a round's matches.\n     *\n     * @param roundNumber The number of the round.\n     * @param matches The matches of the round.\n     * @param positions The new positions.\n     */\n    async applyRoundOrdering(roundNumber, matches, positions) {\n        for (const match of matches) {\n            const updated = { ...match };\n            updated.opponent1 = helpers.findPosition(matches, positions.shift());\n            // The only rounds where we have a second ordered participant are first rounds of brackets (upper and lower).\n            if (roundNumber === 1)\n                updated.opponent2 = helpers.findPosition(matches, positions.shift());\n            if (!await this.storage.update('match', updated.id, updated))\n                throw Error('Could not update the match.');\n        }\n    }\n    /**\n     * Adds or deletes match games of a match based on a target child count.\n     *\n     * @param match The match of which child games need to be adjusted.\n     * @param targetChildCount The target child count.\n     */\n    async adjustMatchChildGames(match, targetChildCount) {\n        const games = await this.storage.select('match_game', { parent_id: match.id });\n        let childCount = games ? games.length : 0;\n        while (childCount < targetChildCount) {\n            const id = await this.storage.insert('match_game', {\n                number: childCount + 1,\n                stage_id: match.stage_id,\n                parent_id: match.id,\n                status: match.status,\n                opponent1: { id: null },\n                opponent2: { id: null },\n            });\n            if (id === -1)\n                throw Error('Could not adjust the match games when inserting.');\n            childCount++;\n        }\n        while (childCount > targetChildCount) {\n            const deleted = await this.storage.delete('match_game', {\n                parent_id: match.id,\n                number: childCount,\n            });\n            if (!deleted)\n                throw Error('Could not adjust the match games when deleting.');\n            childCount--;\n        }\n        if (!await this.storage.update('match', match.id, { ...match, child_count: targetChildCount }))\n            throw Error('Could not update the match.');\n    }\n}\nexports.Update = Update;\n//# sourceMappingURL=update.js.map\n\n//# sourceURL=webpack://brackets-viewer/./node_modules/brackets-manager/dist/update.js?");

/***/ }),

/***/ "./node_modules/brackets-model/dist/index.js":
/*!***************************************************!*\
  !*** ./node_modules/brackets-model/dist/index.js ***!
  \***************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.Status = void 0;\n/**\n * The possible status for a match.\n */\nvar Status;\n(function (Status) {\n    /** The two matches leading to this one are not completed yet. */\n    Status[Status[\"Locked\"] = 0] = \"Locked\";\n    /** One participant is ready and waiting for the other one. */\n    Status[Status[\"Waiting\"] = 1] = \"Waiting\";\n    /** Both participants are ready to start. */\n    Status[Status[\"Ready\"] = 2] = \"Ready\";\n    /** The match is running. */\n    Status[Status[\"Running\"] = 3] = \"Running\";\n    /** The match is completed. */\n    Status[Status[\"Completed\"] = 4] = \"Completed\";\n    /** At least one participant completed his following match. */\n    Status[Status[\"Archived\"] = 5] = \"Archived\";\n})(Status = exports.Status || (exports.Status = {}));\n\n\n//# sourceURL=webpack://brackets-viewer/./node_modules/brackets-model/dist/index.js?");

/***/ }),

/***/ "./node_modules/call-bind/callBound.js":
/*!*********************************************!*\
  !*** ./node_modules/call-bind/callBound.js ***!
  \*********************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("\n\nvar GetIntrinsic = __webpack_require__(/*! get-intrinsic */ \"./node_modules/get-intrinsic/index.js\");\n\nvar callBind = __webpack_require__(/*! ./ */ \"./node_modules/call-bind/index.js\");\n\nvar $indexOf = callBind(GetIntrinsic('String.prototype.indexOf'));\n\nmodule.exports = function callBoundIntrinsic(name, allowMissing) {\n\tvar intrinsic = GetIntrinsic(name, !!allowMissing);\n\tif (typeof intrinsic === 'function' && $indexOf(name, '.prototype.') > -1) {\n\t\treturn callBind(intrinsic);\n\t}\n\treturn intrinsic;\n};\n\n\n//# sourceURL=webpack://brackets-viewer/./node_modules/call-bind/callBound.js?");

/***/ }),

/***/ "./node_modules/call-bind/index.js":
/*!*****************************************!*\
  !*** ./node_modules/call-bind/index.js ***!
  \*****************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("\n\nvar bind = __webpack_require__(/*! function-bind */ \"./node_modules/function-bind/index.js\");\nvar GetIntrinsic = __webpack_require__(/*! get-intrinsic */ \"./node_modules/get-intrinsic/index.js\");\n\nvar $apply = GetIntrinsic('%Function.prototype.apply%');\nvar $call = GetIntrinsic('%Function.prototype.call%');\nvar $reflectApply = GetIntrinsic('%Reflect.apply%', true) || bind.call($call, $apply);\n\nvar $gOPD = GetIntrinsic('%Object.getOwnPropertyDescriptor%', true);\nvar $defineProperty = GetIntrinsic('%Object.defineProperty%', true);\nvar $max = GetIntrinsic('%Math.max%');\n\nif ($defineProperty) {\n\ttry {\n\t\t$defineProperty({}, 'a', { value: 1 });\n\t} catch (e) {\n\t\t// IE 8 has a broken defineProperty\n\t\t$defineProperty = null;\n\t}\n}\n\nmodule.exports = function callBind(originalFunction) {\n\tvar func = $reflectApply(bind, $call, arguments);\n\tif ($gOPD && $defineProperty) {\n\t\tvar desc = $gOPD(func, 'length');\n\t\tif (desc.configurable) {\n\t\t\t// original length, plus the receiver, minus any additional arguments (after the receiver)\n\t\t\t$defineProperty(\n\t\t\t\tfunc,\n\t\t\t\t'length',\n\t\t\t\t{ value: 1 + $max(0, originalFunction.length - (arguments.length - 1)) }\n\t\t\t);\n\t\t}\n\t}\n\treturn func;\n};\n\nvar applyBind = function applyBind() {\n\treturn $reflectApply(bind, $apply, arguments);\n};\n\nif ($defineProperty) {\n\t$defineProperty(module.exports, 'apply', { value: applyBind });\n} else {\n\tmodule.exports.apply = applyBind;\n}\n\n\n//# sourceURL=webpack://brackets-viewer/./node_modules/call-bind/index.js?");

/***/ }),

/***/ "./node_modules/foreach/index.js":
/*!***************************************!*\
  !*** ./node_modules/foreach/index.js ***!
  \***************************************/
/***/ ((module) => {

eval("\nvar hasOwn = Object.prototype.hasOwnProperty;\nvar toString = Object.prototype.toString;\n\nmodule.exports = function forEach (obj, fn, ctx) {\n    if (toString.call(fn) !== '[object Function]') {\n        throw new TypeError('iterator must be a function');\n    }\n    var l = obj.length;\n    if (l === +l) {\n        for (var i = 0; i < l; i++) {\n            fn.call(ctx, obj[i], i, obj);\n        }\n    } else {\n        for (var k in obj) {\n            if (hasOwn.call(obj, k)) {\n                fn.call(ctx, obj[k], k, obj);\n            }\n        }\n    }\n};\n\n\n\n//# sourceURL=webpack://brackets-viewer/./node_modules/foreach/index.js?");

/***/ }),

/***/ "./node_modules/function-bind/implementation.js":
/*!******************************************************!*\
  !*** ./node_modules/function-bind/implementation.js ***!
  \******************************************************/
/***/ ((module) => {

"use strict";
eval("\n\n/* eslint no-invalid-this: 1 */\n\nvar ERROR_MESSAGE = 'Function.prototype.bind called on incompatible ';\nvar slice = Array.prototype.slice;\nvar toStr = Object.prototype.toString;\nvar funcType = '[object Function]';\n\nmodule.exports = function bind(that) {\n    var target = this;\n    if (typeof target !== 'function' || toStr.call(target) !== funcType) {\n        throw new TypeError(ERROR_MESSAGE + target);\n    }\n    var args = slice.call(arguments, 1);\n\n    var bound;\n    var binder = function () {\n        if (this instanceof bound) {\n            var result = target.apply(\n                this,\n                args.concat(slice.call(arguments))\n            );\n            if (Object(result) === result) {\n                return result;\n            }\n            return this;\n        } else {\n            return target.apply(\n                that,\n                args.concat(slice.call(arguments))\n            );\n        }\n    };\n\n    var boundLength = Math.max(0, target.length - args.length);\n    var boundArgs = [];\n    for (var i = 0; i < boundLength; i++) {\n        boundArgs.push('$' + i);\n    }\n\n    bound = Function('binder', 'return function (' + boundArgs.join(',') + '){ return binder.apply(this,arguments); }')(binder);\n\n    if (target.prototype) {\n        var Empty = function Empty() {};\n        Empty.prototype = target.prototype;\n        bound.prototype = new Empty();\n        Empty.prototype = null;\n    }\n\n    return bound;\n};\n\n\n//# sourceURL=webpack://brackets-viewer/./node_modules/function-bind/implementation.js?");

/***/ }),

/***/ "./node_modules/function-bind/index.js":
/*!*********************************************!*\
  !*** ./node_modules/function-bind/index.js ***!
  \*********************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("\n\nvar implementation = __webpack_require__(/*! ./implementation */ \"./node_modules/function-bind/implementation.js\");\n\nmodule.exports = Function.prototype.bind || implementation;\n\n\n//# sourceURL=webpack://brackets-viewer/./node_modules/function-bind/index.js?");

/***/ }),

/***/ "./node_modules/get-intrinsic/index.js":
/*!*********************************************!*\
  !*** ./node_modules/get-intrinsic/index.js ***!
  \*********************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("\n\nvar undefined;\n\nvar $SyntaxError = SyntaxError;\nvar $Function = Function;\nvar $TypeError = TypeError;\n\n// eslint-disable-next-line consistent-return\nvar getEvalledConstructor = function (expressionSyntax) {\n\ttry {\n\t\treturn $Function('\"use strict\"; return (' + expressionSyntax + ').constructor;')();\n\t} catch (e) {}\n};\n\nvar $gOPD = Object.getOwnPropertyDescriptor;\nif ($gOPD) {\n\ttry {\n\t\t$gOPD({}, '');\n\t} catch (e) {\n\t\t$gOPD = null; // this is IE 8, which has a broken gOPD\n\t}\n}\n\nvar throwTypeError = function () {\n\tthrow new $TypeError();\n};\nvar ThrowTypeError = $gOPD\n\t? (function () {\n\t\ttry {\n\t\t\t// eslint-disable-next-line no-unused-expressions, no-caller, no-restricted-properties\n\t\t\targuments.callee; // IE 8 does not throw here\n\t\t\treturn throwTypeError;\n\t\t} catch (calleeThrows) {\n\t\t\ttry {\n\t\t\t\t// IE 8 throws on Object.getOwnPropertyDescriptor(arguments, '')\n\t\t\t\treturn $gOPD(arguments, 'callee').get;\n\t\t\t} catch (gOPDthrows) {\n\t\t\t\treturn throwTypeError;\n\t\t\t}\n\t\t}\n\t}())\n\t: throwTypeError;\n\nvar hasSymbols = __webpack_require__(/*! has-symbols */ \"./node_modules/has-symbols/index.js\")();\n\nvar getProto = Object.getPrototypeOf || function (x) { return x.__proto__; }; // eslint-disable-line no-proto\n\nvar needsEval = {};\n\nvar TypedArray = typeof Uint8Array === 'undefined' ? undefined : getProto(Uint8Array);\n\nvar INTRINSICS = {\n\t'%AggregateError%': typeof AggregateError === 'undefined' ? undefined : AggregateError,\n\t'%Array%': Array,\n\t'%ArrayBuffer%': typeof ArrayBuffer === 'undefined' ? undefined : ArrayBuffer,\n\t'%ArrayIteratorPrototype%': hasSymbols ? getProto([][Symbol.iterator]()) : undefined,\n\t'%AsyncFromSyncIteratorPrototype%': undefined,\n\t'%AsyncFunction%': needsEval,\n\t'%AsyncGenerator%': needsEval,\n\t'%AsyncGeneratorFunction%': needsEval,\n\t'%AsyncIteratorPrototype%': needsEval,\n\t'%Atomics%': typeof Atomics === 'undefined' ? undefined : Atomics,\n\t'%BigInt%': typeof BigInt === 'undefined' ? undefined : BigInt,\n\t'%Boolean%': Boolean,\n\t'%DataView%': typeof DataView === 'undefined' ? undefined : DataView,\n\t'%Date%': Date,\n\t'%decodeURI%': decodeURI,\n\t'%decodeURIComponent%': decodeURIComponent,\n\t'%encodeURI%': encodeURI,\n\t'%encodeURIComponent%': encodeURIComponent,\n\t'%Error%': Error,\n\t'%eval%': eval, // eslint-disable-line no-eval\n\t'%EvalError%': EvalError,\n\t'%Float32Array%': typeof Float32Array === 'undefined' ? undefined : Float32Array,\n\t'%Float64Array%': typeof Float64Array === 'undefined' ? undefined : Float64Array,\n\t'%FinalizationRegistry%': typeof FinalizationRegistry === 'undefined' ? undefined : FinalizationRegistry,\n\t'%Function%': $Function,\n\t'%GeneratorFunction%': needsEval,\n\t'%Int8Array%': typeof Int8Array === 'undefined' ? undefined : Int8Array,\n\t'%Int16Array%': typeof Int16Array === 'undefined' ? undefined : Int16Array,\n\t'%Int32Array%': typeof Int32Array === 'undefined' ? undefined : Int32Array,\n\t'%isFinite%': isFinite,\n\t'%isNaN%': isNaN,\n\t'%IteratorPrototype%': hasSymbols ? getProto(getProto([][Symbol.iterator]())) : undefined,\n\t'%JSON%': typeof JSON === 'object' ? JSON : undefined,\n\t'%Map%': typeof Map === 'undefined' ? undefined : Map,\n\t'%MapIteratorPrototype%': typeof Map === 'undefined' || !hasSymbols ? undefined : getProto(new Map()[Symbol.iterator]()),\n\t'%Math%': Math,\n\t'%Number%': Number,\n\t'%Object%': Object,\n\t'%parseFloat%': parseFloat,\n\t'%parseInt%': parseInt,\n\t'%Promise%': typeof Promise === 'undefined' ? undefined : Promise,\n\t'%Proxy%': typeof Proxy === 'undefined' ? undefined : Proxy,\n\t'%RangeError%': RangeError,\n\t'%ReferenceError%': ReferenceError,\n\t'%Reflect%': typeof Reflect === 'undefined' ? undefined : Reflect,\n\t'%RegExp%': RegExp,\n\t'%Set%': typeof Set === 'undefined' ? undefined : Set,\n\t'%SetIteratorPrototype%': typeof Set === 'undefined' || !hasSymbols ? undefined : getProto(new Set()[Symbol.iterator]()),\n\t'%SharedArrayBuffer%': typeof SharedArrayBuffer === 'undefined' ? undefined : SharedArrayBuffer,\n\t'%String%': String,\n\t'%StringIteratorPrototype%': hasSymbols ? getProto(''[Symbol.iterator]()) : undefined,\n\t'%Symbol%': hasSymbols ? Symbol : undefined,\n\t'%SyntaxError%': $SyntaxError,\n\t'%ThrowTypeError%': ThrowTypeError,\n\t'%TypedArray%': TypedArray,\n\t'%TypeError%': $TypeError,\n\t'%Uint8Array%': typeof Uint8Array === 'undefined' ? undefined : Uint8Array,\n\t'%Uint8ClampedArray%': typeof Uint8ClampedArray === 'undefined' ? undefined : Uint8ClampedArray,\n\t'%Uint16Array%': typeof Uint16Array === 'undefined' ? undefined : Uint16Array,\n\t'%Uint32Array%': typeof Uint32Array === 'undefined' ? undefined : Uint32Array,\n\t'%URIError%': URIError,\n\t'%WeakMap%': typeof WeakMap === 'undefined' ? undefined : WeakMap,\n\t'%WeakRef%': typeof WeakRef === 'undefined' ? undefined : WeakRef,\n\t'%WeakSet%': typeof WeakSet === 'undefined' ? undefined : WeakSet\n};\n\nvar doEval = function doEval(name) {\n\tvar value;\n\tif (name === '%AsyncFunction%') {\n\t\tvalue = getEvalledConstructor('async function () {}');\n\t} else if (name === '%GeneratorFunction%') {\n\t\tvalue = getEvalledConstructor('function* () {}');\n\t} else if (name === '%AsyncGeneratorFunction%') {\n\t\tvalue = getEvalledConstructor('async function* () {}');\n\t} else if (name === '%AsyncGenerator%') {\n\t\tvar fn = doEval('%AsyncGeneratorFunction%');\n\t\tif (fn) {\n\t\t\tvalue = fn.prototype;\n\t\t}\n\t} else if (name === '%AsyncIteratorPrototype%') {\n\t\tvar gen = doEval('%AsyncGenerator%');\n\t\tif (gen) {\n\t\t\tvalue = getProto(gen.prototype);\n\t\t}\n\t}\n\n\tINTRINSICS[name] = value;\n\n\treturn value;\n};\n\nvar LEGACY_ALIASES = {\n\t'%ArrayBufferPrototype%': ['ArrayBuffer', 'prototype'],\n\t'%ArrayPrototype%': ['Array', 'prototype'],\n\t'%ArrayProto_entries%': ['Array', 'prototype', 'entries'],\n\t'%ArrayProto_forEach%': ['Array', 'prototype', 'forEach'],\n\t'%ArrayProto_keys%': ['Array', 'prototype', 'keys'],\n\t'%ArrayProto_values%': ['Array', 'prototype', 'values'],\n\t'%AsyncFunctionPrototype%': ['AsyncFunction', 'prototype'],\n\t'%AsyncGenerator%': ['AsyncGeneratorFunction', 'prototype'],\n\t'%AsyncGeneratorPrototype%': ['AsyncGeneratorFunction', 'prototype', 'prototype'],\n\t'%BooleanPrototype%': ['Boolean', 'prototype'],\n\t'%DataViewPrototype%': ['DataView', 'prototype'],\n\t'%DatePrototype%': ['Date', 'prototype'],\n\t'%ErrorPrototype%': ['Error', 'prototype'],\n\t'%EvalErrorPrototype%': ['EvalError', 'prototype'],\n\t'%Float32ArrayPrototype%': ['Float32Array', 'prototype'],\n\t'%Float64ArrayPrototype%': ['Float64Array', 'prototype'],\n\t'%FunctionPrototype%': ['Function', 'prototype'],\n\t'%Generator%': ['GeneratorFunction', 'prototype'],\n\t'%GeneratorPrototype%': ['GeneratorFunction', 'prototype', 'prototype'],\n\t'%Int8ArrayPrototype%': ['Int8Array', 'prototype'],\n\t'%Int16ArrayPrototype%': ['Int16Array', 'prototype'],\n\t'%Int32ArrayPrototype%': ['Int32Array', 'prototype'],\n\t'%JSONParse%': ['JSON', 'parse'],\n\t'%JSONStringify%': ['JSON', 'stringify'],\n\t'%MapPrototype%': ['Map', 'prototype'],\n\t'%NumberPrototype%': ['Number', 'prototype'],\n\t'%ObjectPrototype%': ['Object', 'prototype'],\n\t'%ObjProto_toString%': ['Object', 'prototype', 'toString'],\n\t'%ObjProto_valueOf%': ['Object', 'prototype', 'valueOf'],\n\t'%PromisePrototype%': ['Promise', 'prototype'],\n\t'%PromiseProto_then%': ['Promise', 'prototype', 'then'],\n\t'%Promise_all%': ['Promise', 'all'],\n\t'%Promise_reject%': ['Promise', 'reject'],\n\t'%Promise_resolve%': ['Promise', 'resolve'],\n\t'%RangeErrorPrototype%': ['RangeError', 'prototype'],\n\t'%ReferenceErrorPrototype%': ['ReferenceError', 'prototype'],\n\t'%RegExpPrototype%': ['RegExp', 'prototype'],\n\t'%SetPrototype%': ['Set', 'prototype'],\n\t'%SharedArrayBufferPrototype%': ['SharedArrayBuffer', 'prototype'],\n\t'%StringPrototype%': ['String', 'prototype'],\n\t'%SymbolPrototype%': ['Symbol', 'prototype'],\n\t'%SyntaxErrorPrototype%': ['SyntaxError', 'prototype'],\n\t'%TypedArrayPrototype%': ['TypedArray', 'prototype'],\n\t'%TypeErrorPrototype%': ['TypeError', 'prototype'],\n\t'%Uint8ArrayPrototype%': ['Uint8Array', 'prototype'],\n\t'%Uint8ClampedArrayPrototype%': ['Uint8ClampedArray', 'prototype'],\n\t'%Uint16ArrayPrototype%': ['Uint16Array', 'prototype'],\n\t'%Uint32ArrayPrototype%': ['Uint32Array', 'prototype'],\n\t'%URIErrorPrototype%': ['URIError', 'prototype'],\n\t'%WeakMapPrototype%': ['WeakMap', 'prototype'],\n\t'%WeakSetPrototype%': ['WeakSet', 'prototype']\n};\n\nvar bind = __webpack_require__(/*! function-bind */ \"./node_modules/function-bind/index.js\");\nvar hasOwn = __webpack_require__(/*! has */ \"./node_modules/has/src/index.js\");\nvar $concat = bind.call(Function.call, Array.prototype.concat);\nvar $spliceApply = bind.call(Function.apply, Array.prototype.splice);\nvar $replace = bind.call(Function.call, String.prototype.replace);\nvar $strSlice = bind.call(Function.call, String.prototype.slice);\n\n/* adapted from https://github.com/lodash/lodash/blob/4.17.15/dist/lodash.js#L6735-L6744 */\nvar rePropName = /[^%.[\\]]+|\\[(?:(-?\\d+(?:\\.\\d+)?)|([\"'])((?:(?!\\2)[^\\\\]|\\\\.)*?)\\2)\\]|(?=(?:\\.|\\[\\])(?:\\.|\\[\\]|%$))/g;\nvar reEscapeChar = /\\\\(\\\\)?/g; /** Used to match backslashes in property paths. */\nvar stringToPath = function stringToPath(string) {\n\tvar first = $strSlice(string, 0, 1);\n\tvar last = $strSlice(string, -1);\n\tif (first === '%' && last !== '%') {\n\t\tthrow new $SyntaxError('invalid intrinsic syntax, expected closing `%`');\n\t} else if (last === '%' && first !== '%') {\n\t\tthrow new $SyntaxError('invalid intrinsic syntax, expected opening `%`');\n\t}\n\tvar result = [];\n\t$replace(string, rePropName, function (match, number, quote, subString) {\n\t\tresult[result.length] = quote ? $replace(subString, reEscapeChar, '$1') : number || match;\n\t});\n\treturn result;\n};\n/* end adaptation */\n\nvar getBaseIntrinsic = function getBaseIntrinsic(name, allowMissing) {\n\tvar intrinsicName = name;\n\tvar alias;\n\tif (hasOwn(LEGACY_ALIASES, intrinsicName)) {\n\t\talias = LEGACY_ALIASES[intrinsicName];\n\t\tintrinsicName = '%' + alias[0] + '%';\n\t}\n\n\tif (hasOwn(INTRINSICS, intrinsicName)) {\n\t\tvar value = INTRINSICS[intrinsicName];\n\t\tif (value === needsEval) {\n\t\t\tvalue = doEval(intrinsicName);\n\t\t}\n\t\tif (typeof value === 'undefined' && !allowMissing) {\n\t\t\tthrow new $TypeError('intrinsic ' + name + ' exists, but is not available. Please file an issue!');\n\t\t}\n\n\t\treturn {\n\t\t\talias: alias,\n\t\t\tname: intrinsicName,\n\t\t\tvalue: value\n\t\t};\n\t}\n\n\tthrow new $SyntaxError('intrinsic ' + name + ' does not exist!');\n};\n\nmodule.exports = function GetIntrinsic(name, allowMissing) {\n\tif (typeof name !== 'string' || name.length === 0) {\n\t\tthrow new $TypeError('intrinsic name must be a non-empty string');\n\t}\n\tif (arguments.length > 1 && typeof allowMissing !== 'boolean') {\n\t\tthrow new $TypeError('\"allowMissing\" argument must be a boolean');\n\t}\n\n\tvar parts = stringToPath(name);\n\tvar intrinsicBaseName = parts.length > 0 ? parts[0] : '';\n\n\tvar intrinsic = getBaseIntrinsic('%' + intrinsicBaseName + '%', allowMissing);\n\tvar intrinsicRealName = intrinsic.name;\n\tvar value = intrinsic.value;\n\tvar skipFurtherCaching = false;\n\n\tvar alias = intrinsic.alias;\n\tif (alias) {\n\t\tintrinsicBaseName = alias[0];\n\t\t$spliceApply(parts, $concat([0, 1], alias));\n\t}\n\n\tfor (var i = 1, isOwn = true; i < parts.length; i += 1) {\n\t\tvar part = parts[i];\n\t\tvar first = $strSlice(part, 0, 1);\n\t\tvar last = $strSlice(part, -1);\n\t\tif (\n\t\t\t(\n\t\t\t\t(first === '\"' || first === \"'\" || first === '`')\n\t\t\t\t|| (last === '\"' || last === \"'\" || last === '`')\n\t\t\t)\n\t\t\t&& first !== last\n\t\t) {\n\t\t\tthrow new $SyntaxError('property names with quotes must have matching quotes');\n\t\t}\n\t\tif (part === 'constructor' || !isOwn) {\n\t\t\tskipFurtherCaching = true;\n\t\t}\n\n\t\tintrinsicBaseName += '.' + part;\n\t\tintrinsicRealName = '%' + intrinsicBaseName + '%';\n\n\t\tif (hasOwn(INTRINSICS, intrinsicRealName)) {\n\t\t\tvalue = INTRINSICS[intrinsicRealName];\n\t\t} else if (value != null) {\n\t\t\tif (!(part in value)) {\n\t\t\t\tif (!allowMissing) {\n\t\t\t\t\tthrow new $TypeError('base intrinsic for ' + name + ' exists, but the property is not available.');\n\t\t\t\t}\n\t\t\t\treturn void undefined;\n\t\t\t}\n\t\t\tif ($gOPD && (i + 1) >= parts.length) {\n\t\t\t\tvar desc = $gOPD(value, part);\n\t\t\t\tisOwn = !!desc;\n\n\t\t\t\t// By convention, when a data property is converted to an accessor\n\t\t\t\t// property to emulate a data property that does not suffer from\n\t\t\t\t// the override mistake, that accessor's getter is marked with\n\t\t\t\t// an `originalValue` property. Here, when we detect this, we\n\t\t\t\t// uphold the illusion by pretending to see that original data\n\t\t\t\t// property, i.e., returning the value rather than the getter\n\t\t\t\t// itself.\n\t\t\t\tif (isOwn && 'get' in desc && !('originalValue' in desc.get)) {\n\t\t\t\t\tvalue = desc.get;\n\t\t\t\t} else {\n\t\t\t\t\tvalue = value[part];\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tisOwn = hasOwn(value, part);\n\t\t\t\tvalue = value[part];\n\t\t\t}\n\n\t\t\tif (isOwn && !skipFurtherCaching) {\n\t\t\t\tINTRINSICS[intrinsicRealName] = value;\n\t\t\t}\n\t\t}\n\t}\n\treturn value;\n};\n\n\n//# sourceURL=webpack://brackets-viewer/./node_modules/get-intrinsic/index.js?");

/***/ }),

/***/ "./node_modules/has-symbols/index.js":
/*!*******************************************!*\
  !*** ./node_modules/has-symbols/index.js ***!
  \*******************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("\n\nvar origSymbol = typeof Symbol !== 'undefined' && Symbol;\nvar hasSymbolSham = __webpack_require__(/*! ./shams */ \"./node_modules/has-symbols/shams.js\");\n\nmodule.exports = function hasNativeSymbols() {\n\tif (typeof origSymbol !== 'function') { return false; }\n\tif (typeof Symbol !== 'function') { return false; }\n\tif (typeof origSymbol('foo') !== 'symbol') { return false; }\n\tif (typeof Symbol('bar') !== 'symbol') { return false; }\n\n\treturn hasSymbolSham();\n};\n\n\n//# sourceURL=webpack://brackets-viewer/./node_modules/has-symbols/index.js?");

/***/ }),

/***/ "./node_modules/has-symbols/shams.js":
/*!*******************************************!*\
  !*** ./node_modules/has-symbols/shams.js ***!
  \*******************************************/
/***/ ((module) => {

"use strict";
eval("\n\n/* eslint complexity: [2, 18], max-statements: [2, 33] */\nmodule.exports = function hasSymbols() {\n\tif (typeof Symbol !== 'function' || typeof Object.getOwnPropertySymbols !== 'function') { return false; }\n\tif (typeof Symbol.iterator === 'symbol') { return true; }\n\n\tvar obj = {};\n\tvar sym = Symbol('test');\n\tvar symObj = Object(sym);\n\tif (typeof sym === 'string') { return false; }\n\n\tif (Object.prototype.toString.call(sym) !== '[object Symbol]') { return false; }\n\tif (Object.prototype.toString.call(symObj) !== '[object Symbol]') { return false; }\n\n\t// temp disabled per https://github.com/ljharb/object.assign/issues/17\n\t// if (sym instanceof Symbol) { return false; }\n\t// temp disabled per https://github.com/WebReflection/get-own-property-symbols/issues/4\n\t// if (!(symObj instanceof Symbol)) { return false; }\n\n\t// if (typeof Symbol.prototype.toString !== 'function') { return false; }\n\t// if (String(sym) !== Symbol.prototype.toString.call(sym)) { return false; }\n\n\tvar symVal = 42;\n\tobj[sym] = symVal;\n\tfor (sym in obj) { return false; } // eslint-disable-line no-restricted-syntax, no-unreachable-loop\n\tif (typeof Object.keys === 'function' && Object.keys(obj).length !== 0) { return false; }\n\n\tif (typeof Object.getOwnPropertyNames === 'function' && Object.getOwnPropertyNames(obj).length !== 0) { return false; }\n\n\tvar syms = Object.getOwnPropertySymbols(obj);\n\tif (syms.length !== 1 || syms[0] !== sym) { return false; }\n\n\tif (!Object.prototype.propertyIsEnumerable.call(obj, sym)) { return false; }\n\n\tif (typeof Object.getOwnPropertyDescriptor === 'function') {\n\t\tvar descriptor = Object.getOwnPropertyDescriptor(obj, sym);\n\t\tif (descriptor.value !== symVal || descriptor.enumerable !== true) { return false; }\n\t}\n\n\treturn true;\n};\n\n\n//# sourceURL=webpack://brackets-viewer/./node_modules/has-symbols/shams.js?");

/***/ }),

/***/ "./node_modules/has-tostringtag/shams.js":
/*!***********************************************!*\
  !*** ./node_modules/has-tostringtag/shams.js ***!
  \***********************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("\n\nvar hasSymbols = __webpack_require__(/*! has-symbols/shams */ \"./node_modules/has-symbols/shams.js\");\n\nmodule.exports = function hasToStringTagShams() {\n\treturn hasSymbols() && !!Symbol.toStringTag;\n};\n\n\n//# sourceURL=webpack://brackets-viewer/./node_modules/has-tostringtag/shams.js?");

/***/ }),

/***/ "./node_modules/has/src/index.js":
/*!***************************************!*\
  !*** ./node_modules/has/src/index.js ***!
  \***************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("\n\nvar bind = __webpack_require__(/*! function-bind */ \"./node_modules/function-bind/index.js\");\n\nmodule.exports = bind.call(Function.call, Object.prototype.hasOwnProperty);\n\n\n//# sourceURL=webpack://brackets-viewer/./node_modules/has/src/index.js?");

/***/ }),

/***/ "./node_modules/i18next-browser-languagedetector/dist/esm/i18nextBrowserLanguageDetector.js":
/*!**************************************************************************************************!*\
  !*** ./node_modules/i18next-browser-languagedetector/dist/esm/i18nextBrowserLanguageDetector.js ***!
  \**************************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n/* harmony import */ var _babel_runtime_helpers_esm_classCallCheck__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @babel/runtime/helpers/esm/classCallCheck */ \"./node_modules/@babel/runtime/helpers/esm/classCallCheck.js\");\n/* harmony import */ var _babel_runtime_helpers_esm_createClass__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @babel/runtime/helpers/esm/createClass */ \"./node_modules/@babel/runtime/helpers/esm/createClass.js\");\n\n\n\nvar arr = [];\nvar each = arr.forEach;\nvar slice = arr.slice;\nfunction defaults(obj) {\n  each.call(slice.call(arguments, 1), function (source) {\n    if (source) {\n      for (var prop in source) {\n        if (obj[prop] === undefined) obj[prop] = source[prop];\n      }\n    }\n  });\n  return obj;\n}\n\n// eslint-disable-next-line no-control-regex\nvar fieldContentRegExp = /^[\\u0009\\u0020-\\u007e\\u0080-\\u00ff]+$/;\n\nvar serializeCookie = function serializeCookie(name, val, options) {\n  var opt = options || {};\n  opt.path = opt.path || '/';\n  var value = encodeURIComponent(val);\n  var str = name + '=' + value;\n\n  if (opt.maxAge > 0) {\n    var maxAge = opt.maxAge - 0;\n    if (isNaN(maxAge)) throw new Error('maxAge should be a Number');\n    str += '; Max-Age=' + Math.floor(maxAge);\n  }\n\n  if (opt.domain) {\n    if (!fieldContentRegExp.test(opt.domain)) {\n      throw new TypeError('option domain is invalid');\n    }\n\n    str += '; Domain=' + opt.domain;\n  }\n\n  if (opt.path) {\n    if (!fieldContentRegExp.test(opt.path)) {\n      throw new TypeError('option path is invalid');\n    }\n\n    str += '; Path=' + opt.path;\n  }\n\n  if (opt.expires) {\n    if (typeof opt.expires.toUTCString !== 'function') {\n      throw new TypeError('option expires is invalid');\n    }\n\n    str += '; Expires=' + opt.expires.toUTCString();\n  }\n\n  if (opt.httpOnly) str += '; HttpOnly';\n  if (opt.secure) str += '; Secure';\n\n  if (opt.sameSite) {\n    var sameSite = typeof opt.sameSite === 'string' ? opt.sameSite.toLowerCase() : opt.sameSite;\n\n    switch (sameSite) {\n      case true:\n        str += '; SameSite=Strict';\n        break;\n\n      case 'lax':\n        str += '; SameSite=Lax';\n        break;\n\n      case 'strict':\n        str += '; SameSite=Strict';\n        break;\n\n      case 'none':\n        str += '; SameSite=None';\n        break;\n\n      default:\n        throw new TypeError('option sameSite is invalid');\n    }\n  }\n\n  return str;\n};\n\nvar cookie = {\n  create: function create(name, value, minutes, domain) {\n    var cookieOptions = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : {\n      path: '/',\n      sameSite: 'strict'\n    };\n\n    if (minutes) {\n      cookieOptions.expires = new Date();\n      cookieOptions.expires.setTime(cookieOptions.expires.getTime() + minutes * 60 * 1000);\n    }\n\n    if (domain) cookieOptions.domain = domain;\n    document.cookie = serializeCookie(name, encodeURIComponent(value), cookieOptions);\n  },\n  read: function read(name) {\n    var nameEQ = name + '=';\n    var ca = document.cookie.split(';');\n\n    for (var i = 0; i < ca.length; i++) {\n      var c = ca[i];\n\n      while (c.charAt(0) === ' ') {\n        c = c.substring(1, c.length);\n      }\n\n      if (c.indexOf(nameEQ) === 0) return c.substring(nameEQ.length, c.length);\n    }\n\n    return null;\n  },\n  remove: function remove(name) {\n    this.create(name, '', -1);\n  }\n};\nvar cookie$1 = {\n  name: 'cookie',\n  lookup: function lookup(options) {\n    var found;\n\n    if (options.lookupCookie && typeof document !== 'undefined') {\n      var c = cookie.read(options.lookupCookie);\n      if (c) found = c;\n    }\n\n    return found;\n  },\n  cacheUserLanguage: function cacheUserLanguage(lng, options) {\n    if (options.lookupCookie && typeof document !== 'undefined') {\n      cookie.create(options.lookupCookie, lng, options.cookieMinutes, options.cookieDomain, options.cookieOptions);\n    }\n  }\n};\n\nvar querystring = {\n  name: 'querystring',\n  lookup: function lookup(options) {\n    var found;\n\n    if (typeof window !== 'undefined') {\n      var query = window.location.search.substring(1);\n      var params = query.split('&');\n\n      for (var i = 0; i < params.length; i++) {\n        var pos = params[i].indexOf('=');\n\n        if (pos > 0) {\n          var key = params[i].substring(0, pos);\n\n          if (key === options.lookupQuerystring) {\n            found = params[i].substring(pos + 1);\n          }\n        }\n      }\n    }\n\n    return found;\n  }\n};\n\nvar hasLocalStorageSupport = null;\n\nvar localStorageAvailable = function localStorageAvailable() {\n  if (hasLocalStorageSupport !== null) return hasLocalStorageSupport;\n\n  try {\n    hasLocalStorageSupport = window !== 'undefined' && window.localStorage !== null;\n    var testKey = 'i18next.translate.boo';\n    window.localStorage.setItem(testKey, 'foo');\n    window.localStorage.removeItem(testKey);\n  } catch (e) {\n    hasLocalStorageSupport = false;\n  }\n\n  return hasLocalStorageSupport;\n};\n\nvar localStorage = {\n  name: 'localStorage',\n  lookup: function lookup(options) {\n    var found;\n\n    if (options.lookupLocalStorage && localStorageAvailable()) {\n      var lng = window.localStorage.getItem(options.lookupLocalStorage);\n      if (lng) found = lng;\n    }\n\n    return found;\n  },\n  cacheUserLanguage: function cacheUserLanguage(lng, options) {\n    if (options.lookupLocalStorage && localStorageAvailable()) {\n      window.localStorage.setItem(options.lookupLocalStorage, lng);\n    }\n  }\n};\n\nvar hasSessionStorageSupport = null;\n\nvar sessionStorageAvailable = function sessionStorageAvailable() {\n  if (hasSessionStorageSupport !== null) return hasSessionStorageSupport;\n\n  try {\n    hasSessionStorageSupport = window !== 'undefined' && window.sessionStorage !== null;\n    var testKey = 'i18next.translate.boo';\n    window.sessionStorage.setItem(testKey, 'foo');\n    window.sessionStorage.removeItem(testKey);\n  } catch (e) {\n    hasSessionStorageSupport = false;\n  }\n\n  return hasSessionStorageSupport;\n};\n\nvar sessionStorage = {\n  name: 'sessionStorage',\n  lookup: function lookup(options) {\n    var found;\n\n    if (options.lookupSessionStorage && sessionStorageAvailable()) {\n      var lng = window.sessionStorage.getItem(options.lookupSessionStorage);\n      if (lng) found = lng;\n    }\n\n    return found;\n  },\n  cacheUserLanguage: function cacheUserLanguage(lng, options) {\n    if (options.lookupSessionStorage && sessionStorageAvailable()) {\n      window.sessionStorage.setItem(options.lookupSessionStorage, lng);\n    }\n  }\n};\n\nvar navigator$1 = {\n  name: 'navigator',\n  lookup: function lookup(options) {\n    var found = [];\n\n    if (typeof navigator !== 'undefined') {\n      if (navigator.languages) {\n        // chrome only; not an array, so can't use .push.apply instead of iterating\n        for (var i = 0; i < navigator.languages.length; i++) {\n          found.push(navigator.languages[i]);\n        }\n      }\n\n      if (navigator.userLanguage) {\n        found.push(navigator.userLanguage);\n      }\n\n      if (navigator.language) {\n        found.push(navigator.language);\n      }\n    }\n\n    return found.length > 0 ? found : undefined;\n  }\n};\n\nvar htmlTag = {\n  name: 'htmlTag',\n  lookup: function lookup(options) {\n    var found;\n    var htmlTag = options.htmlTag || (typeof document !== 'undefined' ? document.documentElement : null);\n\n    if (htmlTag && typeof htmlTag.getAttribute === 'function') {\n      found = htmlTag.getAttribute('lang');\n    }\n\n    return found;\n  }\n};\n\nvar path = {\n  name: 'path',\n  lookup: function lookup(options) {\n    var found;\n\n    if (typeof window !== 'undefined') {\n      var language = window.location.pathname.match(/\\/([a-zA-Z-]*)/g);\n\n      if (language instanceof Array) {\n        if (typeof options.lookupFromPathIndex === 'number') {\n          if (typeof language[options.lookupFromPathIndex] !== 'string') {\n            return undefined;\n          }\n\n          found = language[options.lookupFromPathIndex].replace('/', '');\n        } else {\n          found = language[0].replace('/', '');\n        }\n      }\n    }\n\n    return found;\n  }\n};\n\nvar subdomain = {\n  name: 'subdomain',\n  lookup: function lookup(options) {\n    var found;\n\n    if (typeof window !== 'undefined') {\n      var language = window.location.href.match(/(?:http[s]*\\:\\/\\/)*(.*?)\\.(?=[^\\/]*\\..{2,5})/gi);\n\n      if (language instanceof Array) {\n        if (typeof options.lookupFromSubdomainIndex === 'number') {\n          found = language[options.lookupFromSubdomainIndex].replace('http://', '').replace('https://', '').replace('.', '');\n        } else {\n          found = language[0].replace('http://', '').replace('https://', '').replace('.', '');\n        }\n      }\n    }\n\n    return found;\n  }\n};\n\nfunction getDefaults() {\n  return {\n    order: ['querystring', 'cookie', 'localStorage', 'sessionStorage', 'navigator', 'htmlTag'],\n    lookupQuerystring: 'lng',\n    lookupCookie: 'i18next',\n    lookupLocalStorage: 'i18nextLng',\n    lookupSessionStorage: 'i18nextLng',\n    // cache user language\n    caches: ['localStorage'],\n    excludeCacheFor: ['cimode'] //cookieMinutes: 10,\n    //cookieDomain: 'myDomain'\n\n  };\n}\n\nvar Browser = /*#__PURE__*/function () {\n  function Browser(services) {\n    var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n\n    (0,_babel_runtime_helpers_esm_classCallCheck__WEBPACK_IMPORTED_MODULE_0__.default)(this, Browser);\n\n    this.type = 'languageDetector';\n    this.detectors = {};\n    this.init(services, options);\n  }\n\n  (0,_babel_runtime_helpers_esm_createClass__WEBPACK_IMPORTED_MODULE_1__.default)(Browser, [{\n    key: \"init\",\n    value: function init(services) {\n      var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n      var i18nOptions = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n      this.services = services;\n      this.options = defaults(options, this.options || {}, getDefaults()); // backwards compatibility\n\n      if (this.options.lookupFromUrlIndex) this.options.lookupFromPathIndex = this.options.lookupFromUrlIndex;\n      this.i18nOptions = i18nOptions;\n      this.addDetector(cookie$1);\n      this.addDetector(querystring);\n      this.addDetector(localStorage);\n      this.addDetector(sessionStorage);\n      this.addDetector(navigator$1);\n      this.addDetector(htmlTag);\n      this.addDetector(path);\n      this.addDetector(subdomain);\n    }\n  }, {\n    key: \"addDetector\",\n    value: function addDetector(detector) {\n      this.detectors[detector.name] = detector;\n    }\n  }, {\n    key: \"detect\",\n    value: function detect(detectionOrder) {\n      var _this = this;\n\n      if (!detectionOrder) detectionOrder = this.options.order;\n      var detected = [];\n      detectionOrder.forEach(function (detectorName) {\n        if (_this.detectors[detectorName]) {\n          var lookup = _this.detectors[detectorName].lookup(_this.options);\n\n          if (lookup && typeof lookup === 'string') lookup = [lookup];\n          if (lookup) detected = detected.concat(lookup);\n        }\n      });\n      if (this.services.languageUtils.getBestMatchFromCodes) return detected; // new i18next v19.5.0\n\n      return detected.length > 0 ? detected[0] : null; // a little backward compatibility\n    }\n  }, {\n    key: \"cacheUserLanguage\",\n    value: function cacheUserLanguage(lng, caches) {\n      var _this2 = this;\n\n      if (!caches) caches = this.options.caches;\n      if (!caches) return;\n      if (this.options.excludeCacheFor && this.options.excludeCacheFor.indexOf(lng) > -1) return;\n      caches.forEach(function (cacheName) {\n        if (_this2.detectors[cacheName]) _this2.detectors[cacheName].cacheUserLanguage(lng, _this2.options);\n      });\n    }\n  }]);\n\n  return Browser;\n}();\n\nBrowser.type = 'languageDetector';\n\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (Browser);\n\n\n//# sourceURL=webpack://brackets-viewer/./node_modules/i18next-browser-languagedetector/dist/esm/i18nextBrowserLanguageDetector.js?");

/***/ }),

/***/ "./node_modules/i18next/dist/esm/i18next.js":
/*!**************************************************!*\
  !*** ./node_modules/i18next/dist/esm/i18next.js ***!
  \**************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n/* harmony import */ var _babel_runtime_helpers_esm_typeof__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @babel/runtime/helpers/esm/typeof */ \"./node_modules/@babel/runtime/helpers/esm/typeof.js\");\n/* harmony import */ var _babel_runtime_helpers_esm_objectSpread__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @babel/runtime/helpers/esm/objectSpread */ \"./node_modules/@babel/runtime/helpers/esm/objectSpread.js\");\n/* harmony import */ var _babel_runtime_helpers_esm_classCallCheck__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @babel/runtime/helpers/esm/classCallCheck */ \"./node_modules/@babel/runtime/helpers/esm/classCallCheck.js\");\n/* harmony import */ var _babel_runtime_helpers_esm_createClass__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! @babel/runtime/helpers/esm/createClass */ \"./node_modules/@babel/runtime/helpers/esm/createClass.js\");\n/* harmony import */ var _babel_runtime_helpers_esm_possibleConstructorReturn__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! @babel/runtime/helpers/esm/possibleConstructorReturn */ \"./node_modules/@babel/runtime/helpers/esm/possibleConstructorReturn.js\");\n/* harmony import */ var _babel_runtime_helpers_esm_getPrototypeOf__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! @babel/runtime/helpers/esm/getPrototypeOf */ \"./node_modules/@babel/runtime/helpers/esm/getPrototypeOf.js\");\n/* harmony import */ var _babel_runtime_helpers_esm_assertThisInitialized__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! @babel/runtime/helpers/esm/assertThisInitialized */ \"./node_modules/@babel/runtime/helpers/esm/assertThisInitialized.js\");\n/* harmony import */ var _babel_runtime_helpers_esm_inherits__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! @babel/runtime/helpers/esm/inherits */ \"./node_modules/@babel/runtime/helpers/esm/inherits.js\");\n\n\n\n\n\n\n\n\n\nvar consoleLogger = {\n  type: 'logger',\n  log: function log(args) {\n    this.output('log', args);\n  },\n  warn: function warn(args) {\n    this.output('warn', args);\n  },\n  error: function error(args) {\n    this.output('error', args);\n  },\n  output: function output(type, args) {\n    if (console && console[type]) console[type].apply(console, args);\n  }\n};\n\nvar Logger = function () {\n  function Logger(concreteLogger) {\n    var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n\n    (0,_babel_runtime_helpers_esm_classCallCheck__WEBPACK_IMPORTED_MODULE_2__.default)(this, Logger);\n\n    this.init(concreteLogger, options);\n  }\n\n  (0,_babel_runtime_helpers_esm_createClass__WEBPACK_IMPORTED_MODULE_3__.default)(Logger, [{\n    key: \"init\",\n    value: function init(concreteLogger) {\n      var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n      this.prefix = options.prefix || 'i18next:';\n      this.logger = concreteLogger || consoleLogger;\n      this.options = options;\n      this.debug = options.debug;\n    }\n  }, {\n    key: \"setDebug\",\n    value: function setDebug(bool) {\n      this.debug = bool;\n    }\n  }, {\n    key: \"log\",\n    value: function log() {\n      for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {\n        args[_key] = arguments[_key];\n      }\n\n      return this.forward(args, 'log', '', true);\n    }\n  }, {\n    key: \"warn\",\n    value: function warn() {\n      for (var _len2 = arguments.length, args = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {\n        args[_key2] = arguments[_key2];\n      }\n\n      return this.forward(args, 'warn', '', true);\n    }\n  }, {\n    key: \"error\",\n    value: function error() {\n      for (var _len3 = arguments.length, args = new Array(_len3), _key3 = 0; _key3 < _len3; _key3++) {\n        args[_key3] = arguments[_key3];\n      }\n\n      return this.forward(args, 'error', '');\n    }\n  }, {\n    key: \"deprecate\",\n    value: function deprecate() {\n      for (var _len4 = arguments.length, args = new Array(_len4), _key4 = 0; _key4 < _len4; _key4++) {\n        args[_key4] = arguments[_key4];\n      }\n\n      return this.forward(args, 'warn', 'WARNING DEPRECATED: ', true);\n    }\n  }, {\n    key: \"forward\",\n    value: function forward(args, lvl, prefix, debugOnly) {\n      if (debugOnly && !this.debug) return null;\n      if (typeof args[0] === 'string') args[0] = \"\".concat(prefix).concat(this.prefix, \" \").concat(args[0]);\n      return this.logger[lvl](args);\n    }\n  }, {\n    key: \"create\",\n    value: function create(moduleName) {\n      return new Logger(this.logger, (0,_babel_runtime_helpers_esm_objectSpread__WEBPACK_IMPORTED_MODULE_1__.default)({}, {\n        prefix: \"\".concat(this.prefix, \":\").concat(moduleName, \":\")\n      }, this.options));\n    }\n  }]);\n\n  return Logger;\n}();\n\nvar baseLogger = new Logger();\n\nvar EventEmitter = function () {\n  function EventEmitter() {\n    (0,_babel_runtime_helpers_esm_classCallCheck__WEBPACK_IMPORTED_MODULE_2__.default)(this, EventEmitter);\n\n    this.observers = {};\n  }\n\n  (0,_babel_runtime_helpers_esm_createClass__WEBPACK_IMPORTED_MODULE_3__.default)(EventEmitter, [{\n    key: \"on\",\n    value: function on(events, listener) {\n      var _this = this;\n\n      events.split(' ').forEach(function (event) {\n        _this.observers[event] = _this.observers[event] || [];\n\n        _this.observers[event].push(listener);\n      });\n      return this;\n    }\n  }, {\n    key: \"off\",\n    value: function off(event, listener) {\n      if (!this.observers[event]) return;\n\n      if (!listener) {\n        delete this.observers[event];\n        return;\n      }\n\n      this.observers[event] = this.observers[event].filter(function (l) {\n        return l !== listener;\n      });\n    }\n  }, {\n    key: \"emit\",\n    value: function emit(event) {\n      for (var _len = arguments.length, args = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {\n        args[_key - 1] = arguments[_key];\n      }\n\n      if (this.observers[event]) {\n        var cloned = [].concat(this.observers[event]);\n        cloned.forEach(function (observer) {\n          observer.apply(void 0, args);\n        });\n      }\n\n      if (this.observers['*']) {\n        var _cloned = [].concat(this.observers['*']);\n\n        _cloned.forEach(function (observer) {\n          observer.apply(observer, [event].concat(args));\n        });\n      }\n    }\n  }]);\n\n  return EventEmitter;\n}();\n\nfunction defer() {\n  var res;\n  var rej;\n  var promise = new Promise(function (resolve, reject) {\n    res = resolve;\n    rej = reject;\n  });\n  promise.resolve = res;\n  promise.reject = rej;\n  return promise;\n}\nfunction makeString(object) {\n  if (object == null) return '';\n  return '' + object;\n}\nfunction copy(a, s, t) {\n  a.forEach(function (m) {\n    if (s[m]) t[m] = s[m];\n  });\n}\n\nfunction getLastOfPath(object, path, Empty) {\n  function cleanKey(key) {\n    return key && key.indexOf('###') > -1 ? key.replace(/###/g, '.') : key;\n  }\n\n  function canNotTraverseDeeper() {\n    return !object || typeof object === 'string';\n  }\n\n  var stack = typeof path !== 'string' ? [].concat(path) : path.split('.');\n\n  while (stack.length > 1) {\n    if (canNotTraverseDeeper()) return {};\n    var key = cleanKey(stack.shift());\n    if (!object[key] && Empty) object[key] = new Empty();\n\n    if (Object.prototype.hasOwnProperty.call(object, key)) {\n      object = object[key];\n    } else {\n      object = {};\n    }\n  }\n\n  if (canNotTraverseDeeper()) return {};\n  return {\n    obj: object,\n    k: cleanKey(stack.shift())\n  };\n}\n\nfunction setPath(object, path, newValue) {\n  var _getLastOfPath = getLastOfPath(object, path, Object),\n      obj = _getLastOfPath.obj,\n      k = _getLastOfPath.k;\n\n  obj[k] = newValue;\n}\nfunction pushPath(object, path, newValue, concat) {\n  var _getLastOfPath2 = getLastOfPath(object, path, Object),\n      obj = _getLastOfPath2.obj,\n      k = _getLastOfPath2.k;\n\n  obj[k] = obj[k] || [];\n  if (concat) obj[k] = obj[k].concat(newValue);\n  if (!concat) obj[k].push(newValue);\n}\nfunction getPath(object, path) {\n  var _getLastOfPath3 = getLastOfPath(object, path),\n      obj = _getLastOfPath3.obj,\n      k = _getLastOfPath3.k;\n\n  if (!obj) return undefined;\n  return obj[k];\n}\nfunction getPathWithDefaults(data, defaultData, key) {\n  var value = getPath(data, key);\n\n  if (value !== undefined) {\n    return value;\n  }\n\n  return getPath(defaultData, key);\n}\nfunction deepExtend(target, source, overwrite) {\n  for (var prop in source) {\n    if (prop !== '__proto__' && prop !== 'constructor') {\n      if (prop in target) {\n        if (typeof target[prop] === 'string' || target[prop] instanceof String || typeof source[prop] === 'string' || source[prop] instanceof String) {\n          if (overwrite) target[prop] = source[prop];\n        } else {\n          deepExtend(target[prop], source[prop], overwrite);\n        }\n      } else {\n        target[prop] = source[prop];\n      }\n    }\n  }\n\n  return target;\n}\nfunction regexEscape(str) {\n  return str.replace(/[\\-\\[\\]\\/\\{\\}\\(\\)\\*\\+\\?\\.\\\\\\^\\$\\|]/g, '\\\\$&');\n}\nvar _entityMap = {\n  '&': '&amp;',\n  '<': '&lt;',\n  '>': '&gt;',\n  '\"': '&quot;',\n  \"'\": '&#39;',\n  '/': '&#x2F;'\n};\nfunction escape(data) {\n  if (typeof data === 'string') {\n    return data.replace(/[&<>\"'\\/]/g, function (s) {\n      return _entityMap[s];\n    });\n  }\n\n  return data;\n}\nvar isIE10 = typeof window !== 'undefined' && window.navigator && window.navigator.userAgent && window.navigator.userAgent.indexOf('MSIE') > -1;\n\nfunction deepFind(obj, path) {\n  var keySeparator = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : '.';\n  if (!obj) return undefined;\n  if (obj[path]) return obj[path];\n  var paths = path.split(keySeparator);\n  var current = obj;\n\n  for (var i = 0; i < paths.length; ++i) {\n    if (typeof current[paths[i]] === 'string' && i + 1 < paths.length) {\n      return undefined;\n    }\n\n    if (current[paths[i]] === undefined) {\n      var j = 2;\n      var p = paths.slice(i, i + j).join(keySeparator);\n      var mix = current[p];\n\n      while (mix === undefined && paths.length > i + j) {\n        j++;\n        p = paths.slice(i, i + j).join(keySeparator);\n        mix = current[p];\n      }\n\n      if (mix === undefined) return undefined;\n      if (typeof mix === 'string') return mix;\n      if (p && typeof mix[p] === 'string') return mix[p];\n      var joinedPath = paths.slice(i + j).join(keySeparator);\n      if (joinedPath) return deepFind(mix, joinedPath, keySeparator);\n      return undefined;\n    }\n\n    current = current[paths[i]];\n  }\n\n  return current;\n}\n\nvar ResourceStore = function (_EventEmitter) {\n  (0,_babel_runtime_helpers_esm_inherits__WEBPACK_IMPORTED_MODULE_7__.default)(ResourceStore, _EventEmitter);\n\n  function ResourceStore(data) {\n    var _this;\n\n    var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {\n      ns: ['translation'],\n      defaultNS: 'translation'\n    };\n\n    (0,_babel_runtime_helpers_esm_classCallCheck__WEBPACK_IMPORTED_MODULE_2__.default)(this, ResourceStore);\n\n    _this = (0,_babel_runtime_helpers_esm_possibleConstructorReturn__WEBPACK_IMPORTED_MODULE_4__.default)(this, (0,_babel_runtime_helpers_esm_getPrototypeOf__WEBPACK_IMPORTED_MODULE_5__.default)(ResourceStore).call(this));\n\n    if (isIE10) {\n      EventEmitter.call((0,_babel_runtime_helpers_esm_assertThisInitialized__WEBPACK_IMPORTED_MODULE_6__.default)(_this));\n    }\n\n    _this.data = data || {};\n    _this.options = options;\n\n    if (_this.options.keySeparator === undefined) {\n      _this.options.keySeparator = '.';\n    }\n\n    if (_this.options.ignoreJSONStructure === undefined) {\n      _this.options.ignoreJSONStructure = true;\n    }\n\n    return _this;\n  }\n\n  (0,_babel_runtime_helpers_esm_createClass__WEBPACK_IMPORTED_MODULE_3__.default)(ResourceStore, [{\n    key: \"addNamespaces\",\n    value: function addNamespaces(ns) {\n      if (this.options.ns.indexOf(ns) < 0) {\n        this.options.ns.push(ns);\n      }\n    }\n  }, {\n    key: \"removeNamespaces\",\n    value: function removeNamespaces(ns) {\n      var index = this.options.ns.indexOf(ns);\n\n      if (index > -1) {\n        this.options.ns.splice(index, 1);\n      }\n    }\n  }, {\n    key: \"getResource\",\n    value: function getResource(lng, ns, key) {\n      var options = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : {};\n      var keySeparator = options.keySeparator !== undefined ? options.keySeparator : this.options.keySeparator;\n      var ignoreJSONStructure = options.ignoreJSONStructure !== undefined ? options.ignoreJSONStructure : this.options.ignoreJSONStructure;\n      var path = [lng, ns];\n      if (key && typeof key !== 'string') path = path.concat(key);\n      if (key && typeof key === 'string') path = path.concat(keySeparator ? key.split(keySeparator) : key);\n\n      if (lng.indexOf('.') > -1) {\n        path = lng.split('.');\n      }\n\n      var result = getPath(this.data, path);\n      if (result || !ignoreJSONStructure || typeof key !== 'string') return result;\n      return deepFind(this.data && this.data[lng] && this.data[lng][ns], key, keySeparator);\n    }\n  }, {\n    key: \"addResource\",\n    value: function addResource(lng, ns, key, value) {\n      var options = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : {\n        silent: false\n      };\n      var keySeparator = this.options.keySeparator;\n      if (keySeparator === undefined) keySeparator = '.';\n      var path = [lng, ns];\n      if (key) path = path.concat(keySeparator ? key.split(keySeparator) : key);\n\n      if (lng.indexOf('.') > -1) {\n        path = lng.split('.');\n        value = ns;\n        ns = path[1];\n      }\n\n      this.addNamespaces(ns);\n      setPath(this.data, path, value);\n      if (!options.silent) this.emit('added', lng, ns, key, value);\n    }\n  }, {\n    key: \"addResources\",\n    value: function addResources(lng, ns, resources) {\n      var options = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : {\n        silent: false\n      };\n\n      for (var m in resources) {\n        if (typeof resources[m] === 'string' || Object.prototype.toString.apply(resources[m]) === '[object Array]') this.addResource(lng, ns, m, resources[m], {\n          silent: true\n        });\n      }\n\n      if (!options.silent) this.emit('added', lng, ns, resources);\n    }\n  }, {\n    key: \"addResourceBundle\",\n    value: function addResourceBundle(lng, ns, resources, deep, overwrite) {\n      var options = arguments.length > 5 && arguments[5] !== undefined ? arguments[5] : {\n        silent: false\n      };\n      var path = [lng, ns];\n\n      if (lng.indexOf('.') > -1) {\n        path = lng.split('.');\n        deep = resources;\n        resources = ns;\n        ns = path[1];\n      }\n\n      this.addNamespaces(ns);\n      var pack = getPath(this.data, path) || {};\n\n      if (deep) {\n        deepExtend(pack, resources, overwrite);\n      } else {\n        pack = (0,_babel_runtime_helpers_esm_objectSpread__WEBPACK_IMPORTED_MODULE_1__.default)({}, pack, resources);\n      }\n\n      setPath(this.data, path, pack);\n      if (!options.silent) this.emit('added', lng, ns, resources);\n    }\n  }, {\n    key: \"removeResourceBundle\",\n    value: function removeResourceBundle(lng, ns) {\n      if (this.hasResourceBundle(lng, ns)) {\n        delete this.data[lng][ns];\n      }\n\n      this.removeNamespaces(ns);\n      this.emit('removed', lng, ns);\n    }\n  }, {\n    key: \"hasResourceBundle\",\n    value: function hasResourceBundle(lng, ns) {\n      return this.getResource(lng, ns) !== undefined;\n    }\n  }, {\n    key: \"getResourceBundle\",\n    value: function getResourceBundle(lng, ns) {\n      if (!ns) ns = this.options.defaultNS;\n      if (this.options.compatibilityAPI === 'v1') return (0,_babel_runtime_helpers_esm_objectSpread__WEBPACK_IMPORTED_MODULE_1__.default)({}, {}, this.getResource(lng, ns));\n      return this.getResource(lng, ns);\n    }\n  }, {\n    key: \"getDataByLanguage\",\n    value: function getDataByLanguage(lng) {\n      return this.data[lng];\n    }\n  }, {\n    key: \"toJSON\",\n    value: function toJSON() {\n      return this.data;\n    }\n  }]);\n\n  return ResourceStore;\n}(EventEmitter);\n\nvar postProcessor = {\n  processors: {},\n  addPostProcessor: function addPostProcessor(module) {\n    this.processors[module.name] = module;\n  },\n  handle: function handle(processors, value, key, options, translator) {\n    var _this = this;\n\n    processors.forEach(function (processor) {\n      if (_this.processors[processor]) value = _this.processors[processor].process(value, key, options, translator);\n    });\n    return value;\n  }\n};\n\nvar checkedLoadedFor = {};\n\nvar Translator = function (_EventEmitter) {\n  (0,_babel_runtime_helpers_esm_inherits__WEBPACK_IMPORTED_MODULE_7__.default)(Translator, _EventEmitter);\n\n  function Translator(services) {\n    var _this;\n\n    var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n\n    (0,_babel_runtime_helpers_esm_classCallCheck__WEBPACK_IMPORTED_MODULE_2__.default)(this, Translator);\n\n    _this = (0,_babel_runtime_helpers_esm_possibleConstructorReturn__WEBPACK_IMPORTED_MODULE_4__.default)(this, (0,_babel_runtime_helpers_esm_getPrototypeOf__WEBPACK_IMPORTED_MODULE_5__.default)(Translator).call(this));\n\n    if (isIE10) {\n      EventEmitter.call((0,_babel_runtime_helpers_esm_assertThisInitialized__WEBPACK_IMPORTED_MODULE_6__.default)(_this));\n    }\n\n    copy(['resourceStore', 'languageUtils', 'pluralResolver', 'interpolator', 'backendConnector', 'i18nFormat', 'utils'], services, (0,_babel_runtime_helpers_esm_assertThisInitialized__WEBPACK_IMPORTED_MODULE_6__.default)(_this));\n    _this.options = options;\n\n    if (_this.options.keySeparator === undefined) {\n      _this.options.keySeparator = '.';\n    }\n\n    _this.logger = baseLogger.create('translator');\n    return _this;\n  }\n\n  (0,_babel_runtime_helpers_esm_createClass__WEBPACK_IMPORTED_MODULE_3__.default)(Translator, [{\n    key: \"changeLanguage\",\n    value: function changeLanguage(lng) {\n      if (lng) this.language = lng;\n    }\n  }, {\n    key: \"exists\",\n    value: function exists(key) {\n      var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {\n        interpolation: {}\n      };\n\n      if (key === undefined || key === null) {\n        return false;\n      }\n\n      var resolved = this.resolve(key, options);\n      return resolved && resolved.res !== undefined;\n    }\n  }, {\n    key: \"extractFromKey\",\n    value: function extractFromKey(key, options) {\n      var nsSeparator = options.nsSeparator !== undefined ? options.nsSeparator : this.options.nsSeparator;\n      if (nsSeparator === undefined) nsSeparator = ':';\n      var keySeparator = options.keySeparator !== undefined ? options.keySeparator : this.options.keySeparator;\n      var namespaces = options.ns || this.options.defaultNS;\n\n      if (nsSeparator && key.indexOf(nsSeparator) > -1) {\n        var m = key.match(this.interpolator.nestingRegexp);\n\n        if (m && m.length > 0) {\n          return {\n            key: key,\n            namespaces: namespaces\n          };\n        }\n\n        var parts = key.split(nsSeparator);\n        if (nsSeparator !== keySeparator || nsSeparator === keySeparator && this.options.ns.indexOf(parts[0]) > -1) namespaces = parts.shift();\n        key = parts.join(keySeparator);\n      }\n\n      if (typeof namespaces === 'string') namespaces = [namespaces];\n      return {\n        key: key,\n        namespaces: namespaces\n      };\n    }\n  }, {\n    key: \"translate\",\n    value: function translate(keys, options, lastKey) {\n      var _this2 = this;\n\n      if ((0,_babel_runtime_helpers_esm_typeof__WEBPACK_IMPORTED_MODULE_0__.default)(options) !== 'object' && this.options.overloadTranslationOptionHandler) {\n        options = this.options.overloadTranslationOptionHandler(arguments);\n      }\n\n      if (!options) options = {};\n      if (keys === undefined || keys === null) return '';\n      if (!Array.isArray(keys)) keys = [String(keys)];\n      var keySeparator = options.keySeparator !== undefined ? options.keySeparator : this.options.keySeparator;\n\n      var _this$extractFromKey = this.extractFromKey(keys[keys.length - 1], options),\n          key = _this$extractFromKey.key,\n          namespaces = _this$extractFromKey.namespaces;\n\n      var namespace = namespaces[namespaces.length - 1];\n      var lng = options.lng || this.language;\n      var appendNamespaceToCIMode = options.appendNamespaceToCIMode || this.options.appendNamespaceToCIMode;\n\n      if (lng && lng.toLowerCase() === 'cimode') {\n        if (appendNamespaceToCIMode) {\n          var nsSeparator = options.nsSeparator || this.options.nsSeparator;\n          return namespace + nsSeparator + key;\n        }\n\n        return key;\n      }\n\n      var resolved = this.resolve(keys, options);\n      var res = resolved && resolved.res;\n      var resUsedKey = resolved && resolved.usedKey || key;\n      var resExactUsedKey = resolved && resolved.exactUsedKey || key;\n      var resType = Object.prototype.toString.apply(res);\n      var noObject = ['[object Number]', '[object Function]', '[object RegExp]'];\n      var joinArrays = options.joinArrays !== undefined ? options.joinArrays : this.options.joinArrays;\n      var handleAsObjectInI18nFormat = !this.i18nFormat || this.i18nFormat.handleAsObject;\n      var handleAsObject = typeof res !== 'string' && typeof res !== 'boolean' && typeof res !== 'number';\n\n      if (handleAsObjectInI18nFormat && res && handleAsObject && noObject.indexOf(resType) < 0 && !(typeof joinArrays === 'string' && resType === '[object Array]')) {\n        if (!options.returnObjects && !this.options.returnObjects) {\n          if (!this.options.returnedObjectHandler) {\n            this.logger.warn('accessing an object - but returnObjects options is not enabled!');\n          }\n\n          return this.options.returnedObjectHandler ? this.options.returnedObjectHandler(resUsedKey, res, (0,_babel_runtime_helpers_esm_objectSpread__WEBPACK_IMPORTED_MODULE_1__.default)({}, options, {\n            ns: namespaces\n          })) : \"key '\".concat(key, \" (\").concat(this.language, \")' returned an object instead of string.\");\n        }\n\n        if (keySeparator) {\n          var resTypeIsArray = resType === '[object Array]';\n          var copy = resTypeIsArray ? [] : {};\n          var newKeyToUse = resTypeIsArray ? resExactUsedKey : resUsedKey;\n\n          for (var m in res) {\n            if (Object.prototype.hasOwnProperty.call(res, m)) {\n              var deepKey = \"\".concat(newKeyToUse).concat(keySeparator).concat(m);\n              copy[m] = this.translate(deepKey, (0,_babel_runtime_helpers_esm_objectSpread__WEBPACK_IMPORTED_MODULE_1__.default)({}, options, {\n                joinArrays: false,\n                ns: namespaces\n              }));\n              if (copy[m] === deepKey) copy[m] = res[m];\n            }\n          }\n\n          res = copy;\n        }\n      } else if (handleAsObjectInI18nFormat && typeof joinArrays === 'string' && resType === '[object Array]') {\n        res = res.join(joinArrays);\n        if (res) res = this.extendTranslation(res, keys, options, lastKey);\n      } else {\n        var usedDefault = false;\n        var usedKey = false;\n        var needsPluralHandling = options.count !== undefined && typeof options.count !== 'string';\n        var hasDefaultValue = Translator.hasDefaultValue(options);\n        var defaultValueSuffix = needsPluralHandling ? this.pluralResolver.getSuffix(lng, options.count) : '';\n        var defaultValue = options[\"defaultValue\".concat(defaultValueSuffix)] || options.defaultValue;\n\n        if (!this.isValidLookup(res) && hasDefaultValue) {\n          usedDefault = true;\n          res = defaultValue;\n        }\n\n        if (!this.isValidLookup(res)) {\n          usedKey = true;\n          res = key;\n        }\n\n        var updateMissing = hasDefaultValue && defaultValue !== res && this.options.updateMissing;\n\n        if (usedKey || usedDefault || updateMissing) {\n          this.logger.log(updateMissing ? 'updateKey' : 'missingKey', lng, namespace, key, updateMissing ? defaultValue : res);\n\n          if (keySeparator) {\n            var fk = this.resolve(key, (0,_babel_runtime_helpers_esm_objectSpread__WEBPACK_IMPORTED_MODULE_1__.default)({}, options, {\n              keySeparator: false\n            }));\n            if (fk && fk.res) this.logger.warn('Seems the loaded translations were in flat JSON format instead of nested. Either set keySeparator: false on init or make sure your translations are published in nested format.');\n          }\n\n          var lngs = [];\n          var fallbackLngs = this.languageUtils.getFallbackCodes(this.options.fallbackLng, options.lng || this.language);\n\n          if (this.options.saveMissingTo === 'fallback' && fallbackLngs && fallbackLngs[0]) {\n            for (var i = 0; i < fallbackLngs.length; i++) {\n              lngs.push(fallbackLngs[i]);\n            }\n          } else if (this.options.saveMissingTo === 'all') {\n            lngs = this.languageUtils.toResolveHierarchy(options.lng || this.language);\n          } else {\n            lngs.push(options.lng || this.language);\n          }\n\n          var send = function send(l, k, fallbackValue) {\n            if (_this2.options.missingKeyHandler) {\n              _this2.options.missingKeyHandler(l, namespace, k, updateMissing ? fallbackValue : res, updateMissing, options);\n            } else if (_this2.backendConnector && _this2.backendConnector.saveMissing) {\n              _this2.backendConnector.saveMissing(l, namespace, k, updateMissing ? fallbackValue : res, updateMissing, options);\n            }\n\n            _this2.emit('missingKey', l, namespace, k, res);\n          };\n\n          if (this.options.saveMissing) {\n            if (this.options.saveMissingPlurals && needsPluralHandling) {\n              lngs.forEach(function (language) {\n                _this2.pluralResolver.getSuffixes(language).forEach(function (suffix) {\n                  send([language], key + suffix, options[\"defaultValue\".concat(suffix)] || defaultValue);\n                });\n              });\n            } else {\n              send(lngs, key, defaultValue);\n            }\n          }\n        }\n\n        res = this.extendTranslation(res, keys, options, resolved, lastKey);\n        if (usedKey && res === key && this.options.appendNamespaceToMissingKey) res = \"\".concat(namespace, \":\").concat(key);\n        if ((usedKey || usedDefault) && this.options.parseMissingKeyHandler) res = this.options.parseMissingKeyHandler(res);\n      }\n\n      return res;\n    }\n  }, {\n    key: \"extendTranslation\",\n    value: function extendTranslation(res, key, options, resolved, lastKey) {\n      var _this3 = this;\n\n      if (this.i18nFormat && this.i18nFormat.parse) {\n        res = this.i18nFormat.parse(res, options, resolved.usedLng, resolved.usedNS, resolved.usedKey, {\n          resolved: resolved\n        });\n      } else if (!options.skipInterpolation) {\n        if (options.interpolation) this.interpolator.init((0,_babel_runtime_helpers_esm_objectSpread__WEBPACK_IMPORTED_MODULE_1__.default)({}, options, {\n          interpolation: (0,_babel_runtime_helpers_esm_objectSpread__WEBPACK_IMPORTED_MODULE_1__.default)({}, this.options.interpolation, options.interpolation)\n        }));\n        var skipOnVariables = options.interpolation && options.interpolation.skipOnVariables || this.options.interpolation.skipOnVariables;\n        var nestBef;\n\n        if (skipOnVariables) {\n          var nb = res.match(this.interpolator.nestingRegexp);\n          nestBef = nb && nb.length;\n        }\n\n        var data = options.replace && typeof options.replace !== 'string' ? options.replace : options;\n        if (this.options.interpolation.defaultVariables) data = (0,_babel_runtime_helpers_esm_objectSpread__WEBPACK_IMPORTED_MODULE_1__.default)({}, this.options.interpolation.defaultVariables, data);\n        res = this.interpolator.interpolate(res, data, options.lng || this.language, options);\n\n        if (skipOnVariables) {\n          var na = res.match(this.interpolator.nestingRegexp);\n          var nestAft = na && na.length;\n          if (nestBef < nestAft) options.nest = false;\n        }\n\n        if (options.nest !== false) res = this.interpolator.nest(res, function () {\n          for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {\n            args[_key] = arguments[_key];\n          }\n\n          if (lastKey && lastKey[0] === args[0] && !options.context) {\n            _this3.logger.warn(\"It seems you are nesting recursively key: \".concat(args[0], \" in key: \").concat(key[0]));\n\n            return null;\n          }\n\n          return _this3.translate.apply(_this3, args.concat([key]));\n        }, options);\n        if (options.interpolation) this.interpolator.reset();\n      }\n\n      var postProcess = options.postProcess || this.options.postProcess;\n      var postProcessorNames = typeof postProcess === 'string' ? [postProcess] : postProcess;\n\n      if (res !== undefined && res !== null && postProcessorNames && postProcessorNames.length && options.applyPostProcessor !== false) {\n        res = postProcessor.handle(postProcessorNames, res, key, this.options && this.options.postProcessPassResolved ? (0,_babel_runtime_helpers_esm_objectSpread__WEBPACK_IMPORTED_MODULE_1__.default)({\n          i18nResolved: resolved\n        }, options) : options, this);\n      }\n\n      return res;\n    }\n  }, {\n    key: \"resolve\",\n    value: function resolve(keys) {\n      var _this4 = this;\n\n      var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n      var found;\n      var usedKey;\n      var exactUsedKey;\n      var usedLng;\n      var usedNS;\n      if (typeof keys === 'string') keys = [keys];\n      keys.forEach(function (k) {\n        if (_this4.isValidLookup(found)) return;\n\n        var extracted = _this4.extractFromKey(k, options);\n\n        var key = extracted.key;\n        usedKey = key;\n        var namespaces = extracted.namespaces;\n        if (_this4.options.fallbackNS) namespaces = namespaces.concat(_this4.options.fallbackNS);\n        var needsPluralHandling = options.count !== undefined && typeof options.count !== 'string';\n        var needsContextHandling = options.context !== undefined && (typeof options.context === 'string' || typeof options.context === 'number') && options.context !== '';\n        var codes = options.lngs ? options.lngs : _this4.languageUtils.toResolveHierarchy(options.lng || _this4.language, options.fallbackLng);\n        namespaces.forEach(function (ns) {\n          if (_this4.isValidLookup(found)) return;\n          usedNS = ns;\n\n          if (!checkedLoadedFor[\"\".concat(codes[0], \"-\").concat(ns)] && _this4.utils && _this4.utils.hasLoadedNamespace && !_this4.utils.hasLoadedNamespace(usedNS)) {\n            checkedLoadedFor[\"\".concat(codes[0], \"-\").concat(ns)] = true;\n\n            _this4.logger.warn(\"key \\\"\".concat(usedKey, \"\\\" for languages \\\"\").concat(codes.join(', '), \"\\\" won't get resolved as namespace \\\"\").concat(usedNS, \"\\\" was not yet loaded\"), 'This means something IS WRONG in your setup. You access the t function before i18next.init / i18next.loadNamespace / i18next.changeLanguage was done. Wait for the callback or Promise to resolve before accessing it!!!');\n          }\n\n          codes.forEach(function (code) {\n            if (_this4.isValidLookup(found)) return;\n            usedLng = code;\n            var finalKey = key;\n            var finalKeys = [finalKey];\n\n            if (_this4.i18nFormat && _this4.i18nFormat.addLookupKeys) {\n              _this4.i18nFormat.addLookupKeys(finalKeys, key, code, ns, options);\n            } else {\n              var pluralSuffix;\n              if (needsPluralHandling) pluralSuffix = _this4.pluralResolver.getSuffix(code, options.count);\n              if (needsPluralHandling && needsContextHandling) finalKeys.push(finalKey + pluralSuffix);\n              if (needsContextHandling) finalKeys.push(finalKey += \"\".concat(_this4.options.contextSeparator).concat(options.context));\n              if (needsPluralHandling) finalKeys.push(finalKey += pluralSuffix);\n            }\n\n            var possibleKey;\n\n            while (possibleKey = finalKeys.pop()) {\n              if (!_this4.isValidLookup(found)) {\n                exactUsedKey = possibleKey;\n                found = _this4.getResource(code, ns, possibleKey, options);\n              }\n            }\n          });\n        });\n      });\n      return {\n        res: found,\n        usedKey: usedKey,\n        exactUsedKey: exactUsedKey,\n        usedLng: usedLng,\n        usedNS: usedNS\n      };\n    }\n  }, {\n    key: \"isValidLookup\",\n    value: function isValidLookup(res) {\n      return res !== undefined && !(!this.options.returnNull && res === null) && !(!this.options.returnEmptyString && res === '');\n    }\n  }, {\n    key: \"getResource\",\n    value: function getResource(code, ns, key) {\n      var options = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : {};\n      if (this.i18nFormat && this.i18nFormat.getResource) return this.i18nFormat.getResource(code, ns, key, options);\n      return this.resourceStore.getResource(code, ns, key, options);\n    }\n  }], [{\n    key: \"hasDefaultValue\",\n    value: function hasDefaultValue(options) {\n      var prefix = 'defaultValue';\n\n      for (var option in options) {\n        if (Object.prototype.hasOwnProperty.call(options, option) && prefix === option.substring(0, prefix.length) && undefined !== options[option]) {\n          return true;\n        }\n      }\n\n      return false;\n    }\n  }]);\n\n  return Translator;\n}(EventEmitter);\n\nfunction capitalize(string) {\n  return string.charAt(0).toUpperCase() + string.slice(1);\n}\n\nvar LanguageUtil = function () {\n  function LanguageUtil(options) {\n    (0,_babel_runtime_helpers_esm_classCallCheck__WEBPACK_IMPORTED_MODULE_2__.default)(this, LanguageUtil);\n\n    this.options = options;\n    this.whitelist = this.options.supportedLngs || false;\n    this.supportedLngs = this.options.supportedLngs || false;\n    this.logger = baseLogger.create('languageUtils');\n  }\n\n  (0,_babel_runtime_helpers_esm_createClass__WEBPACK_IMPORTED_MODULE_3__.default)(LanguageUtil, [{\n    key: \"getScriptPartFromCode\",\n    value: function getScriptPartFromCode(code) {\n      if (!code || code.indexOf('-') < 0) return null;\n      var p = code.split('-');\n      if (p.length === 2) return null;\n      p.pop();\n      if (p[p.length - 1].toLowerCase() === 'x') return null;\n      return this.formatLanguageCode(p.join('-'));\n    }\n  }, {\n    key: \"getLanguagePartFromCode\",\n    value: function getLanguagePartFromCode(code) {\n      if (!code || code.indexOf('-') < 0) return code;\n      var p = code.split('-');\n      return this.formatLanguageCode(p[0]);\n    }\n  }, {\n    key: \"formatLanguageCode\",\n    value: function formatLanguageCode(code) {\n      if (typeof code === 'string' && code.indexOf('-') > -1) {\n        var specialCases = ['hans', 'hant', 'latn', 'cyrl', 'cans', 'mong', 'arab'];\n        var p = code.split('-');\n\n        if (this.options.lowerCaseLng) {\n          p = p.map(function (part) {\n            return part.toLowerCase();\n          });\n        } else if (p.length === 2) {\n          p[0] = p[0].toLowerCase();\n          p[1] = p[1].toUpperCase();\n          if (specialCases.indexOf(p[1].toLowerCase()) > -1) p[1] = capitalize(p[1].toLowerCase());\n        } else if (p.length === 3) {\n          p[0] = p[0].toLowerCase();\n          if (p[1].length === 2) p[1] = p[1].toUpperCase();\n          if (p[0] !== 'sgn' && p[2].length === 2) p[2] = p[2].toUpperCase();\n          if (specialCases.indexOf(p[1].toLowerCase()) > -1) p[1] = capitalize(p[1].toLowerCase());\n          if (specialCases.indexOf(p[2].toLowerCase()) > -1) p[2] = capitalize(p[2].toLowerCase());\n        }\n\n        return p.join('-');\n      }\n\n      return this.options.cleanCode || this.options.lowerCaseLng ? code.toLowerCase() : code;\n    }\n  }, {\n    key: \"isWhitelisted\",\n    value: function isWhitelisted(code) {\n      this.logger.deprecate('languageUtils.isWhitelisted', 'function \"isWhitelisted\" will be renamed to \"isSupportedCode\" in the next major - please make sure to rename it\\'s usage asap.');\n      return this.isSupportedCode(code);\n    }\n  }, {\n    key: \"isSupportedCode\",\n    value: function isSupportedCode(code) {\n      if (this.options.load === 'languageOnly' || this.options.nonExplicitSupportedLngs) {\n        code = this.getLanguagePartFromCode(code);\n      }\n\n      return !this.supportedLngs || !this.supportedLngs.length || this.supportedLngs.indexOf(code) > -1;\n    }\n  }, {\n    key: \"getBestMatchFromCodes\",\n    value: function getBestMatchFromCodes(codes) {\n      var _this = this;\n\n      if (!codes) return null;\n      var found;\n      codes.forEach(function (code) {\n        if (found) return;\n\n        var cleanedLng = _this.formatLanguageCode(code);\n\n        if (!_this.options.supportedLngs || _this.isSupportedCode(cleanedLng)) found = cleanedLng;\n      });\n\n      if (!found && this.options.supportedLngs) {\n        codes.forEach(function (code) {\n          if (found) return;\n\n          var lngOnly = _this.getLanguagePartFromCode(code);\n\n          if (_this.isSupportedCode(lngOnly)) return found = lngOnly;\n          found = _this.options.supportedLngs.find(function (supportedLng) {\n            if (supportedLng.indexOf(lngOnly) === 0) return supportedLng;\n          });\n        });\n      }\n\n      if (!found) found = this.getFallbackCodes(this.options.fallbackLng)[0];\n      return found;\n    }\n  }, {\n    key: \"getFallbackCodes\",\n    value: function getFallbackCodes(fallbacks, code) {\n      if (!fallbacks) return [];\n      if (typeof fallbacks === 'function') fallbacks = fallbacks(code);\n      if (typeof fallbacks === 'string') fallbacks = [fallbacks];\n      if (Object.prototype.toString.apply(fallbacks) === '[object Array]') return fallbacks;\n      if (!code) return fallbacks[\"default\"] || [];\n      var found = fallbacks[code];\n      if (!found) found = fallbacks[this.getScriptPartFromCode(code)];\n      if (!found) found = fallbacks[this.formatLanguageCode(code)];\n      if (!found) found = fallbacks[this.getLanguagePartFromCode(code)];\n      if (!found) found = fallbacks[\"default\"];\n      return found || [];\n    }\n  }, {\n    key: \"toResolveHierarchy\",\n    value: function toResolveHierarchy(code, fallbackCode) {\n      var _this2 = this;\n\n      var fallbackCodes = this.getFallbackCodes(fallbackCode || this.options.fallbackLng || [], code);\n      var codes = [];\n\n      var addCode = function addCode(c) {\n        if (!c) return;\n\n        if (_this2.isSupportedCode(c)) {\n          codes.push(c);\n        } else {\n          _this2.logger.warn(\"rejecting language code not found in supportedLngs: \".concat(c));\n        }\n      };\n\n      if (typeof code === 'string' && code.indexOf('-') > -1) {\n        if (this.options.load !== 'languageOnly') addCode(this.formatLanguageCode(code));\n        if (this.options.load !== 'languageOnly' && this.options.load !== 'currentOnly') addCode(this.getScriptPartFromCode(code));\n        if (this.options.load !== 'currentOnly') addCode(this.getLanguagePartFromCode(code));\n      } else if (typeof code === 'string') {\n        addCode(this.formatLanguageCode(code));\n      }\n\n      fallbackCodes.forEach(function (fc) {\n        if (codes.indexOf(fc) < 0) addCode(_this2.formatLanguageCode(fc));\n      });\n      return codes;\n    }\n  }]);\n\n  return LanguageUtil;\n}();\n\nvar sets = [{\n  lngs: ['ach', 'ak', 'am', 'arn', 'br', 'fil', 'gun', 'ln', 'mfe', 'mg', 'mi', 'oc', 'pt', 'pt-BR', 'tg', 'tl', 'ti', 'tr', 'uz', 'wa'],\n  nr: [1, 2],\n  fc: 1\n}, {\n  lngs: ['af', 'an', 'ast', 'az', 'bg', 'bn', 'ca', 'da', 'de', 'dev', 'el', 'en', 'eo', 'es', 'et', 'eu', 'fi', 'fo', 'fur', 'fy', 'gl', 'gu', 'ha', 'hi', 'hu', 'hy', 'ia', 'it', 'kk', 'kn', 'ku', 'lb', 'mai', 'ml', 'mn', 'mr', 'nah', 'nap', 'nb', 'ne', 'nl', 'nn', 'no', 'nso', 'pa', 'pap', 'pms', 'ps', 'pt-PT', 'rm', 'sco', 'se', 'si', 'so', 'son', 'sq', 'sv', 'sw', 'ta', 'te', 'tk', 'ur', 'yo'],\n  nr: [1, 2],\n  fc: 2\n}, {\n  lngs: ['ay', 'bo', 'cgg', 'fa', 'ht', 'id', 'ja', 'jbo', 'ka', 'km', 'ko', 'ky', 'lo', 'ms', 'sah', 'su', 'th', 'tt', 'ug', 'vi', 'wo', 'zh'],\n  nr: [1],\n  fc: 3\n}, {\n  lngs: ['be', 'bs', 'cnr', 'dz', 'hr', 'ru', 'sr', 'uk'],\n  nr: [1, 2, 5],\n  fc: 4\n}, {\n  lngs: ['ar'],\n  nr: [0, 1, 2, 3, 11, 100],\n  fc: 5\n}, {\n  lngs: ['cs', 'sk'],\n  nr: [1, 2, 5],\n  fc: 6\n}, {\n  lngs: ['csb', 'pl'],\n  nr: [1, 2, 5],\n  fc: 7\n}, {\n  lngs: ['cy'],\n  nr: [1, 2, 3, 8],\n  fc: 8\n}, {\n  lngs: ['fr'],\n  nr: [1, 2],\n  fc: 9\n}, {\n  lngs: ['ga'],\n  nr: [1, 2, 3, 7, 11],\n  fc: 10\n}, {\n  lngs: ['gd'],\n  nr: [1, 2, 3, 20],\n  fc: 11\n}, {\n  lngs: ['is'],\n  nr: [1, 2],\n  fc: 12\n}, {\n  lngs: ['jv'],\n  nr: [0, 1],\n  fc: 13\n}, {\n  lngs: ['kw'],\n  nr: [1, 2, 3, 4],\n  fc: 14\n}, {\n  lngs: ['lt'],\n  nr: [1, 2, 10],\n  fc: 15\n}, {\n  lngs: ['lv'],\n  nr: [1, 2, 0],\n  fc: 16\n}, {\n  lngs: ['mk'],\n  nr: [1, 2],\n  fc: 17\n}, {\n  lngs: ['mnk'],\n  nr: [0, 1, 2],\n  fc: 18\n}, {\n  lngs: ['mt'],\n  nr: [1, 2, 11, 20],\n  fc: 19\n}, {\n  lngs: ['or'],\n  nr: [2, 1],\n  fc: 2\n}, {\n  lngs: ['ro'],\n  nr: [1, 2, 20],\n  fc: 20\n}, {\n  lngs: ['sl'],\n  nr: [5, 1, 2, 3],\n  fc: 21\n}, {\n  lngs: ['he', 'iw'],\n  nr: [1, 2, 20, 21],\n  fc: 22\n}];\nvar _rulesPluralsTypes = {\n  1: function _(n) {\n    return Number(n > 1);\n  },\n  2: function _(n) {\n    return Number(n != 1);\n  },\n  3: function _(n) {\n    return 0;\n  },\n  4: function _(n) {\n    return Number(n % 10 == 1 && n % 100 != 11 ? 0 : n % 10 >= 2 && n % 10 <= 4 && (n % 100 < 10 || n % 100 >= 20) ? 1 : 2);\n  },\n  5: function _(n) {\n    return Number(n == 0 ? 0 : n == 1 ? 1 : n == 2 ? 2 : n % 100 >= 3 && n % 100 <= 10 ? 3 : n % 100 >= 11 ? 4 : 5);\n  },\n  6: function _(n) {\n    return Number(n == 1 ? 0 : n >= 2 && n <= 4 ? 1 : 2);\n  },\n  7: function _(n) {\n    return Number(n == 1 ? 0 : n % 10 >= 2 && n % 10 <= 4 && (n % 100 < 10 || n % 100 >= 20) ? 1 : 2);\n  },\n  8: function _(n) {\n    return Number(n == 1 ? 0 : n == 2 ? 1 : n != 8 && n != 11 ? 2 : 3);\n  },\n  9: function _(n) {\n    return Number(n >= 2);\n  },\n  10: function _(n) {\n    return Number(n == 1 ? 0 : n == 2 ? 1 : n < 7 ? 2 : n < 11 ? 3 : 4);\n  },\n  11: function _(n) {\n    return Number(n == 1 || n == 11 ? 0 : n == 2 || n == 12 ? 1 : n > 2 && n < 20 ? 2 : 3);\n  },\n  12: function _(n) {\n    return Number(n % 10 != 1 || n % 100 == 11);\n  },\n  13: function _(n) {\n    return Number(n !== 0);\n  },\n  14: function _(n) {\n    return Number(n == 1 ? 0 : n == 2 ? 1 : n == 3 ? 2 : 3);\n  },\n  15: function _(n) {\n    return Number(n % 10 == 1 && n % 100 != 11 ? 0 : n % 10 >= 2 && (n % 100 < 10 || n % 100 >= 20) ? 1 : 2);\n  },\n  16: function _(n) {\n    return Number(n % 10 == 1 && n % 100 != 11 ? 0 : n !== 0 ? 1 : 2);\n  },\n  17: function _(n) {\n    return Number(n == 1 || n % 10 == 1 && n % 100 != 11 ? 0 : 1);\n  },\n  18: function _(n) {\n    return Number(n == 0 ? 0 : n == 1 ? 1 : 2);\n  },\n  19: function _(n) {\n    return Number(n == 1 ? 0 : n == 0 || n % 100 > 1 && n % 100 < 11 ? 1 : n % 100 > 10 && n % 100 < 20 ? 2 : 3);\n  },\n  20: function _(n) {\n    return Number(n == 1 ? 0 : n == 0 || n % 100 > 0 && n % 100 < 20 ? 1 : 2);\n  },\n  21: function _(n) {\n    return Number(n % 100 == 1 ? 1 : n % 100 == 2 ? 2 : n % 100 == 3 || n % 100 == 4 ? 3 : 0);\n  },\n  22: function _(n) {\n    return Number(n == 1 ? 0 : n == 2 ? 1 : (n < 0 || n > 10) && n % 10 == 0 ? 2 : 3);\n  }\n};\n\nfunction createRules() {\n  var rules = {};\n  sets.forEach(function (set) {\n    set.lngs.forEach(function (l) {\n      rules[l] = {\n        numbers: set.nr,\n        plurals: _rulesPluralsTypes[set.fc]\n      };\n    });\n  });\n  return rules;\n}\n\nvar PluralResolver = function () {\n  function PluralResolver(languageUtils) {\n    var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n\n    (0,_babel_runtime_helpers_esm_classCallCheck__WEBPACK_IMPORTED_MODULE_2__.default)(this, PluralResolver);\n\n    this.languageUtils = languageUtils;\n    this.options = options;\n    this.logger = baseLogger.create('pluralResolver');\n    this.rules = createRules();\n  }\n\n  (0,_babel_runtime_helpers_esm_createClass__WEBPACK_IMPORTED_MODULE_3__.default)(PluralResolver, [{\n    key: \"addRule\",\n    value: function addRule(lng, obj) {\n      this.rules[lng] = obj;\n    }\n  }, {\n    key: \"getRule\",\n    value: function getRule(code) {\n      return this.rules[code] || this.rules[this.languageUtils.getLanguagePartFromCode(code)];\n    }\n  }, {\n    key: \"needsPlural\",\n    value: function needsPlural(code) {\n      var rule = this.getRule(code);\n      return rule && rule.numbers.length > 1;\n    }\n  }, {\n    key: \"getPluralFormsOfKey\",\n    value: function getPluralFormsOfKey(code, key) {\n      return this.getSuffixes(code).map(function (suffix) {\n        return key + suffix;\n      });\n    }\n  }, {\n    key: \"getSuffixes\",\n    value: function getSuffixes(code) {\n      var _this = this;\n\n      var rule = this.getRule(code);\n\n      if (!rule) {\n        return [];\n      }\n\n      return rule.numbers.map(function (number) {\n        return _this.getSuffix(code, number);\n      });\n    }\n  }, {\n    key: \"getSuffix\",\n    value: function getSuffix(code, count) {\n      var _this2 = this;\n\n      var rule = this.getRule(code);\n\n      if (rule) {\n        var idx = rule.noAbs ? rule.plurals(count) : rule.plurals(Math.abs(count));\n        var suffix = rule.numbers[idx];\n\n        if (this.options.simplifyPluralSuffix && rule.numbers.length === 2 && rule.numbers[0] === 1) {\n          if (suffix === 2) {\n            suffix = 'plural';\n          } else if (suffix === 1) {\n            suffix = '';\n          }\n        }\n\n        var returnSuffix = function returnSuffix() {\n          return _this2.options.prepend && suffix.toString() ? _this2.options.prepend + suffix.toString() : suffix.toString();\n        };\n\n        if (this.options.compatibilityJSON === 'v1') {\n          if (suffix === 1) return '';\n          if (typeof suffix === 'number') return \"_plural_\".concat(suffix.toString());\n          return returnSuffix();\n        } else if (this.options.compatibilityJSON === 'v2') {\n          return returnSuffix();\n        } else if (this.options.simplifyPluralSuffix && rule.numbers.length === 2 && rule.numbers[0] === 1) {\n          return returnSuffix();\n        }\n\n        return this.options.prepend && idx.toString() ? this.options.prepend + idx.toString() : idx.toString();\n      }\n\n      this.logger.warn(\"no plural rule found for: \".concat(code));\n      return '';\n    }\n  }]);\n\n  return PluralResolver;\n}();\n\nvar Interpolator = function () {\n  function Interpolator() {\n    var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n\n    (0,_babel_runtime_helpers_esm_classCallCheck__WEBPACK_IMPORTED_MODULE_2__.default)(this, Interpolator);\n\n    this.logger = baseLogger.create('interpolator');\n    this.options = options;\n\n    this.format = options.interpolation && options.interpolation.format || function (value) {\n      return value;\n    };\n\n    this.init(options);\n  }\n\n  (0,_babel_runtime_helpers_esm_createClass__WEBPACK_IMPORTED_MODULE_3__.default)(Interpolator, [{\n    key: \"init\",\n    value: function init() {\n      var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n      if (!options.interpolation) options.interpolation = {\n        escapeValue: true\n      };\n      var iOpts = options.interpolation;\n      this.escape = iOpts.escape !== undefined ? iOpts.escape : escape;\n      this.escapeValue = iOpts.escapeValue !== undefined ? iOpts.escapeValue : true;\n      this.useRawValueToEscape = iOpts.useRawValueToEscape !== undefined ? iOpts.useRawValueToEscape : false;\n      this.prefix = iOpts.prefix ? regexEscape(iOpts.prefix) : iOpts.prefixEscaped || '{{';\n      this.suffix = iOpts.suffix ? regexEscape(iOpts.suffix) : iOpts.suffixEscaped || '}}';\n      this.formatSeparator = iOpts.formatSeparator ? iOpts.formatSeparator : iOpts.formatSeparator || ',';\n      this.unescapePrefix = iOpts.unescapeSuffix ? '' : iOpts.unescapePrefix || '-';\n      this.unescapeSuffix = this.unescapePrefix ? '' : iOpts.unescapeSuffix || '';\n      this.nestingPrefix = iOpts.nestingPrefix ? regexEscape(iOpts.nestingPrefix) : iOpts.nestingPrefixEscaped || regexEscape('$t(');\n      this.nestingSuffix = iOpts.nestingSuffix ? regexEscape(iOpts.nestingSuffix) : iOpts.nestingSuffixEscaped || regexEscape(')');\n      this.nestingOptionsSeparator = iOpts.nestingOptionsSeparator ? iOpts.nestingOptionsSeparator : iOpts.nestingOptionsSeparator || ',';\n      this.maxReplaces = iOpts.maxReplaces ? iOpts.maxReplaces : 1000;\n      this.alwaysFormat = iOpts.alwaysFormat !== undefined ? iOpts.alwaysFormat : false;\n      this.resetRegExp();\n    }\n  }, {\n    key: \"reset\",\n    value: function reset() {\n      if (this.options) this.init(this.options);\n    }\n  }, {\n    key: \"resetRegExp\",\n    value: function resetRegExp() {\n      var regexpStr = \"\".concat(this.prefix, \"(.+?)\").concat(this.suffix);\n      this.regexp = new RegExp(regexpStr, 'g');\n      var regexpUnescapeStr = \"\".concat(this.prefix).concat(this.unescapePrefix, \"(.+?)\").concat(this.unescapeSuffix).concat(this.suffix);\n      this.regexpUnescape = new RegExp(regexpUnescapeStr, 'g');\n      var nestingRegexpStr = \"\".concat(this.nestingPrefix, \"(.+?)\").concat(this.nestingSuffix);\n      this.nestingRegexp = new RegExp(nestingRegexpStr, 'g');\n    }\n  }, {\n    key: \"interpolate\",\n    value: function interpolate(str, data, lng, options) {\n      var _this = this;\n\n      var match;\n      var value;\n      var replaces;\n      var defaultData = this.options && this.options.interpolation && this.options.interpolation.defaultVariables || {};\n\n      function regexSafe(val) {\n        return val.replace(/\\$/g, '$$$$');\n      }\n\n      var handleFormat = function handleFormat(key) {\n        if (key.indexOf(_this.formatSeparator) < 0) {\n          var path = getPathWithDefaults(data, defaultData, key);\n          return _this.alwaysFormat ? _this.format(path, undefined, lng, (0,_babel_runtime_helpers_esm_objectSpread__WEBPACK_IMPORTED_MODULE_1__.default)({}, options, data, {\n            interpolationkey: key\n          })) : path;\n        }\n\n        var p = key.split(_this.formatSeparator);\n        var k = p.shift().trim();\n        var f = p.join(_this.formatSeparator).trim();\n        return _this.format(getPathWithDefaults(data, defaultData, k), f, lng, (0,_babel_runtime_helpers_esm_objectSpread__WEBPACK_IMPORTED_MODULE_1__.default)({}, options, data, {\n          interpolationkey: k\n        }));\n      };\n\n      this.resetRegExp();\n      var missingInterpolationHandler = options && options.missingInterpolationHandler || this.options.missingInterpolationHandler;\n      var skipOnVariables = options && options.interpolation && options.interpolation.skipOnVariables || this.options.interpolation.skipOnVariables;\n      var todos = [{\n        regex: this.regexpUnescape,\n        safeValue: function safeValue(val) {\n          return regexSafe(val);\n        }\n      }, {\n        regex: this.regexp,\n        safeValue: function safeValue(val) {\n          return _this.escapeValue ? regexSafe(_this.escape(val)) : regexSafe(val);\n        }\n      }];\n      todos.forEach(function (todo) {\n        replaces = 0;\n\n        while (match = todo.regex.exec(str)) {\n          value = handleFormat(match[1].trim());\n\n          if (value === undefined) {\n            if (typeof missingInterpolationHandler === 'function') {\n              var temp = missingInterpolationHandler(str, match, options);\n              value = typeof temp === 'string' ? temp : '';\n            } else if (skipOnVariables) {\n              value = match[0];\n              continue;\n            } else {\n              _this.logger.warn(\"missed to pass in variable \".concat(match[1], \" for interpolating \").concat(str));\n\n              value = '';\n            }\n          } else if (typeof value !== 'string' && !_this.useRawValueToEscape) {\n            value = makeString(value);\n          }\n\n          var safeValue = todo.safeValue(value);\n          str = str.replace(match[0], safeValue);\n\n          if (skipOnVariables) {\n            todo.regex.lastIndex += safeValue.length;\n            todo.regex.lastIndex -= match[0].length;\n          } else {\n            todo.regex.lastIndex = 0;\n          }\n\n          replaces++;\n\n          if (replaces >= _this.maxReplaces) {\n            break;\n          }\n        }\n      });\n      return str;\n    }\n  }, {\n    key: \"nest\",\n    value: function nest(str, fc) {\n      var _this2 = this;\n\n      var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n      var match;\n      var value;\n\n      var clonedOptions = (0,_babel_runtime_helpers_esm_objectSpread__WEBPACK_IMPORTED_MODULE_1__.default)({}, options);\n\n      clonedOptions.applyPostProcessor = false;\n      delete clonedOptions.defaultValue;\n\n      function handleHasOptions(key, inheritedOptions) {\n        var sep = this.nestingOptionsSeparator;\n        if (key.indexOf(sep) < 0) return key;\n        var c = key.split(new RegExp(\"\".concat(sep, \"[ ]*{\")));\n        var optionsString = \"{\".concat(c[1]);\n        key = c[0];\n        optionsString = this.interpolate(optionsString, clonedOptions);\n        optionsString = optionsString.replace(/'/g, '\"');\n\n        try {\n          clonedOptions = JSON.parse(optionsString);\n          if (inheritedOptions) clonedOptions = (0,_babel_runtime_helpers_esm_objectSpread__WEBPACK_IMPORTED_MODULE_1__.default)({}, inheritedOptions, clonedOptions);\n        } catch (e) {\n          this.logger.warn(\"failed parsing options string in nesting for key \".concat(key), e);\n          return \"\".concat(key).concat(sep).concat(optionsString);\n        }\n\n        delete clonedOptions.defaultValue;\n        return key;\n      }\n\n      while (match = this.nestingRegexp.exec(str)) {\n        var formatters = [];\n        var doReduce = false;\n\n        if (match[0].indexOf(this.formatSeparator) !== -1 && !/{.*}/.test(match[1])) {\n          var r = match[1].split(this.formatSeparator).map(function (elem) {\n            return elem.trim();\n          });\n          match[1] = r.shift();\n          formatters = r;\n          doReduce = true;\n        }\n\n        value = fc(handleHasOptions.call(this, match[1].trim(), clonedOptions), clonedOptions);\n        if (value && match[0] === str && typeof value !== 'string') return value;\n        if (typeof value !== 'string') value = makeString(value);\n\n        if (!value) {\n          this.logger.warn(\"missed to resolve \".concat(match[1], \" for nesting \").concat(str));\n          value = '';\n        }\n\n        if (doReduce) {\n          value = formatters.reduce(function (v, f) {\n            return _this2.format(v, f, options.lng, (0,_babel_runtime_helpers_esm_objectSpread__WEBPACK_IMPORTED_MODULE_1__.default)({}, options, {\n              interpolationkey: match[1].trim()\n            }));\n          }, value.trim());\n        }\n\n        str = str.replace(match[0], value);\n        this.regexp.lastIndex = 0;\n      }\n\n      return str;\n    }\n  }]);\n\n  return Interpolator;\n}();\n\nfunction remove(arr, what) {\n  var found = arr.indexOf(what);\n\n  while (found !== -1) {\n    arr.splice(found, 1);\n    found = arr.indexOf(what);\n  }\n}\n\nvar Connector = function (_EventEmitter) {\n  (0,_babel_runtime_helpers_esm_inherits__WEBPACK_IMPORTED_MODULE_7__.default)(Connector, _EventEmitter);\n\n  function Connector(backend, store, services) {\n    var _this;\n\n    var options = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : {};\n\n    (0,_babel_runtime_helpers_esm_classCallCheck__WEBPACK_IMPORTED_MODULE_2__.default)(this, Connector);\n\n    _this = (0,_babel_runtime_helpers_esm_possibleConstructorReturn__WEBPACK_IMPORTED_MODULE_4__.default)(this, (0,_babel_runtime_helpers_esm_getPrototypeOf__WEBPACK_IMPORTED_MODULE_5__.default)(Connector).call(this));\n\n    if (isIE10) {\n      EventEmitter.call((0,_babel_runtime_helpers_esm_assertThisInitialized__WEBPACK_IMPORTED_MODULE_6__.default)(_this));\n    }\n\n    _this.backend = backend;\n    _this.store = store;\n    _this.services = services;\n    _this.languageUtils = services.languageUtils;\n    _this.options = options;\n    _this.logger = baseLogger.create('backendConnector');\n    _this.state = {};\n    _this.queue = [];\n\n    if (_this.backend && _this.backend.init) {\n      _this.backend.init(services, options.backend, options);\n    }\n\n    return _this;\n  }\n\n  (0,_babel_runtime_helpers_esm_createClass__WEBPACK_IMPORTED_MODULE_3__.default)(Connector, [{\n    key: \"queueLoad\",\n    value: function queueLoad(languages, namespaces, options, callback) {\n      var _this2 = this;\n\n      var toLoad = [];\n      var pending = [];\n      var toLoadLanguages = [];\n      var toLoadNamespaces = [];\n      languages.forEach(function (lng) {\n        var hasAllNamespaces = true;\n        namespaces.forEach(function (ns) {\n          var name = \"\".concat(lng, \"|\").concat(ns);\n\n          if (!options.reload && _this2.store.hasResourceBundle(lng, ns)) {\n            _this2.state[name] = 2;\n          } else if (_this2.state[name] < 0) ; else if (_this2.state[name] === 1) {\n            if (pending.indexOf(name) < 0) pending.push(name);\n          } else {\n            _this2.state[name] = 1;\n            hasAllNamespaces = false;\n            if (pending.indexOf(name) < 0) pending.push(name);\n            if (toLoad.indexOf(name) < 0) toLoad.push(name);\n            if (toLoadNamespaces.indexOf(ns) < 0) toLoadNamespaces.push(ns);\n          }\n        });\n        if (!hasAllNamespaces) toLoadLanguages.push(lng);\n      });\n\n      if (toLoad.length || pending.length) {\n        this.queue.push({\n          pending: pending,\n          loaded: {},\n          errors: [],\n          callback: callback\n        });\n      }\n\n      return {\n        toLoad: toLoad,\n        pending: pending,\n        toLoadLanguages: toLoadLanguages,\n        toLoadNamespaces: toLoadNamespaces\n      };\n    }\n  }, {\n    key: \"loaded\",\n    value: function loaded(name, err, data) {\n      var s = name.split('|');\n      var lng = s[0];\n      var ns = s[1];\n      if (err) this.emit('failedLoading', lng, ns, err);\n\n      if (data) {\n        this.store.addResourceBundle(lng, ns, data);\n      }\n\n      this.state[name] = err ? -1 : 2;\n      var loaded = {};\n      this.queue.forEach(function (q) {\n        pushPath(q.loaded, [lng], ns);\n        remove(q.pending, name);\n        if (err) q.errors.push(err);\n\n        if (q.pending.length === 0 && !q.done) {\n          Object.keys(q.loaded).forEach(function (l) {\n            if (!loaded[l]) loaded[l] = [];\n\n            if (q.loaded[l].length) {\n              q.loaded[l].forEach(function (ns) {\n                if (loaded[l].indexOf(ns) < 0) loaded[l].push(ns);\n              });\n            }\n          });\n          q.done = true;\n\n          if (q.errors.length) {\n            q.callback(q.errors);\n          } else {\n            q.callback();\n          }\n        }\n      });\n      this.emit('loaded', loaded);\n      this.queue = this.queue.filter(function (q) {\n        return !q.done;\n      });\n    }\n  }, {\n    key: \"read\",\n    value: function read(lng, ns, fcName) {\n      var _this3 = this;\n\n      var tried = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : 0;\n      var wait = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : 350;\n      var callback = arguments.length > 5 ? arguments[5] : undefined;\n      if (!lng.length) return callback(null, {});\n      return this.backend[fcName](lng, ns, function (err, data) {\n        if (err && data && tried < 5) {\n          setTimeout(function () {\n            _this3.read.call(_this3, lng, ns, fcName, tried + 1, wait * 2, callback);\n          }, wait);\n          return;\n        }\n\n        callback(err, data);\n      });\n    }\n  }, {\n    key: \"prepareLoading\",\n    value: function prepareLoading(languages, namespaces) {\n      var _this4 = this;\n\n      var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n      var callback = arguments.length > 3 ? arguments[3] : undefined;\n\n      if (!this.backend) {\n        this.logger.warn('No backend was added via i18next.use. Will not load resources.');\n        return callback && callback();\n      }\n\n      if (typeof languages === 'string') languages = this.languageUtils.toResolveHierarchy(languages);\n      if (typeof namespaces === 'string') namespaces = [namespaces];\n      var toLoad = this.queueLoad(languages, namespaces, options, callback);\n\n      if (!toLoad.toLoad.length) {\n        if (!toLoad.pending.length) callback();\n        return null;\n      }\n\n      toLoad.toLoad.forEach(function (name) {\n        _this4.loadOne(name);\n      });\n    }\n  }, {\n    key: \"load\",\n    value: function load(languages, namespaces, callback) {\n      this.prepareLoading(languages, namespaces, {}, callback);\n    }\n  }, {\n    key: \"reload\",\n    value: function reload(languages, namespaces, callback) {\n      this.prepareLoading(languages, namespaces, {\n        reload: true\n      }, callback);\n    }\n  }, {\n    key: \"loadOne\",\n    value: function loadOne(name) {\n      var _this5 = this;\n\n      var prefix = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : '';\n      var s = name.split('|');\n      var lng = s[0];\n      var ns = s[1];\n      this.read(lng, ns, 'read', undefined, undefined, function (err, data) {\n        if (err) _this5.logger.warn(\"\".concat(prefix, \"loading namespace \").concat(ns, \" for language \").concat(lng, \" failed\"), err);\n        if (!err && data) _this5.logger.log(\"\".concat(prefix, \"loaded namespace \").concat(ns, \" for language \").concat(lng), data);\n\n        _this5.loaded(name, err, data);\n      });\n    }\n  }, {\n    key: \"saveMissing\",\n    value: function saveMissing(languages, namespace, key, fallbackValue, isUpdate) {\n      var options = arguments.length > 5 && arguments[5] !== undefined ? arguments[5] : {};\n\n      if (this.services.utils && this.services.utils.hasLoadedNamespace && !this.services.utils.hasLoadedNamespace(namespace)) {\n        this.logger.warn(\"did not save key \\\"\".concat(key, \"\\\" as the namespace \\\"\").concat(namespace, \"\\\" was not yet loaded\"), 'This means something IS WRONG in your setup. You access the t function before i18next.init / i18next.loadNamespace / i18next.changeLanguage was done. Wait for the callback or Promise to resolve before accessing it!!!');\n        return;\n      }\n\n      if (key === undefined || key === null || key === '') return;\n\n      if (this.backend && this.backend.create) {\n        this.backend.create(languages, namespace, key, fallbackValue, null, (0,_babel_runtime_helpers_esm_objectSpread__WEBPACK_IMPORTED_MODULE_1__.default)({}, options, {\n          isUpdate: isUpdate\n        }));\n      }\n\n      if (!languages || !languages[0]) return;\n      this.store.addResource(languages[0], namespace, key, fallbackValue);\n    }\n  }]);\n\n  return Connector;\n}(EventEmitter);\n\nfunction get() {\n  return {\n    debug: false,\n    initImmediate: true,\n    ns: ['translation'],\n    defaultNS: ['translation'],\n    fallbackLng: ['dev'],\n    fallbackNS: false,\n    whitelist: false,\n    nonExplicitWhitelist: false,\n    supportedLngs: false,\n    nonExplicitSupportedLngs: false,\n    load: 'all',\n    preload: false,\n    simplifyPluralSuffix: true,\n    keySeparator: '.',\n    nsSeparator: ':',\n    pluralSeparator: '_',\n    contextSeparator: '_',\n    partialBundledLanguages: false,\n    saveMissing: false,\n    updateMissing: false,\n    saveMissingTo: 'fallback',\n    saveMissingPlurals: true,\n    missingKeyHandler: false,\n    missingInterpolationHandler: false,\n    postProcess: false,\n    postProcessPassResolved: false,\n    returnNull: true,\n    returnEmptyString: true,\n    returnObjects: false,\n    joinArrays: false,\n    returnedObjectHandler: false,\n    parseMissingKeyHandler: false,\n    appendNamespaceToMissingKey: false,\n    appendNamespaceToCIMode: false,\n    overloadTranslationOptionHandler: function handle(args) {\n      var ret = {};\n      if ((0,_babel_runtime_helpers_esm_typeof__WEBPACK_IMPORTED_MODULE_0__.default)(args[1]) === 'object') ret = args[1];\n      if (typeof args[1] === 'string') ret.defaultValue = args[1];\n      if (typeof args[2] === 'string') ret.tDescription = args[2];\n\n      if ((0,_babel_runtime_helpers_esm_typeof__WEBPACK_IMPORTED_MODULE_0__.default)(args[2]) === 'object' || (0,_babel_runtime_helpers_esm_typeof__WEBPACK_IMPORTED_MODULE_0__.default)(args[3]) === 'object') {\n        var options = args[3] || args[2];\n        Object.keys(options).forEach(function (key) {\n          ret[key] = options[key];\n        });\n      }\n\n      return ret;\n    },\n    interpolation: {\n      escapeValue: true,\n      format: function format(value, _format, lng, options) {\n        return value;\n      },\n      prefix: '{{',\n      suffix: '}}',\n      formatSeparator: ',',\n      unescapePrefix: '-',\n      nestingPrefix: '$t(',\n      nestingSuffix: ')',\n      nestingOptionsSeparator: ',',\n      maxReplaces: 1000,\n      skipOnVariables: false\n    }\n  };\n}\nfunction transformOptions(options) {\n  if (typeof options.ns === 'string') options.ns = [options.ns];\n  if (typeof options.fallbackLng === 'string') options.fallbackLng = [options.fallbackLng];\n  if (typeof options.fallbackNS === 'string') options.fallbackNS = [options.fallbackNS];\n\n  if (options.whitelist) {\n    if (options.whitelist && options.whitelist.indexOf('cimode') < 0) {\n      options.whitelist = options.whitelist.concat(['cimode']);\n    }\n\n    options.supportedLngs = options.whitelist;\n  }\n\n  if (options.nonExplicitWhitelist) {\n    options.nonExplicitSupportedLngs = options.nonExplicitWhitelist;\n  }\n\n  if (options.supportedLngs && options.supportedLngs.indexOf('cimode') < 0) {\n    options.supportedLngs = options.supportedLngs.concat(['cimode']);\n  }\n\n  return options;\n}\n\nfunction noop() {}\n\nvar I18n = function (_EventEmitter) {\n  (0,_babel_runtime_helpers_esm_inherits__WEBPACK_IMPORTED_MODULE_7__.default)(I18n, _EventEmitter);\n\n  function I18n() {\n    var _this;\n\n    var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n    var callback = arguments.length > 1 ? arguments[1] : undefined;\n\n    (0,_babel_runtime_helpers_esm_classCallCheck__WEBPACK_IMPORTED_MODULE_2__.default)(this, I18n);\n\n    _this = (0,_babel_runtime_helpers_esm_possibleConstructorReturn__WEBPACK_IMPORTED_MODULE_4__.default)(this, (0,_babel_runtime_helpers_esm_getPrototypeOf__WEBPACK_IMPORTED_MODULE_5__.default)(I18n).call(this));\n\n    if (isIE10) {\n      EventEmitter.call((0,_babel_runtime_helpers_esm_assertThisInitialized__WEBPACK_IMPORTED_MODULE_6__.default)(_this));\n    }\n\n    _this.options = transformOptions(options);\n    _this.services = {};\n    _this.logger = baseLogger;\n    _this.modules = {\n      external: []\n    };\n\n    if (callback && !_this.isInitialized && !options.isClone) {\n      if (!_this.options.initImmediate) {\n        _this.init(options, callback);\n\n        return (0,_babel_runtime_helpers_esm_possibleConstructorReturn__WEBPACK_IMPORTED_MODULE_4__.default)(_this, (0,_babel_runtime_helpers_esm_assertThisInitialized__WEBPACK_IMPORTED_MODULE_6__.default)(_this));\n      }\n\n      setTimeout(function () {\n        _this.init(options, callback);\n      }, 0);\n    }\n\n    return _this;\n  }\n\n  (0,_babel_runtime_helpers_esm_createClass__WEBPACK_IMPORTED_MODULE_3__.default)(I18n, [{\n    key: \"init\",\n    value: function init() {\n      var _this2 = this;\n\n      var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n      var callback = arguments.length > 1 ? arguments[1] : undefined;\n\n      if (typeof options === 'function') {\n        callback = options;\n        options = {};\n      }\n\n      if (options.whitelist && !options.supportedLngs) {\n        this.logger.deprecate('whitelist', 'option \"whitelist\" will be renamed to \"supportedLngs\" in the next major - please make sure to rename this option asap.');\n      }\n\n      if (options.nonExplicitWhitelist && !options.nonExplicitSupportedLngs) {\n        this.logger.deprecate('whitelist', 'options \"nonExplicitWhitelist\" will be renamed to \"nonExplicitSupportedLngs\" in the next major - please make sure to rename this option asap.');\n      }\n\n      this.options = (0,_babel_runtime_helpers_esm_objectSpread__WEBPACK_IMPORTED_MODULE_1__.default)({}, get(), this.options, transformOptions(options));\n      this.format = this.options.interpolation.format;\n      if (!callback) callback = noop;\n\n      function createClassOnDemand(ClassOrObject) {\n        if (!ClassOrObject) return null;\n        if (typeof ClassOrObject === 'function') return new ClassOrObject();\n        return ClassOrObject;\n      }\n\n      if (!this.options.isClone) {\n        if (this.modules.logger) {\n          baseLogger.init(createClassOnDemand(this.modules.logger), this.options);\n        } else {\n          baseLogger.init(null, this.options);\n        }\n\n        var lu = new LanguageUtil(this.options);\n        this.store = new ResourceStore(this.options.resources, this.options);\n        var s = this.services;\n        s.logger = baseLogger;\n        s.resourceStore = this.store;\n        s.languageUtils = lu;\n        s.pluralResolver = new PluralResolver(lu, {\n          prepend: this.options.pluralSeparator,\n          compatibilityJSON: this.options.compatibilityJSON,\n          simplifyPluralSuffix: this.options.simplifyPluralSuffix\n        });\n        s.interpolator = new Interpolator(this.options);\n        s.utils = {\n          hasLoadedNamespace: this.hasLoadedNamespace.bind(this)\n        };\n        s.backendConnector = new Connector(createClassOnDemand(this.modules.backend), s.resourceStore, s, this.options);\n        s.backendConnector.on('*', function (event) {\n          for (var _len = arguments.length, args = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {\n            args[_key - 1] = arguments[_key];\n          }\n\n          _this2.emit.apply(_this2, [event].concat(args));\n        });\n\n        if (this.modules.languageDetector) {\n          s.languageDetector = createClassOnDemand(this.modules.languageDetector);\n          s.languageDetector.init(s, this.options.detection, this.options);\n        }\n\n        if (this.modules.i18nFormat) {\n          s.i18nFormat = createClassOnDemand(this.modules.i18nFormat);\n          if (s.i18nFormat.init) s.i18nFormat.init(this);\n        }\n\n        this.translator = new Translator(this.services, this.options);\n        this.translator.on('*', function (event) {\n          for (var _len2 = arguments.length, args = new Array(_len2 > 1 ? _len2 - 1 : 0), _key2 = 1; _key2 < _len2; _key2++) {\n            args[_key2 - 1] = arguments[_key2];\n          }\n\n          _this2.emit.apply(_this2, [event].concat(args));\n        });\n        this.modules.external.forEach(function (m) {\n          if (m.init) m.init(_this2);\n        });\n      }\n\n      if (this.options.fallbackLng && !this.services.languageDetector && !this.options.lng) {\n        var codes = this.services.languageUtils.getFallbackCodes(this.options.fallbackLng);\n        if (codes.length > 0 && codes[0] !== 'dev') this.options.lng = codes[0];\n      }\n\n      if (!this.services.languageDetector && !this.options.lng) {\n        this.logger.warn('init: no languageDetector is used and no lng is defined');\n      }\n\n      var storeApi = ['getResource', 'hasResourceBundle', 'getResourceBundle', 'getDataByLanguage'];\n      storeApi.forEach(function (fcName) {\n        _this2[fcName] = function () {\n          var _this2$store;\n\n          return (_this2$store = _this2.store)[fcName].apply(_this2$store, arguments);\n        };\n      });\n      var storeApiChained = ['addResource', 'addResources', 'addResourceBundle', 'removeResourceBundle'];\n      storeApiChained.forEach(function (fcName) {\n        _this2[fcName] = function () {\n          var _this2$store2;\n\n          (_this2$store2 = _this2.store)[fcName].apply(_this2$store2, arguments);\n\n          return _this2;\n        };\n      });\n      var deferred = defer();\n\n      var load = function load() {\n        var finish = function finish(err, t) {\n          if (_this2.isInitialized && !_this2.initializedStoreOnce) _this2.logger.warn('init: i18next is already initialized. You should call init just once!');\n          _this2.isInitialized = true;\n          if (!_this2.options.isClone) _this2.logger.log('initialized', _this2.options);\n\n          _this2.emit('initialized', _this2.options);\n\n          deferred.resolve(t);\n          callback(err, t);\n        };\n\n        if (_this2.languages && _this2.options.compatibilityAPI !== 'v1' && !_this2.isInitialized) return finish(null, _this2.t.bind(_this2));\n\n        _this2.changeLanguage(_this2.options.lng, finish);\n      };\n\n      if (this.options.resources || !this.options.initImmediate) {\n        load();\n      } else {\n        setTimeout(load, 0);\n      }\n\n      return deferred;\n    }\n  }, {\n    key: \"loadResources\",\n    value: function loadResources(language) {\n      var _this3 = this;\n\n      var callback = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : noop;\n      var usedCallback = callback;\n      var usedLng = typeof language === 'string' ? language : this.language;\n      if (typeof language === 'function') usedCallback = language;\n\n      if (!this.options.resources || this.options.partialBundledLanguages) {\n        if (usedLng && usedLng.toLowerCase() === 'cimode') return usedCallback();\n        var toLoad = [];\n\n        var append = function append(lng) {\n          if (!lng) return;\n\n          var lngs = _this3.services.languageUtils.toResolveHierarchy(lng);\n\n          lngs.forEach(function (l) {\n            if (toLoad.indexOf(l) < 0) toLoad.push(l);\n          });\n        };\n\n        if (!usedLng) {\n          var fallbacks = this.services.languageUtils.getFallbackCodes(this.options.fallbackLng);\n          fallbacks.forEach(function (l) {\n            return append(l);\n          });\n        } else {\n          append(usedLng);\n        }\n\n        if (this.options.preload) {\n          this.options.preload.forEach(function (l) {\n            return append(l);\n          });\n        }\n\n        this.services.backendConnector.load(toLoad, this.options.ns, usedCallback);\n      } else {\n        usedCallback(null);\n      }\n    }\n  }, {\n    key: \"reloadResources\",\n    value: function reloadResources(lngs, ns, callback) {\n      var deferred = defer();\n      if (!lngs) lngs = this.languages;\n      if (!ns) ns = this.options.ns;\n      if (!callback) callback = noop;\n      this.services.backendConnector.reload(lngs, ns, function (err) {\n        deferred.resolve();\n        callback(err);\n      });\n      return deferred;\n    }\n  }, {\n    key: \"use\",\n    value: function use(module) {\n      if (!module) throw new Error('You are passing an undefined module! Please check the object you are passing to i18next.use()');\n      if (!module.type) throw new Error('You are passing a wrong module! Please check the object you are passing to i18next.use()');\n\n      if (module.type === 'backend') {\n        this.modules.backend = module;\n      }\n\n      if (module.type === 'logger' || module.log && module.warn && module.error) {\n        this.modules.logger = module;\n      }\n\n      if (module.type === 'languageDetector') {\n        this.modules.languageDetector = module;\n      }\n\n      if (module.type === 'i18nFormat') {\n        this.modules.i18nFormat = module;\n      }\n\n      if (module.type === 'postProcessor') {\n        postProcessor.addPostProcessor(module);\n      }\n\n      if (module.type === '3rdParty') {\n        this.modules.external.push(module);\n      }\n\n      return this;\n    }\n  }, {\n    key: \"changeLanguage\",\n    value: function changeLanguage(lng, callback) {\n      var _this4 = this;\n\n      this.isLanguageChangingTo = lng;\n      var deferred = defer();\n      this.emit('languageChanging', lng);\n\n      var done = function done(err, l) {\n        if (l) {\n          _this4.language = l;\n          _this4.languages = _this4.services.languageUtils.toResolveHierarchy(l);\n\n          _this4.translator.changeLanguage(l);\n\n          _this4.isLanguageChangingTo = undefined;\n\n          _this4.emit('languageChanged', l);\n\n          _this4.logger.log('languageChanged', l);\n        } else {\n          _this4.isLanguageChangingTo = undefined;\n        }\n\n        deferred.resolve(function () {\n          return _this4.t.apply(_this4, arguments);\n        });\n        if (callback) callback(err, function () {\n          return _this4.t.apply(_this4, arguments);\n        });\n      };\n\n      var setLng = function setLng(lngs) {\n        if (!lng && !lngs && _this4.services.languageDetector) lngs = [];\n        var l = typeof lngs === 'string' ? lngs : _this4.services.languageUtils.getBestMatchFromCodes(lngs);\n\n        if (l) {\n          if (!_this4.language) {\n            _this4.language = l;\n            _this4.languages = _this4.services.languageUtils.toResolveHierarchy(l);\n          }\n\n          if (!_this4.translator.language) _this4.translator.changeLanguage(l);\n          if (_this4.services.languageDetector) _this4.services.languageDetector.cacheUserLanguage(l);\n        }\n\n        _this4.loadResources(l, function (err) {\n          done(err, l);\n        });\n      };\n\n      if (!lng && this.services.languageDetector && !this.services.languageDetector.async) {\n        setLng(this.services.languageDetector.detect());\n      } else if (!lng && this.services.languageDetector && this.services.languageDetector.async) {\n        this.services.languageDetector.detect(setLng);\n      } else {\n        setLng(lng);\n      }\n\n      return deferred;\n    }\n  }, {\n    key: \"getFixedT\",\n    value: function getFixedT(lng, ns) {\n      var _this5 = this;\n\n      var fixedT = function fixedT(key, opts) {\n        var options;\n\n        if ((0,_babel_runtime_helpers_esm_typeof__WEBPACK_IMPORTED_MODULE_0__.default)(opts) !== 'object') {\n          for (var _len3 = arguments.length, rest = new Array(_len3 > 2 ? _len3 - 2 : 0), _key3 = 2; _key3 < _len3; _key3++) {\n            rest[_key3 - 2] = arguments[_key3];\n          }\n\n          options = _this5.options.overloadTranslationOptionHandler([key, opts].concat(rest));\n        } else {\n          options = (0,_babel_runtime_helpers_esm_objectSpread__WEBPACK_IMPORTED_MODULE_1__.default)({}, opts);\n        }\n\n        options.lng = options.lng || fixedT.lng;\n        options.lngs = options.lngs || fixedT.lngs;\n        options.ns = options.ns || fixedT.ns;\n        return _this5.t(key, options);\n      };\n\n      if (typeof lng === 'string') {\n        fixedT.lng = lng;\n      } else {\n        fixedT.lngs = lng;\n      }\n\n      fixedT.ns = ns;\n      return fixedT;\n    }\n  }, {\n    key: \"t\",\n    value: function t() {\n      var _this$translator;\n\n      return this.translator && (_this$translator = this.translator).translate.apply(_this$translator, arguments);\n    }\n  }, {\n    key: \"exists\",\n    value: function exists() {\n      var _this$translator2;\n\n      return this.translator && (_this$translator2 = this.translator).exists.apply(_this$translator2, arguments);\n    }\n  }, {\n    key: \"setDefaultNamespace\",\n    value: function setDefaultNamespace(ns) {\n      this.options.defaultNS = ns;\n    }\n  }, {\n    key: \"hasLoadedNamespace\",\n    value: function hasLoadedNamespace(ns) {\n      var _this6 = this;\n\n      var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n\n      if (!this.isInitialized) {\n        this.logger.warn('hasLoadedNamespace: i18next was not initialized', this.languages);\n        return false;\n      }\n\n      if (!this.languages || !this.languages.length) {\n        this.logger.warn('hasLoadedNamespace: i18n.languages were undefined or empty', this.languages);\n        return false;\n      }\n\n      var lng = this.languages[0];\n      var fallbackLng = this.options ? this.options.fallbackLng : false;\n      var lastLng = this.languages[this.languages.length - 1];\n      if (lng.toLowerCase() === 'cimode') return true;\n\n      var loadNotPending = function loadNotPending(l, n) {\n        var loadState = _this6.services.backendConnector.state[\"\".concat(l, \"|\").concat(n)];\n\n        return loadState === -1 || loadState === 2;\n      };\n\n      if (options.precheck) {\n        var preResult = options.precheck(this, loadNotPending);\n        if (preResult !== undefined) return preResult;\n      }\n\n      if (this.hasResourceBundle(lng, ns)) return true;\n      if (!this.services.backendConnector.backend) return true;\n      if (loadNotPending(lng, ns) && (!fallbackLng || loadNotPending(lastLng, ns))) return true;\n      return false;\n    }\n  }, {\n    key: \"loadNamespaces\",\n    value: function loadNamespaces(ns, callback) {\n      var _this7 = this;\n\n      var deferred = defer();\n\n      if (!this.options.ns) {\n        callback && callback();\n        return Promise.resolve();\n      }\n\n      if (typeof ns === 'string') ns = [ns];\n      ns.forEach(function (n) {\n        if (_this7.options.ns.indexOf(n) < 0) _this7.options.ns.push(n);\n      });\n      this.loadResources(function (err) {\n        deferred.resolve();\n        if (callback) callback(err);\n      });\n      return deferred;\n    }\n  }, {\n    key: \"loadLanguages\",\n    value: function loadLanguages(lngs, callback) {\n      var deferred = defer();\n      if (typeof lngs === 'string') lngs = [lngs];\n      var preloaded = this.options.preload || [];\n      var newLngs = lngs.filter(function (lng) {\n        return preloaded.indexOf(lng) < 0;\n      });\n\n      if (!newLngs.length) {\n        if (callback) callback();\n        return Promise.resolve();\n      }\n\n      this.options.preload = preloaded.concat(newLngs);\n      this.loadResources(function (err) {\n        deferred.resolve();\n        if (callback) callback(err);\n      });\n      return deferred;\n    }\n  }, {\n    key: \"dir\",\n    value: function dir(lng) {\n      if (!lng) lng = this.languages && this.languages.length > 0 ? this.languages[0] : this.language;\n      if (!lng) return 'rtl';\n      var rtlLngs = ['ar', 'shu', 'sqr', 'ssh', 'xaa', 'yhd', 'yud', 'aao', 'abh', 'abv', 'acm', 'acq', 'acw', 'acx', 'acy', 'adf', 'ads', 'aeb', 'aec', 'afb', 'ajp', 'apc', 'apd', 'arb', 'arq', 'ars', 'ary', 'arz', 'auz', 'avl', 'ayh', 'ayl', 'ayn', 'ayp', 'bbz', 'pga', 'he', 'iw', 'ps', 'pbt', 'pbu', 'pst', 'prp', 'prd', 'ug', 'ur', 'ydd', 'yds', 'yih', 'ji', 'yi', 'hbo', 'men', 'xmn', 'fa', 'jpr', 'peo', 'pes', 'prs', 'dv', 'sam'];\n      return rtlLngs.indexOf(this.services.languageUtils.getLanguagePartFromCode(lng)) >= 0 ? 'rtl' : 'ltr';\n    }\n  }, {\n    key: \"createInstance\",\n    value: function createInstance() {\n      var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n      var callback = arguments.length > 1 ? arguments[1] : undefined;\n      return new I18n(options, callback);\n    }\n  }, {\n    key: \"cloneInstance\",\n    value: function cloneInstance() {\n      var _this8 = this;\n\n      var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n      var callback = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : noop;\n\n      var mergedOptions = (0,_babel_runtime_helpers_esm_objectSpread__WEBPACK_IMPORTED_MODULE_1__.default)({}, this.options, options, {\n        isClone: true\n      });\n\n      var clone = new I18n(mergedOptions);\n      var membersToCopy = ['store', 'services', 'language'];\n      membersToCopy.forEach(function (m) {\n        clone[m] = _this8[m];\n      });\n      clone.services = (0,_babel_runtime_helpers_esm_objectSpread__WEBPACK_IMPORTED_MODULE_1__.default)({}, this.services);\n      clone.services.utils = {\n        hasLoadedNamespace: clone.hasLoadedNamespace.bind(clone)\n      };\n      clone.translator = new Translator(clone.services, clone.options);\n      clone.translator.on('*', function (event) {\n        for (var _len4 = arguments.length, args = new Array(_len4 > 1 ? _len4 - 1 : 0), _key4 = 1; _key4 < _len4; _key4++) {\n          args[_key4 - 1] = arguments[_key4];\n        }\n\n        clone.emit.apply(clone, [event].concat(args));\n      });\n      clone.init(mergedOptions, callback);\n      clone.translator.options = clone.options;\n      clone.translator.backendConnector.services.utils = {\n        hasLoadedNamespace: clone.hasLoadedNamespace.bind(clone)\n      };\n      return clone;\n    }\n  }, {\n    key: \"toJSON\",\n    value: function toJSON() {\n      return {\n        options: this.options,\n        store: this.store,\n        language: this.language,\n        languages: this.languages\n      };\n    }\n  }]);\n\n  return I18n;\n}(EventEmitter);\n\nvar i18next = new I18n();\n\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (i18next);\n\n\n//# sourceURL=webpack://brackets-viewer/./node_modules/i18next/dist/esm/i18next.js?");

/***/ }),

/***/ "./node_modules/inherits/inherits_browser.js":
/*!***************************************************!*\
  !*** ./node_modules/inherits/inherits_browser.js ***!
  \***************************************************/
/***/ ((module) => {

eval("if (typeof Object.create === 'function') {\n  // implementation from standard node.js 'util' module\n  module.exports = function inherits(ctor, superCtor) {\n    if (superCtor) {\n      ctor.super_ = superCtor\n      ctor.prototype = Object.create(superCtor.prototype, {\n        constructor: {\n          value: ctor,\n          enumerable: false,\n          writable: true,\n          configurable: true\n        }\n      })\n    }\n  };\n} else {\n  // old school shim for old browsers\n  module.exports = function inherits(ctor, superCtor) {\n    if (superCtor) {\n      ctor.super_ = superCtor\n      var TempCtor = function () {}\n      TempCtor.prototype = superCtor.prototype\n      ctor.prototype = new TempCtor()\n      ctor.prototype.constructor = ctor\n    }\n  }\n}\n\n\n//# sourceURL=webpack://brackets-viewer/./node_modules/inherits/inherits_browser.js?");

/***/ }),

/***/ "./node_modules/is-arguments/index.js":
/*!********************************************!*\
  !*** ./node_modules/is-arguments/index.js ***!
  \********************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("\n\nvar hasToStringTag = __webpack_require__(/*! has-tostringtag/shams */ \"./node_modules/has-tostringtag/shams.js\")();\nvar callBound = __webpack_require__(/*! call-bind/callBound */ \"./node_modules/call-bind/callBound.js\");\n\nvar $toString = callBound('Object.prototype.toString');\n\nvar isStandardArguments = function isArguments(value) {\n\tif (hasToStringTag && value && typeof value === 'object' && Symbol.toStringTag in value) {\n\t\treturn false;\n\t}\n\treturn $toString(value) === '[object Arguments]';\n};\n\nvar isLegacyArguments = function isArguments(value) {\n\tif (isStandardArguments(value)) {\n\t\treturn true;\n\t}\n\treturn value !== null &&\n\t\ttypeof value === 'object' &&\n\t\ttypeof value.length === 'number' &&\n\t\tvalue.length >= 0 &&\n\t\t$toString(value) !== '[object Array]' &&\n\t\t$toString(value.callee) === '[object Function]';\n};\n\nvar supportsStandardArguments = (function () {\n\treturn isStandardArguments(arguments);\n}());\n\nisStandardArguments.isLegacyArguments = isLegacyArguments; // for tests\n\nmodule.exports = supportsStandardArguments ? isStandardArguments : isLegacyArguments;\n\n\n//# sourceURL=webpack://brackets-viewer/./node_modules/is-arguments/index.js?");

/***/ }),

/***/ "./node_modules/is-generator-function/index.js":
/*!*****************************************************!*\
  !*** ./node_modules/is-generator-function/index.js ***!
  \*****************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("\n\nvar toStr = Object.prototype.toString;\nvar fnToStr = Function.prototype.toString;\nvar isFnRegex = /^\\s*(?:function)?\\*/;\nvar hasToStringTag = __webpack_require__(/*! has-tostringtag/shams */ \"./node_modules/has-tostringtag/shams.js\")();\nvar getProto = Object.getPrototypeOf;\nvar getGeneratorFunc = function () { // eslint-disable-line consistent-return\n\tif (!hasToStringTag) {\n\t\treturn false;\n\t}\n\ttry {\n\t\treturn Function('return function*() {}')();\n\t} catch (e) {\n\t}\n};\nvar GeneratorFunction;\n\nmodule.exports = function isGeneratorFunction(fn) {\n\tif (typeof fn !== 'function') {\n\t\treturn false;\n\t}\n\tif (isFnRegex.test(fnToStr.call(fn))) {\n\t\treturn true;\n\t}\n\tif (!hasToStringTag) {\n\t\tvar str = toStr.call(fn);\n\t\treturn str === '[object GeneratorFunction]';\n\t}\n\tif (!getProto) {\n\t\treturn false;\n\t}\n\tif (typeof GeneratorFunction === 'undefined') {\n\t\tvar generatorFunc = getGeneratorFunc();\n\t\tGeneratorFunction = generatorFunc ? getProto(generatorFunc) : false;\n\t}\n\treturn getProto(fn) === GeneratorFunction;\n};\n\n\n//# sourceURL=webpack://brackets-viewer/./node_modules/is-generator-function/index.js?");

/***/ }),

/***/ "./node_modules/is-typed-array/index.js":
/*!**********************************************!*\
  !*** ./node_modules/is-typed-array/index.js ***!
  \**********************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("\n\nvar forEach = __webpack_require__(/*! foreach */ \"./node_modules/foreach/index.js\");\nvar availableTypedArrays = __webpack_require__(/*! available-typed-arrays */ \"./node_modules/available-typed-arrays/index.js\");\nvar callBound = __webpack_require__(/*! call-bind/callBound */ \"./node_modules/call-bind/callBound.js\");\n\nvar $toString = callBound('Object.prototype.toString');\nvar hasToStringTag = __webpack_require__(/*! has-tostringtag/shams */ \"./node_modules/has-tostringtag/shams.js\")();\n\nvar typedArrays = availableTypedArrays();\n\nvar $indexOf = callBound('Array.prototype.indexOf', true) || function indexOf(array, value) {\n\tfor (var i = 0; i < array.length; i += 1) {\n\t\tif (array[i] === value) {\n\t\t\treturn i;\n\t\t}\n\t}\n\treturn -1;\n};\nvar $slice = callBound('String.prototype.slice');\nvar toStrTags = {};\nvar gOPD = __webpack_require__(/*! es-abstract/helpers/getOwnPropertyDescriptor */ \"./node_modules/es-abstract/helpers/getOwnPropertyDescriptor.js\");\nvar getPrototypeOf = Object.getPrototypeOf; // require('getprototypeof');\nif (hasToStringTag && gOPD && getPrototypeOf) {\n\tforEach(typedArrays, function (typedArray) {\n\t\tvar arr = new __webpack_require__.g[typedArray]();\n\t\tif (Symbol.toStringTag in arr) {\n\t\t\tvar proto = getPrototypeOf(arr);\n\t\t\tvar descriptor = gOPD(proto, Symbol.toStringTag);\n\t\t\tif (!descriptor) {\n\t\t\t\tvar superProto = getPrototypeOf(proto);\n\t\t\t\tdescriptor = gOPD(superProto, Symbol.toStringTag);\n\t\t\t}\n\t\t\ttoStrTags[typedArray] = descriptor.get;\n\t\t}\n\t});\n}\n\nvar tryTypedArrays = function tryAllTypedArrays(value) {\n\tvar anyTrue = false;\n\tforEach(toStrTags, function (getter, typedArray) {\n\t\tif (!anyTrue) {\n\t\t\ttry {\n\t\t\t\tanyTrue = getter.call(value) === typedArray;\n\t\t\t} catch (e) { /**/ }\n\t\t}\n\t});\n\treturn anyTrue;\n};\n\nmodule.exports = function isTypedArray(value) {\n\tif (!value || typeof value !== 'object') { return false; }\n\tif (!hasToStringTag || !(Symbol.toStringTag in value)) {\n\t\tvar tag = $slice($toString(value), 8, -1);\n\t\treturn $indexOf(typedArrays, tag) > -1;\n\t}\n\tif (!gOPD) { return false; }\n\treturn tryTypedArrays(value);\n};\n\n\n//# sourceURL=webpack://brackets-viewer/./node_modules/is-typed-array/index.js?");

/***/ }),

/***/ "./src/viewer/style.scss":
/*!*******************************!*\
  !*** ./src/viewer/style.scss ***!
  \*******************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n// extracted by mini-css-extract-plugin\n\n\n//# sourceURL=webpack://brackets-viewer/./src/viewer/style.scss?");

/***/ }),

/***/ "./node_modules/mkdirp/index.js":
/*!**************************************!*\
  !*** ./node_modules/mkdirp/index.js ***!
  \**************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("const optsArg = __webpack_require__(/*! ./lib/opts-arg.js */ \"./node_modules/mkdirp/lib/opts-arg.js\")\nconst pathArg = __webpack_require__(/*! ./lib/path-arg.js */ \"./node_modules/mkdirp/lib/path-arg.js\")\n\nconst {mkdirpNative, mkdirpNativeSync} = __webpack_require__(/*! ./lib/mkdirp-native.js */ \"./node_modules/mkdirp/lib/mkdirp-native.js\")\nconst {mkdirpManual, mkdirpManualSync} = __webpack_require__(/*! ./lib/mkdirp-manual.js */ \"./node_modules/mkdirp/lib/mkdirp-manual.js\")\nconst {useNative, useNativeSync} = __webpack_require__(/*! ./lib/use-native.js */ \"./node_modules/mkdirp/lib/use-native.js\")\n\n\nconst mkdirp = (path, opts) => {\n  path = pathArg(path)\n  opts = optsArg(opts)\n  return useNative(opts)\n    ? mkdirpNative(path, opts)\n    : mkdirpManual(path, opts)\n}\n\nconst mkdirpSync = (path, opts) => {\n  path = pathArg(path)\n  opts = optsArg(opts)\n  return useNativeSync(opts)\n    ? mkdirpNativeSync(path, opts)\n    : mkdirpManualSync(path, opts)\n}\n\nmkdirp.sync = mkdirpSync\nmkdirp.native = (path, opts) => mkdirpNative(pathArg(path), optsArg(opts))\nmkdirp.manual = (path, opts) => mkdirpManual(pathArg(path), optsArg(opts))\nmkdirp.nativeSync = (path, opts) => mkdirpNativeSync(pathArg(path), optsArg(opts))\nmkdirp.manualSync = (path, opts) => mkdirpManualSync(pathArg(path), optsArg(opts))\n\nmodule.exports = mkdirp\n\n\n//# sourceURL=webpack://brackets-viewer/./node_modules/mkdirp/index.js?");

/***/ }),

/***/ "./node_modules/mkdirp/lib/find-made.js":
/*!**********************************************!*\
  !*** ./node_modules/mkdirp/lib/find-made.js ***!
  \**********************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("const {dirname} = __webpack_require__(/*! path */ \"./node_modules/path-browserify/index.js\")\n\nconst findMade = (opts, parent, path = undefined) => {\n  // we never want the 'made' return value to be a root directory\n  if (path === parent)\n    return Promise.resolve()\n\n  return opts.statAsync(parent).then(\n    st => st.isDirectory() ? path : undefined, // will fail later\n    er => er.code === 'ENOENT'\n      ? findMade(opts, dirname(parent), parent)\n      : undefined\n  )\n}\n\nconst findMadeSync = (opts, parent, path = undefined) => {\n  if (path === parent)\n    return undefined\n\n  try {\n    return opts.statSync(parent).isDirectory() ? path : undefined\n  } catch (er) {\n    return er.code === 'ENOENT'\n      ? findMadeSync(opts, dirname(parent), parent)\n      : undefined\n  }\n}\n\nmodule.exports = {findMade, findMadeSync}\n\n\n//# sourceURL=webpack://brackets-viewer/./node_modules/mkdirp/lib/find-made.js?");

/***/ }),

/***/ "./node_modules/mkdirp/lib/mkdirp-manual.js":
/*!**************************************************!*\
  !*** ./node_modules/mkdirp/lib/mkdirp-manual.js ***!
  \**************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("const {dirname} = __webpack_require__(/*! path */ \"./node_modules/path-browserify/index.js\")\n\nconst mkdirpManual = (path, opts, made) => {\n  opts.recursive = false\n  const parent = dirname(path)\n  if (parent === path) {\n    return opts.mkdirAsync(path, opts).catch(er => {\n      // swallowed by recursive implementation on posix systems\n      // any other error is a failure\n      if (er.code !== 'EISDIR')\n        throw er\n    })\n  }\n\n  return opts.mkdirAsync(path, opts).then(() => made || path, er => {\n    if (er.code === 'ENOENT')\n      return mkdirpManual(parent, opts)\n        .then(made => mkdirpManual(path, opts, made))\n    if (er.code !== 'EEXIST' && er.code !== 'EROFS')\n      throw er\n    return opts.statAsync(path).then(st => {\n      if (st.isDirectory())\n        return made\n      else\n        throw er\n    }, () => { throw er })\n  })\n}\n\nconst mkdirpManualSync = (path, opts, made) => {\n  const parent = dirname(path)\n  opts.recursive = false\n\n  if (parent === path) {\n    try {\n      return opts.mkdirSync(path, opts)\n    } catch (er) {\n      // swallowed by recursive implementation on posix systems\n      // any other error is a failure\n      if (er.code !== 'EISDIR')\n        throw er\n      else\n        return\n    }\n  }\n\n  try {\n    opts.mkdirSync(path, opts)\n    return made || path\n  } catch (er) {\n    if (er.code === 'ENOENT')\n      return mkdirpManualSync(path, opts, mkdirpManualSync(parent, opts, made))\n    if (er.code !== 'EEXIST' && er.code !== 'EROFS')\n      throw er\n    try {\n      if (!opts.statSync(path).isDirectory())\n        throw er\n    } catch (_) {\n      throw er\n    }\n  }\n}\n\nmodule.exports = {mkdirpManual, mkdirpManualSync}\n\n\n//# sourceURL=webpack://brackets-viewer/./node_modules/mkdirp/lib/mkdirp-manual.js?");

/***/ }),

/***/ "./node_modules/mkdirp/lib/mkdirp-native.js":
/*!**************************************************!*\
  !*** ./node_modules/mkdirp/lib/mkdirp-native.js ***!
  \**************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("const {dirname} = __webpack_require__(/*! path */ \"./node_modules/path-browserify/index.js\")\nconst {findMade, findMadeSync} = __webpack_require__(/*! ./find-made.js */ \"./node_modules/mkdirp/lib/find-made.js\")\nconst {mkdirpManual, mkdirpManualSync} = __webpack_require__(/*! ./mkdirp-manual.js */ \"./node_modules/mkdirp/lib/mkdirp-manual.js\")\n\nconst mkdirpNative = (path, opts) => {\n  opts.recursive = true\n  const parent = dirname(path)\n  if (parent === path)\n    return opts.mkdirAsync(path, opts)\n\n  return findMade(opts, path).then(made =>\n    opts.mkdirAsync(path, opts).then(() => made)\n    .catch(er => {\n      if (er.code === 'ENOENT')\n        return mkdirpManual(path, opts)\n      else\n        throw er\n    }))\n}\n\nconst mkdirpNativeSync = (path, opts) => {\n  opts.recursive = true\n  const parent = dirname(path)\n  if (parent === path)\n    return opts.mkdirSync(path, opts)\n\n  const made = findMadeSync(opts, path)\n  try {\n    opts.mkdirSync(path, opts)\n    return made\n  } catch (er) {\n    if (er.code === 'ENOENT')\n      return mkdirpManualSync(path, opts)\n    else\n      throw er\n  }\n}\n\nmodule.exports = {mkdirpNative, mkdirpNativeSync}\n\n\n//# sourceURL=webpack://brackets-viewer/./node_modules/mkdirp/lib/mkdirp-native.js?");

/***/ }),

/***/ "./node_modules/mkdirp/lib/opts-arg.js":
/*!*********************************************!*\
  !*** ./node_modules/mkdirp/lib/opts-arg.js ***!
  \*********************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("const { promisify } = __webpack_require__(/*! util */ \"./node_modules/util/util.js\")\nconst fs = __webpack_require__(/*! fs */ \"?c311\")\nconst optsArg = opts => {\n  if (!opts)\n    opts = { mode: 0o777, fs }\n  else if (typeof opts === 'object')\n    opts = { mode: 0o777, fs, ...opts }\n  else if (typeof opts === 'number')\n    opts = { mode: opts, fs }\n  else if (typeof opts === 'string')\n    opts = { mode: parseInt(opts, 8), fs }\n  else\n    throw new TypeError('invalid options argument')\n\n  opts.mkdir = opts.mkdir || opts.fs.mkdir || fs.mkdir\n  opts.mkdirAsync = promisify(opts.mkdir)\n  opts.stat = opts.stat || opts.fs.stat || fs.stat\n  opts.statAsync = promisify(opts.stat)\n  opts.statSync = opts.statSync || opts.fs.statSync || fs.statSync\n  opts.mkdirSync = opts.mkdirSync || opts.fs.mkdirSync || fs.mkdirSync\n  return opts\n}\nmodule.exports = optsArg\n\n\n//# sourceURL=webpack://brackets-viewer/./node_modules/mkdirp/lib/opts-arg.js?");

/***/ }),

/***/ "./node_modules/mkdirp/lib/path-arg.js":
/*!*********************************************!*\
  !*** ./node_modules/mkdirp/lib/path-arg.js ***!
  \*********************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("/* provided dependency */ var process = __webpack_require__(/*! process/browser */ \"./node_modules/process/browser.js\");\nconst platform = process.env.__TESTING_MKDIRP_PLATFORM__ || process.platform\nconst { resolve, parse } = __webpack_require__(/*! path */ \"./node_modules/path-browserify/index.js\")\nconst pathArg = path => {\n  if (/\\0/.test(path)) {\n    // simulate same failure that node raises\n    throw Object.assign(\n      new TypeError('path must be a string without null bytes'),\n      {\n        path,\n        code: 'ERR_INVALID_ARG_VALUE',\n      }\n    )\n  }\n\n  path = resolve(path)\n  if (platform === 'win32') {\n    const badWinChars = /[*|\"<>?:]/\n    const {root} = parse(path)\n    if (badWinChars.test(path.substr(root.length))) {\n      throw Object.assign(new Error('Illegal characters in path.'), {\n        path,\n        code: 'EINVAL',\n      })\n    }\n  }\n\n  return path\n}\nmodule.exports = pathArg\n\n\n//# sourceURL=webpack://brackets-viewer/./node_modules/mkdirp/lib/path-arg.js?");

/***/ }),

/***/ "./node_modules/mkdirp/lib/use-native.js":
/*!***********************************************!*\
  !*** ./node_modules/mkdirp/lib/use-native.js ***!
  \***********************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("/* provided dependency */ var process = __webpack_require__(/*! process/browser */ \"./node_modules/process/browser.js\");\nconst fs = __webpack_require__(/*! fs */ \"?c311\")\n\nconst version = process.env.__TESTING_MKDIRP_NODE_VERSION__ || process.version\nconst versArr = version.replace(/^v/, '').split('.')\nconst hasNative = +versArr[0] > 10 || +versArr[0] === 10 && +versArr[1] >= 12\n\nconst useNative = !hasNative ? () => false : opts => opts.mkdir === fs.mkdir\nconst useNativeSync = !hasNative ? () => false : opts => opts.mkdirSync === fs.mkdirSync\n\nmodule.exports = {useNative, useNativeSync}\n\n\n//# sourceURL=webpack://brackets-viewer/./node_modules/mkdirp/lib/use-native.js?");

/***/ }),

/***/ "./node_modules/node-json-db/dist/JsonDB.js":
/*!**************************************************!*\
  !*** ./node_modules/node-json-db/dist/JsonDB.js ***!
  \**************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.JsonDB = void 0;\nconst Utils_1 = __webpack_require__(/*! ./lib/Utils */ \"./node_modules/node-json-db/dist/lib/Utils.js\");\nconst FS = __webpack_require__(/*! fs */ \"?daec\");\nconst path = __webpack_require__(/*! path */ \"./node_modules/path-browserify/index.js\");\nconst mkdirp = __webpack_require__(/*! mkdirp */ \"./node_modules/mkdirp/index.js\");\nconst Errors_1 = __webpack_require__(/*! ./lib/Errors */ \"./node_modules/node-json-db/dist/lib/Errors.js\");\nconst DBParentData_1 = __webpack_require__(/*! ./lib/DBParentData */ \"./node_modules/node-json-db/dist/lib/DBParentData.js\");\nconst ArrayInfo_1 = __webpack_require__(/*! ./lib/ArrayInfo */ \"./node_modules/node-json-db/dist/lib/ArrayInfo.js\");\nconst JsonDBConfig_1 = __webpack_require__(/*! ./lib/JsonDBConfig */ \"./node_modules/node-json-db/dist/lib/JsonDBConfig.js\");\nclass JsonDB {\n    /**\n     * JSONDB Constructor\n     * @param filename where to save the \"DB\". Can also be used to give the whole configuration\n     * @param saveOnPush save the database at each push command into the json file\n     * @param humanReadable the JSON file will be readable easily by a human\n     * @param separator what to use as separator\n     */\n    constructor(filename, saveOnPush = true, humanReadable = false, separator = '/') {\n        this.loaded = false;\n        this.data = {};\n        if (filename instanceof JsonDBConfig_1.Config) {\n            this.config = filename;\n        }\n        else {\n            this.config = new JsonDBConfig_1.Config(filename, saveOnPush, humanReadable, separator);\n        }\n        if (!FS.existsSync(this.config.filename)) {\n            const dirname = path.dirname(this.config.filename);\n            mkdirp.sync(dirname);\n            this.save(true);\n            this.loaded = true;\n        }\n    }\n    /**\n     * Process datapath into different parts\n     * @param dataPath\n     */\n    processDataPath(dataPath) {\n        if (dataPath === undefined || !dataPath.trim()) {\n            throw new Errors_1.DataError(\"The Data Path can't be empty\", 6);\n        }\n        if (dataPath == this.config.separator) {\n            return [];\n        }\n        dataPath = Utils_1.removeTrailingChar(dataPath, this.config.separator);\n        const path = dataPath.split(this.config.separator);\n        path.shift();\n        return path;\n    }\n    retrieveData(dataPath, create = false) {\n        this.load();\n        const thisDb = this;\n        const recursiveProcessDataPath = (data, index) => {\n            let property = dataPath[index];\n            /**\n             * Find the wanted Data or create it.\n             */\n            function findData(isArray = false) {\n                if (data.hasOwnProperty(property)) {\n                    data = data[property];\n                }\n                else if (create) {\n                    if (isArray) {\n                        data[property] = [];\n                    }\n                    else {\n                        data[property] = {};\n                    }\n                    data = data[property];\n                }\n                else {\n                    throw new Errors_1.DataError(`Can't find dataPath: ${thisDb.config.separator}${dataPath.join(thisDb.config.separator)}. Stopped at ${property}`, 5);\n                }\n            }\n            const arrayInfo = ArrayInfo_1.ArrayInfo.processArray(property);\n            if (arrayInfo) {\n                property = arrayInfo.property;\n                findData(true);\n                if (!Array.isArray(data)) {\n                    throw new Errors_1.DataError(`DataPath: ${thisDb.config.separator}${dataPath.join(thisDb.config.separator)}. ${property} is not an array.`, 11);\n                }\n                const arrayIndex = arrayInfo.getIndex(data, true);\n                if (!arrayInfo.append && data.hasOwnProperty(arrayIndex)) {\n                    data = data[arrayIndex];\n                }\n                else if (create) {\n                    if (arrayInfo.append) {\n                        data.push({});\n                        data = data[data.length - 1];\n                    }\n                    else {\n                        data[arrayIndex] = {};\n                        data = data[arrayIndex];\n                    }\n                }\n                else {\n                    throw new Errors_1.DataError(`DataPath: ${thisDb.config.separator}${dataPath.join(thisDb.config.separator)}. . Can't find index ${arrayInfo.index} in array ${property}`, 10);\n                }\n            }\n            else {\n                findData();\n            }\n            if (dataPath.length == ++index) {\n                return data;\n            }\n            return recursiveProcessDataPath(data, index);\n        };\n        if (dataPath.length === 0) {\n            return this.data;\n        }\n        return recursiveProcessDataPath(this.data, 0);\n    }\n    getParentData(dataPath, create) {\n        const path = this.processDataPath(dataPath);\n        const last = path.pop();\n        return new DBParentData_1.DBParentData(this.retrieveData(path, create), this, dataPath, last);\n    }\n    /**\n     * Get the wanted data\n     * @param dataPath path of the data to retrieve\n     */\n    getData(dataPath) {\n        const path = this.processDataPath(dataPath);\n        return this.retrieveData(path, false);\n    }\n    /**\n     * Same as getData only here it's directly typed to your object\n     * @param dataPath  path of the data to retrieve\n     */\n    getObject(dataPath) {\n        return this.getData(dataPath);\n    }\n    /**\n     * Check for existing datapath\n     * @param dataPath\n     */\n    exists(dataPath) {\n        try {\n            this.getData(dataPath);\n            return true;\n        }\n        catch (e) {\n            if (e instanceof Errors_1.DataError) {\n                return false;\n            }\n            throw e;\n        }\n    }\n    /**\n     * Returns the number of element which constitutes the array\n     * @param dataPath\n     */\n    count(dataPath) {\n        const result = this.getData(dataPath);\n        if (!Array.isArray(result)) {\n            throw new Errors_1.DataError(`DataPath: ${dataPath} is not an array.`, 11);\n        }\n        const path = this.processDataPath(dataPath);\n        const data = this.retrieveData(path, false);\n        return data.length;\n    }\n    /**\n     * Returns the index of the object that meets the criteria submitted.\n     * @param dataPath  base dataPath from where to start searching\n     * @param searchValue value to look for in the dataPath\n     * @param propertyName name of the property to look for searchValue\n     */\n    getIndex(dataPath, searchValue, propertyName = 'id') {\n        const result = this.getData(dataPath);\n        if (!Array.isArray(result)) {\n            throw new Errors_1.DataError(`DataPath: ${dataPath} is not an array.`, 11);\n        }\n        const path = this.processDataPath(dataPath);\n        const data = this.retrieveData(path, false);\n        return data.map(function (element) { return element[propertyName]; }).indexOf(searchValue);\n    }\n    /**\n     * Find all specific entry in an array/object\n     * @param rootPath base dataPath from where to start searching\n     * @param callback method to filter the result and find the wanted entry. Receive the entry and it's index.\n     */\n    filter(rootPath, callback) {\n        const result = this.getData(rootPath);\n        if (Array.isArray(result)) {\n            return result.filter(callback);\n        }\n        if (result instanceof Object) {\n            const entries = Object.entries(result);\n            const found = entries.filter((entry) => {\n                return callback(entry[1], entry[0]);\n            });\n            if (!found || found.length < 1) {\n                return undefined;\n            }\n            return found.map((entry) => {\n                return entry[1];\n            });\n        }\n        throw new Errors_1.DataError(\"The entry at the path (\" + rootPath + \") needs to be either an Object or an Array\", 12);\n    }\n    /**\n     * Find a specific entry in an array/object\n     * @param rootPath base dataPath from where to start searching\n     * @param callback method to filter the result and find the wanted entry. Receive the entry and it's index.\n     */\n    find(rootPath, callback) {\n        const result = this.getData(rootPath);\n        if (Array.isArray(result)) {\n            return result.find(callback);\n        }\n        if (result instanceof Object) {\n            const entries = Object.entries(result);\n            const found = entries.find((entry) => {\n                return callback(entry[1], entry[0]);\n            });\n            if (!found || found.length < 2) {\n                return undefined;\n            }\n            return found[1];\n        }\n        throw new Errors_1.DataError(\"The entry at the path (\" + rootPath + \") needs to be either an Object or an Array\", 12);\n    }\n    /**\n     * Pushing data into the database\n     * @param dataPath path leading to the data\n     * @param data data to push\n     * @param override overriding or not the data, if not, it will merge them\n     */\n    push(dataPath, data, override = true) {\n        const dbData = this.getParentData(dataPath, true);\n        if (!dbData) {\n            throw new Error(\"Data not found\");\n        }\n        let toSet = data;\n        if (!override) {\n            if (Array.isArray(data)) {\n                let storedData = dbData.getData();\n                if (storedData === undefined) {\n                    storedData = [];\n                }\n                else if (!Array.isArray(storedData)) {\n                    throw new Errors_1.DataError(\"Can't merge another type of data with an Array\", 3);\n                }\n                toSet = storedData.concat(data);\n            }\n            else if (data === Object(data)) {\n                if (Array.isArray(dbData.getData())) {\n                    throw new Errors_1.DataError(\"Can't merge an Array with an Object\", 4);\n                }\n                toSet = Utils_1.merge(dbData.getData(), data);\n            }\n        }\n        dbData.setData(toSet);\n        if (this.config.saveOnPush) {\n            this.save();\n        }\n    }\n    /**\n     * Delete the data\n     * @param dataPath path leading to the data\n     */\n    delete(dataPath) {\n        const dbData = this.getParentData(dataPath, true);\n        if (!dbData) {\n            return;\n        }\n        dbData.delete();\n        if (this.config.saveOnPush) {\n            this.save();\n        }\n    }\n    /**\n     * Only use this if you know what you're doing.\n     * It reset the full data of the database.\n     * @param data\n     */\n    resetData(data) {\n        this.data = data;\n    }\n    /**\n     * Reload the database from the file\n     */\n    reload() {\n        this.loaded = false;\n        this.load();\n    }\n    ;\n    /**\n     * Manually load the database\n     * It is automatically called when the first getData is done\n     */\n    load() {\n        if (this.loaded) {\n            return;\n        }\n        try {\n            const data = FS.readFileSync(this.config.filename, 'utf8');\n            this.data = JSON.parse(data);\n            this.loaded = true;\n        }\n        catch (err) {\n            const error = new Errors_1.DatabaseError(\"Can't Load Database\", 1, err);\n            throw error;\n        }\n    }\n    /**\n     * Manually save the database\n     * By default you can't save the database if it's not loaded\n     * @param force force the save of the database\n     */\n    save(force) {\n        force = force || false;\n        if (!force && !this.loaded) {\n            throw new Errors_1.DatabaseError(\"DataBase not loaded. Can't write\", 7);\n        }\n        let data = \"\";\n        try {\n            if (this.config.humanReadable) {\n                data = JSON.stringify(this.data, null, 4);\n            }\n            else {\n                data = JSON.stringify(this.data);\n            }\n            FS.writeFileSync(this.config.filename, data, 'utf8');\n        }\n        catch (err) {\n            const error = new Errors_1.DatabaseError(\"Can't save the database\", 2, err);\n            throw error;\n        }\n    }\n}\nexports.JsonDB = JsonDB;\n//# sourceMappingURL=JsonDB.js.map\n\n//# sourceURL=webpack://brackets-viewer/./node_modules/node-json-db/dist/JsonDB.js?");

/***/ }),

/***/ "./node_modules/node-json-db/dist/lib/ArrayInfo.js":
/*!*********************************************************!*\
  !*** ./node_modules/node-json-db/dist/lib/ArrayInfo.js ***!
  \*********************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.ArrayInfo = exports.arrayRegex = void 0;\nconst Errors_1 = __webpack_require__(/*! ./Errors */ \"./node_modules/node-json-db/dist/lib/Errors.js\");\nfunction isInt(value) {\n    return !isNaN(value) &&\n        Number(value) == value && !isNaN(parseInt(value, 10));\n}\nconst arrayRegex = () => /^([\\.0-9a-zA-Z_$\\-][0-9a-zA-Z_\\-$\\.]*)\\[((?!(\\]|\\[)).*|)\\]$/gm;\nexports.arrayRegex = arrayRegex;\nconst regexCache = {};\nclass ArrayInfo {\n    constructor(property, index) {\n        this.index = 0;\n        this.append = false;\n        this.property = property;\n        this.append = index === \"\";\n        if (isInt(index)) {\n            this.index = parseInt(index);\n        }\n        else if (!this.append) {\n            throw new Errors_1.DataError(\"Only numerical values accepted for array index\", 200);\n        }\n    }\n    /**\n     * Check if the property want to access an Array\n     * @param property\n     */\n    static processArray(property) {\n        if (typeof property === 'undefined') {\n            return null;\n        }\n        if (regexCache[property]) {\n            return regexCache[property];\n        }\n        const arrayIndexRegex = exports.arrayRegex();\n        const match = arrayIndexRegex.exec(property.trim());\n        if (match != null) {\n            return (regexCache[property] = new ArrayInfo(match[1], match[2]));\n        }\n        return null;\n    }\n    /**\n     * Get the index for the array\n     * @param data\n     * @param avoidProperty\n     */\n    getIndex(data, avoidProperty) {\n        if (avoidProperty === undefined) {\n            avoidProperty = false;\n        }\n        if (this.append) {\n            return -1;\n        }\n        const index = this.index;\n        if (index == -1) {\n            const dataIterable = avoidProperty ? data : data[this.property];\n            if (dataIterable.length === 0) {\n                return 0;\n            }\n            return dataIterable.length - 1;\n        }\n        return index;\n    }\n    /**\n     * Get the Data\n     * @param data\n     */\n    getData(data) {\n        if (this.append) {\n            throw new Errors_1.DataError(\"Can't get data when appending\", 100);\n        }\n        const index = this.getIndex(data);\n        return data[this.property][index];\n    }\n    /**\n     * Set the data for the array\n     * @param data\n     * @param value\n     */\n    setData(data, value) {\n        if (this.append) {\n            data[this.property].push(value);\n        }\n        else {\n            const index = this.getIndex(data);\n            data[this.property][index] = value;\n        }\n    }\n    /**\n     * Delete the index from the array\n     * @param data\n     */\n    delete(data) {\n        if (this.append) {\n            throw new Errors_1.DataError(\"Can't delete an appended data\", 10);\n        }\n        const index = this.getIndex(data);\n        data[this.property].splice(index, 1);\n    }\n    /**\n     * Check if the ArrayInfo is valid for the given data\n     * @param data\n     */\n    isValid(data) {\n        const index = this.getIndex(data);\n        return data[this.property].hasOwnProperty(index);\n    }\n}\nexports.ArrayInfo = ArrayInfo;\n//# sourceMappingURL=ArrayInfo.js.map\n\n//# sourceURL=webpack://brackets-viewer/./node_modules/node-json-db/dist/lib/ArrayInfo.js?");

/***/ }),

/***/ "./node_modules/node-json-db/dist/lib/DBParentData.js":
/*!************************************************************!*\
  !*** ./node_modules/node-json-db/dist/lib/DBParentData.js ***!
  \************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.DBParentData = void 0;\nconst ArrayInfo_1 = __webpack_require__(/*! ./ArrayInfo */ \"./node_modules/node-json-db/dist/lib/ArrayInfo.js\");\nconst Errors_1 = __webpack_require__(/*! ./Errors */ \"./node_modules/node-json-db/dist/lib/Errors.js\");\nclass DBParentData {\n    constructor(data, db, dataPath, parent) {\n        this.parent = parent;\n        this.data = data;\n        this.db = db;\n        this.dataPath = dataPath;\n    }\n    /**\n     * Check if it's an array\n     * @param deletion\n     */\n    checkArray(deletion = false) {\n        const arrayInfo = ArrayInfo_1.ArrayInfo.processArray(this.parent);\n        if (arrayInfo && (!arrayInfo.append || deletion) && !arrayInfo.isValid(this.data)) {\n            throw new Errors_1.DataError(\"DataPath: /\" + this.dataPath + \". Can't find index \" + arrayInfo.index + \" in array \" + arrayInfo.property, 10);\n        }\n        return arrayInfo;\n    }\n    /**\n     * Get the data linked to this path\n     */\n    getData() {\n        if (this.parent === undefined) {\n            return this.data;\n        }\n        const arrayInfo = this.checkArray();\n        if (arrayInfo) {\n            return arrayInfo.getData(this.data);\n        }\n        else {\n            return this.data[this.parent];\n        }\n    }\n    /**\n     * Set the data to the wanted path\n     * @param toSet\n     */\n    setData(toSet) {\n        if (this.parent === undefined) {\n            this.db.resetData(toSet);\n            return;\n        }\n        const arrayInfo = ArrayInfo_1.ArrayInfo.processArray(this.parent);\n        if (arrayInfo) {\n            if (!this.data.hasOwnProperty(arrayInfo.property)) {\n                this.data[arrayInfo.property] = [];\n            }\n            else if (!Array.isArray(this.data[arrayInfo.property])) {\n                throw new Errors_1.DataError(\"DataPath: /\" + this.dataPath + \". \" + arrayInfo.property + \" is not an array.\", 11);\n            }\n            arrayInfo.setData(this.data, toSet);\n        }\n        else {\n            this.data[this.parent] = toSet;\n        }\n    }\n    /**\n     * Delete the data of the current path\n     */\n    delete() {\n        if (this.parent === undefined) {\n            this.db.resetData({});\n            return;\n        }\n        const arrayInfo = this.checkArray(true);\n        if (arrayInfo) {\n            arrayInfo.delete(this.data);\n        }\n        else {\n            delete this.data[this.parent];\n        }\n    }\n}\nexports.DBParentData = DBParentData;\n//# sourceMappingURL=DBParentData.js.map\n\n//# sourceURL=webpack://brackets-viewer/./node_modules/node-json-db/dist/lib/DBParentData.js?");

/***/ }),

/***/ "./node_modules/node-json-db/dist/lib/Errors.js":
/*!******************************************************!*\
  !*** ./node_modules/node-json-db/dist/lib/Errors.js ***!
  \******************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.DataError = exports.DatabaseError = exports.NestedError = void 0;\nclass NestedError extends Error {\n    constructor(message, id, inner) {\n        super(message);\n        this.inner = inner;\n        this.id = id;\n        this.name = this.constructor.name;\n    }\n    toString() {\n        const string = this.name + \": \" + this.message;\n        if (this.inner) {\n            return string + ':\\n' + this.inner;\n        }\n        return string;\n    }\n}\nexports.NestedError = NestedError;\nclass DatabaseError extends NestedError {\n}\nexports.DatabaseError = DatabaseError;\nclass DataError extends NestedError {\n}\nexports.DataError = DataError;\n//# sourceMappingURL=Errors.js.map\n\n//# sourceURL=webpack://brackets-viewer/./node_modules/node-json-db/dist/lib/Errors.js?");

/***/ }),

/***/ "./node_modules/node-json-db/dist/lib/JsonDBConfig.js":
/*!************************************************************!*\
  !*** ./node_modules/node-json-db/dist/lib/JsonDBConfig.js ***!
  \************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.Config = void 0;\nconst path = __webpack_require__(/*! path */ \"./node_modules/path-browserify/index.js\");\nclass Config {\n    constructor(filename, saveOnPush = true, humanReadable = false, separator = '/') {\n        this.filename = filename;\n        // Force json if no extension\n        if (path.extname(filename) === \"\") {\n            this.filename += \".json\";\n        }\n        this.humanReadable = humanReadable;\n        this.saveOnPush = saveOnPush;\n        this.separator = separator;\n    }\n}\nexports.Config = Config;\n//# sourceMappingURL=JsonDBConfig.js.map\n\n//# sourceURL=webpack://brackets-viewer/./node_modules/node-json-db/dist/lib/JsonDBConfig.js?");

/***/ }),

/***/ "./node_modules/node-json-db/dist/lib/Utils.js":
/*!*****************************************************!*\
  !*** ./node_modules/node-json-db/dist/lib/Utils.js ***!
  \*****************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.removeTrailingChar = exports.merge = void 0;\nconst merge = (...arrays) => {\n    const destination = {};\n    arrays.forEach(function (source) {\n        var prop;\n        for (prop in source) {\n            if (prop in destination && destination[prop] === null) {\n                destination[prop] = source[prop];\n            }\n            else if (prop in destination && Array.isArray(destination[prop])) {\n                // Concat Arrays\n                destination[prop] = destination[prop].concat(source[prop]);\n            }\n            else if (prop in destination && typeof destination[prop] === \"object\") {\n                // Merge Objects\n                destination[prop] = exports.merge(destination[prop], source[prop]);\n            }\n            else {\n                // Set new values\n                destination[prop] = source[prop];\n            }\n        }\n    });\n    return destination;\n};\nexports.merge = merge;\nconst removeTrailingChar = (dataPath, trailing) => {\n    if (dataPath.length > 1 && dataPath.endsWith(trailing)) {\n        return dataPath.substring(0, dataPath.length - 1);\n    }\n    return dataPath;\n};\nexports.removeTrailingChar = removeTrailingChar;\n//# sourceMappingURL=Utils.js.map\n\n//# sourceURL=webpack://brackets-viewer/./node_modules/node-json-db/dist/lib/Utils.js?");

/***/ }),

/***/ "./node_modules/path-browserify/index.js":
/*!***********************************************!*\
  !*** ./node_modules/path-browserify/index.js ***!
  \***********************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("/* provided dependency */ var process = __webpack_require__(/*! process/browser */ \"./node_modules/process/browser.js\");\n// 'path' module extracted from Node.js v8.11.1 (only the posix part)\n// transplited with Babel\n\n// Copyright Joyent, Inc. and other Node contributors.\n//\n// Permission is hereby granted, free of charge, to any person obtaining a\n// copy of this software and associated documentation files (the\n// \"Software\"), to deal in the Software without restriction, including\n// without limitation the rights to use, copy, modify, merge, publish,\n// distribute, sublicense, and/or sell copies of the Software, and to permit\n// persons to whom the Software is furnished to do so, subject to the\n// following conditions:\n//\n// The above copyright notice and this permission notice shall be included\n// in all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS\n// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN\n// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,\n// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR\n// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE\n// USE OR OTHER DEALINGS IN THE SOFTWARE.\n\n\n\nfunction assertPath(path) {\n  if (typeof path !== 'string') {\n    throw new TypeError('Path must be a string. Received ' + JSON.stringify(path));\n  }\n}\n\n// Resolves . and .. elements in a path with directory names\nfunction normalizeStringPosix(path, allowAboveRoot) {\n  var res = '';\n  var lastSegmentLength = 0;\n  var lastSlash = -1;\n  var dots = 0;\n  var code;\n  for (var i = 0; i <= path.length; ++i) {\n    if (i < path.length)\n      code = path.charCodeAt(i);\n    else if (code === 47 /*/*/)\n      break;\n    else\n      code = 47 /*/*/;\n    if (code === 47 /*/*/) {\n      if (lastSlash === i - 1 || dots === 1) {\n        // NOOP\n      } else if (lastSlash !== i - 1 && dots === 2) {\n        if (res.length < 2 || lastSegmentLength !== 2 || res.charCodeAt(res.length - 1) !== 46 /*.*/ || res.charCodeAt(res.length - 2) !== 46 /*.*/) {\n          if (res.length > 2) {\n            var lastSlashIndex = res.lastIndexOf('/');\n            if (lastSlashIndex !== res.length - 1) {\n              if (lastSlashIndex === -1) {\n                res = '';\n                lastSegmentLength = 0;\n              } else {\n                res = res.slice(0, lastSlashIndex);\n                lastSegmentLength = res.length - 1 - res.lastIndexOf('/');\n              }\n              lastSlash = i;\n              dots = 0;\n              continue;\n            }\n          } else if (res.length === 2 || res.length === 1) {\n            res = '';\n            lastSegmentLength = 0;\n            lastSlash = i;\n            dots = 0;\n            continue;\n          }\n        }\n        if (allowAboveRoot) {\n          if (res.length > 0)\n            res += '/..';\n          else\n            res = '..';\n          lastSegmentLength = 2;\n        }\n      } else {\n        if (res.length > 0)\n          res += '/' + path.slice(lastSlash + 1, i);\n        else\n          res = path.slice(lastSlash + 1, i);\n        lastSegmentLength = i - lastSlash - 1;\n      }\n      lastSlash = i;\n      dots = 0;\n    } else if (code === 46 /*.*/ && dots !== -1) {\n      ++dots;\n    } else {\n      dots = -1;\n    }\n  }\n  return res;\n}\n\nfunction _format(sep, pathObject) {\n  var dir = pathObject.dir || pathObject.root;\n  var base = pathObject.base || (pathObject.name || '') + (pathObject.ext || '');\n  if (!dir) {\n    return base;\n  }\n  if (dir === pathObject.root) {\n    return dir + base;\n  }\n  return dir + sep + base;\n}\n\nvar posix = {\n  // path.resolve([from ...], to)\n  resolve: function resolve() {\n    var resolvedPath = '';\n    var resolvedAbsolute = false;\n    var cwd;\n\n    for (var i = arguments.length - 1; i >= -1 && !resolvedAbsolute; i--) {\n      var path;\n      if (i >= 0)\n        path = arguments[i];\n      else {\n        if (cwd === undefined)\n          cwd = process.cwd();\n        path = cwd;\n      }\n\n      assertPath(path);\n\n      // Skip empty entries\n      if (path.length === 0) {\n        continue;\n      }\n\n      resolvedPath = path + '/' + resolvedPath;\n      resolvedAbsolute = path.charCodeAt(0) === 47 /*/*/;\n    }\n\n    // At this point the path should be resolved to a full absolute path, but\n    // handle relative paths to be safe (might happen when process.cwd() fails)\n\n    // Normalize the path\n    resolvedPath = normalizeStringPosix(resolvedPath, !resolvedAbsolute);\n\n    if (resolvedAbsolute) {\n      if (resolvedPath.length > 0)\n        return '/' + resolvedPath;\n      else\n        return '/';\n    } else if (resolvedPath.length > 0) {\n      return resolvedPath;\n    } else {\n      return '.';\n    }\n  },\n\n  normalize: function normalize(path) {\n    assertPath(path);\n\n    if (path.length === 0) return '.';\n\n    var isAbsolute = path.charCodeAt(0) === 47 /*/*/;\n    var trailingSeparator = path.charCodeAt(path.length - 1) === 47 /*/*/;\n\n    // Normalize the path\n    path = normalizeStringPosix(path, !isAbsolute);\n\n    if (path.length === 0 && !isAbsolute) path = '.';\n    if (path.length > 0 && trailingSeparator) path += '/';\n\n    if (isAbsolute) return '/' + path;\n    return path;\n  },\n\n  isAbsolute: function isAbsolute(path) {\n    assertPath(path);\n    return path.length > 0 && path.charCodeAt(0) === 47 /*/*/;\n  },\n\n  join: function join() {\n    if (arguments.length === 0)\n      return '.';\n    var joined;\n    for (var i = 0; i < arguments.length; ++i) {\n      var arg = arguments[i];\n      assertPath(arg);\n      if (arg.length > 0) {\n        if (joined === undefined)\n          joined = arg;\n        else\n          joined += '/' + arg;\n      }\n    }\n    if (joined === undefined)\n      return '.';\n    return posix.normalize(joined);\n  },\n\n  relative: function relative(from, to) {\n    assertPath(from);\n    assertPath(to);\n\n    if (from === to) return '';\n\n    from = posix.resolve(from);\n    to = posix.resolve(to);\n\n    if (from === to) return '';\n\n    // Trim any leading backslashes\n    var fromStart = 1;\n    for (; fromStart < from.length; ++fromStart) {\n      if (from.charCodeAt(fromStart) !== 47 /*/*/)\n        break;\n    }\n    var fromEnd = from.length;\n    var fromLen = fromEnd - fromStart;\n\n    // Trim any leading backslashes\n    var toStart = 1;\n    for (; toStart < to.length; ++toStart) {\n      if (to.charCodeAt(toStart) !== 47 /*/*/)\n        break;\n    }\n    var toEnd = to.length;\n    var toLen = toEnd - toStart;\n\n    // Compare paths to find the longest common path from root\n    var length = fromLen < toLen ? fromLen : toLen;\n    var lastCommonSep = -1;\n    var i = 0;\n    for (; i <= length; ++i) {\n      if (i === length) {\n        if (toLen > length) {\n          if (to.charCodeAt(toStart + i) === 47 /*/*/) {\n            // We get here if `from` is the exact base path for `to`.\n            // For example: from='/foo/bar'; to='/foo/bar/baz'\n            return to.slice(toStart + i + 1);\n          } else if (i === 0) {\n            // We get here if `from` is the root\n            // For example: from='/'; to='/foo'\n            return to.slice(toStart + i);\n          }\n        } else if (fromLen > length) {\n          if (from.charCodeAt(fromStart + i) === 47 /*/*/) {\n            // We get here if `to` is the exact base path for `from`.\n            // For example: from='/foo/bar/baz'; to='/foo/bar'\n            lastCommonSep = i;\n          } else if (i === 0) {\n            // We get here if `to` is the root.\n            // For example: from='/foo'; to='/'\n            lastCommonSep = 0;\n          }\n        }\n        break;\n      }\n      var fromCode = from.charCodeAt(fromStart + i);\n      var toCode = to.charCodeAt(toStart + i);\n      if (fromCode !== toCode)\n        break;\n      else if (fromCode === 47 /*/*/)\n        lastCommonSep = i;\n    }\n\n    var out = '';\n    // Generate the relative path based on the path difference between `to`\n    // and `from`\n    for (i = fromStart + lastCommonSep + 1; i <= fromEnd; ++i) {\n      if (i === fromEnd || from.charCodeAt(i) === 47 /*/*/) {\n        if (out.length === 0)\n          out += '..';\n        else\n          out += '/..';\n      }\n    }\n\n    // Lastly, append the rest of the destination (`to`) path that comes after\n    // the common path parts\n    if (out.length > 0)\n      return out + to.slice(toStart + lastCommonSep);\n    else {\n      toStart += lastCommonSep;\n      if (to.charCodeAt(toStart) === 47 /*/*/)\n        ++toStart;\n      return to.slice(toStart);\n    }\n  },\n\n  _makeLong: function _makeLong(path) {\n    return path;\n  },\n\n  dirname: function dirname(path) {\n    assertPath(path);\n    if (path.length === 0) return '.';\n    var code = path.charCodeAt(0);\n    var hasRoot = code === 47 /*/*/;\n    var end = -1;\n    var matchedSlash = true;\n    for (var i = path.length - 1; i >= 1; --i) {\n      code = path.charCodeAt(i);\n      if (code === 47 /*/*/) {\n          if (!matchedSlash) {\n            end = i;\n            break;\n          }\n        } else {\n        // We saw the first non-path separator\n        matchedSlash = false;\n      }\n    }\n\n    if (end === -1) return hasRoot ? '/' : '.';\n    if (hasRoot && end === 1) return '//';\n    return path.slice(0, end);\n  },\n\n  basename: function basename(path, ext) {\n    if (ext !== undefined && typeof ext !== 'string') throw new TypeError('\"ext\" argument must be a string');\n    assertPath(path);\n\n    var start = 0;\n    var end = -1;\n    var matchedSlash = true;\n    var i;\n\n    if (ext !== undefined && ext.length > 0 && ext.length <= path.length) {\n      if (ext.length === path.length && ext === path) return '';\n      var extIdx = ext.length - 1;\n      var firstNonSlashEnd = -1;\n      for (i = path.length - 1; i >= 0; --i) {\n        var code = path.charCodeAt(i);\n        if (code === 47 /*/*/) {\n            // If we reached a path separator that was not part of a set of path\n            // separators at the end of the string, stop now\n            if (!matchedSlash) {\n              start = i + 1;\n              break;\n            }\n          } else {\n          if (firstNonSlashEnd === -1) {\n            // We saw the first non-path separator, remember this index in case\n            // we need it if the extension ends up not matching\n            matchedSlash = false;\n            firstNonSlashEnd = i + 1;\n          }\n          if (extIdx >= 0) {\n            // Try to match the explicit extension\n            if (code === ext.charCodeAt(extIdx)) {\n              if (--extIdx === -1) {\n                // We matched the extension, so mark this as the end of our path\n                // component\n                end = i;\n              }\n            } else {\n              // Extension does not match, so our result is the entire path\n              // component\n              extIdx = -1;\n              end = firstNonSlashEnd;\n            }\n          }\n        }\n      }\n\n      if (start === end) end = firstNonSlashEnd;else if (end === -1) end = path.length;\n      return path.slice(start, end);\n    } else {\n      for (i = path.length - 1; i >= 0; --i) {\n        if (path.charCodeAt(i) === 47 /*/*/) {\n            // If we reached a path separator that was not part of a set of path\n            // separators at the end of the string, stop now\n            if (!matchedSlash) {\n              start = i + 1;\n              break;\n            }\n          } else if (end === -1) {\n          // We saw the first non-path separator, mark this as the end of our\n          // path component\n          matchedSlash = false;\n          end = i + 1;\n        }\n      }\n\n      if (end === -1) return '';\n      return path.slice(start, end);\n    }\n  },\n\n  extname: function extname(path) {\n    assertPath(path);\n    var startDot = -1;\n    var startPart = 0;\n    var end = -1;\n    var matchedSlash = true;\n    // Track the state of characters (if any) we see before our first dot and\n    // after any path separator we find\n    var preDotState = 0;\n    for (var i = path.length - 1; i >= 0; --i) {\n      var code = path.charCodeAt(i);\n      if (code === 47 /*/*/) {\n          // If we reached a path separator that was not part of a set of path\n          // separators at the end of the string, stop now\n          if (!matchedSlash) {\n            startPart = i + 1;\n            break;\n          }\n          continue;\n        }\n      if (end === -1) {\n        // We saw the first non-path separator, mark this as the end of our\n        // extension\n        matchedSlash = false;\n        end = i + 1;\n      }\n      if (code === 46 /*.*/) {\n          // If this is our first dot, mark it as the start of our extension\n          if (startDot === -1)\n            startDot = i;\n          else if (preDotState !== 1)\n            preDotState = 1;\n      } else if (startDot !== -1) {\n        // We saw a non-dot and non-path separator before our dot, so we should\n        // have a good chance at having a non-empty extension\n        preDotState = -1;\n      }\n    }\n\n    if (startDot === -1 || end === -1 ||\n        // We saw a non-dot character immediately before the dot\n        preDotState === 0 ||\n        // The (right-most) trimmed path component is exactly '..'\n        preDotState === 1 && startDot === end - 1 && startDot === startPart + 1) {\n      return '';\n    }\n    return path.slice(startDot, end);\n  },\n\n  format: function format(pathObject) {\n    if (pathObject === null || typeof pathObject !== 'object') {\n      throw new TypeError('The \"pathObject\" argument must be of type Object. Received type ' + typeof pathObject);\n    }\n    return _format('/', pathObject);\n  },\n\n  parse: function parse(path) {\n    assertPath(path);\n\n    var ret = { root: '', dir: '', base: '', ext: '', name: '' };\n    if (path.length === 0) return ret;\n    var code = path.charCodeAt(0);\n    var isAbsolute = code === 47 /*/*/;\n    var start;\n    if (isAbsolute) {\n      ret.root = '/';\n      start = 1;\n    } else {\n      start = 0;\n    }\n    var startDot = -1;\n    var startPart = 0;\n    var end = -1;\n    var matchedSlash = true;\n    var i = path.length - 1;\n\n    // Track the state of characters (if any) we see before our first dot and\n    // after any path separator we find\n    var preDotState = 0;\n\n    // Get non-dir info\n    for (; i >= start; --i) {\n      code = path.charCodeAt(i);\n      if (code === 47 /*/*/) {\n          // If we reached a path separator that was not part of a set of path\n          // separators at the end of the string, stop now\n          if (!matchedSlash) {\n            startPart = i + 1;\n            break;\n          }\n          continue;\n        }\n      if (end === -1) {\n        // We saw the first non-path separator, mark this as the end of our\n        // extension\n        matchedSlash = false;\n        end = i + 1;\n      }\n      if (code === 46 /*.*/) {\n          // If this is our first dot, mark it as the start of our extension\n          if (startDot === -1) startDot = i;else if (preDotState !== 1) preDotState = 1;\n        } else if (startDot !== -1) {\n        // We saw a non-dot and non-path separator before our dot, so we should\n        // have a good chance at having a non-empty extension\n        preDotState = -1;\n      }\n    }\n\n    if (startDot === -1 || end === -1 ||\n    // We saw a non-dot character immediately before the dot\n    preDotState === 0 ||\n    // The (right-most) trimmed path component is exactly '..'\n    preDotState === 1 && startDot === end - 1 && startDot === startPart + 1) {\n      if (end !== -1) {\n        if (startPart === 0 && isAbsolute) ret.base = ret.name = path.slice(1, end);else ret.base = ret.name = path.slice(startPart, end);\n      }\n    } else {\n      if (startPart === 0 && isAbsolute) {\n        ret.name = path.slice(1, startDot);\n        ret.base = path.slice(1, end);\n      } else {\n        ret.name = path.slice(startPart, startDot);\n        ret.base = path.slice(startPart, end);\n      }\n      ret.ext = path.slice(startDot, end);\n    }\n\n    if (startPart > 0) ret.dir = path.slice(0, startPart - 1);else if (isAbsolute) ret.dir = '/';\n\n    return ret;\n  },\n\n  sep: '/',\n  delimiter: ':',\n  win32: null,\n  posix: null\n};\n\nposix.posix = posix;\n\nmodule.exports = posix;\n\n\n//# sourceURL=webpack://brackets-viewer/./node_modules/path-browserify/index.js?");

/***/ }),

/***/ "./node_modules/process/browser.js":
/*!*****************************************!*\
  !*** ./node_modules/process/browser.js ***!
  \*****************************************/
/***/ ((module) => {

eval("// shim for using process in browser\nvar process = module.exports = {};\n\n// cached from whatever global is present so that test runners that stub it\n// don't break things.  But we need to wrap it in a try catch in case it is\n// wrapped in strict mode code which doesn't define any globals.  It's inside a\n// function because try/catches deoptimize in certain engines.\n\nvar cachedSetTimeout;\nvar cachedClearTimeout;\n\nfunction defaultSetTimout() {\n    throw new Error('setTimeout has not been defined');\n}\nfunction defaultClearTimeout () {\n    throw new Error('clearTimeout has not been defined');\n}\n(function () {\n    try {\n        if (typeof setTimeout === 'function') {\n            cachedSetTimeout = setTimeout;\n        } else {\n            cachedSetTimeout = defaultSetTimout;\n        }\n    } catch (e) {\n        cachedSetTimeout = defaultSetTimout;\n    }\n    try {\n        if (typeof clearTimeout === 'function') {\n            cachedClearTimeout = clearTimeout;\n        } else {\n            cachedClearTimeout = defaultClearTimeout;\n        }\n    } catch (e) {\n        cachedClearTimeout = defaultClearTimeout;\n    }\n} ())\nfunction runTimeout(fun) {\n    if (cachedSetTimeout === setTimeout) {\n        //normal enviroments in sane situations\n        return setTimeout(fun, 0);\n    }\n    // if setTimeout wasn't available but was latter defined\n    if ((cachedSetTimeout === defaultSetTimout || !cachedSetTimeout) && setTimeout) {\n        cachedSetTimeout = setTimeout;\n        return setTimeout(fun, 0);\n    }\n    try {\n        // when when somebody has screwed with setTimeout but no I.E. maddness\n        return cachedSetTimeout(fun, 0);\n    } catch(e){\n        try {\n            // When we are in I.E. but the script has been evaled so I.E. doesn't trust the global object when called normally\n            return cachedSetTimeout.call(null, fun, 0);\n        } catch(e){\n            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error\n            return cachedSetTimeout.call(this, fun, 0);\n        }\n    }\n\n\n}\nfunction runClearTimeout(marker) {\n    if (cachedClearTimeout === clearTimeout) {\n        //normal enviroments in sane situations\n        return clearTimeout(marker);\n    }\n    // if clearTimeout wasn't available but was latter defined\n    if ((cachedClearTimeout === defaultClearTimeout || !cachedClearTimeout) && clearTimeout) {\n        cachedClearTimeout = clearTimeout;\n        return clearTimeout(marker);\n    }\n    try {\n        // when when somebody has screwed with setTimeout but no I.E. maddness\n        return cachedClearTimeout(marker);\n    } catch (e){\n        try {\n            // When we are in I.E. but the script has been evaled so I.E. doesn't  trust the global object when called normally\n            return cachedClearTimeout.call(null, marker);\n        } catch (e){\n            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error.\n            // Some versions of I.E. have different rules for clearTimeout vs setTimeout\n            return cachedClearTimeout.call(this, marker);\n        }\n    }\n\n\n\n}\nvar queue = [];\nvar draining = false;\nvar currentQueue;\nvar queueIndex = -1;\n\nfunction cleanUpNextTick() {\n    if (!draining || !currentQueue) {\n        return;\n    }\n    draining = false;\n    if (currentQueue.length) {\n        queue = currentQueue.concat(queue);\n    } else {\n        queueIndex = -1;\n    }\n    if (queue.length) {\n        drainQueue();\n    }\n}\n\nfunction drainQueue() {\n    if (draining) {\n        return;\n    }\n    var timeout = runTimeout(cleanUpNextTick);\n    draining = true;\n\n    var len = queue.length;\n    while(len) {\n        currentQueue = queue;\n        queue = [];\n        while (++queueIndex < len) {\n            if (currentQueue) {\n                currentQueue[queueIndex].run();\n            }\n        }\n        queueIndex = -1;\n        len = queue.length;\n    }\n    currentQueue = null;\n    draining = false;\n    runClearTimeout(timeout);\n}\n\nprocess.nextTick = function (fun) {\n    var args = new Array(arguments.length - 1);\n    if (arguments.length > 1) {\n        for (var i = 1; i < arguments.length; i++) {\n            args[i - 1] = arguments[i];\n        }\n    }\n    queue.push(new Item(fun, args));\n    if (queue.length === 1 && !draining) {\n        runTimeout(drainQueue);\n    }\n};\n\n// v8 likes predictible objects\nfunction Item(fun, array) {\n    this.fun = fun;\n    this.array = array;\n}\nItem.prototype.run = function () {\n    this.fun.apply(null, this.array);\n};\nprocess.title = 'browser';\nprocess.browser = true;\nprocess.env = {};\nprocess.argv = [];\nprocess.version = ''; // empty string to avoid regexp issues\nprocess.versions = {};\n\nfunction noop() {}\n\nprocess.on = noop;\nprocess.addListener = noop;\nprocess.once = noop;\nprocess.off = noop;\nprocess.removeListener = noop;\nprocess.removeAllListeners = noop;\nprocess.emit = noop;\nprocess.prependListener = noop;\nprocess.prependOnceListener = noop;\n\nprocess.listeners = function (name) { return [] }\n\nprocess.binding = function (name) {\n    throw new Error('process.binding is not supported');\n};\n\nprocess.cwd = function () { return '/' };\nprocess.chdir = function (dir) {\n    throw new Error('process.chdir is not supported');\n};\nprocess.umask = function() { return 0; };\n\n\n//# sourceURL=webpack://brackets-viewer/./node_modules/process/browser.js?");

/***/ }),

/***/ "./node_modules/rfdc/index.js":
/*!************************************!*\
  !*** ./node_modules/rfdc/index.js ***!
  \************************************/
/***/ ((module) => {

"use strict";
eval("\nmodule.exports = rfdc\n\nfunction copyBuffer (cur) {\n  if (cur instanceof Buffer) {\n    return Buffer.from(cur)\n  }\n\n  return new cur.constructor(cur.buffer.slice(), cur.byteOffset, cur.length)\n}\n\nfunction rfdc (opts) {\n  opts = opts || {}\n\n  if (opts.circles) return rfdcCircles(opts)\n  return opts.proto ? cloneProto : clone\n\n  function cloneArray (a, fn) {\n    var keys = Object.keys(a)\n    var a2 = new Array(keys.length)\n    for (var i = 0; i < keys.length; i++) {\n      var k = keys[i]\n      var cur = a[k]\n      if (typeof cur !== 'object' || cur === null) {\n        a2[k] = cur\n      } else if (cur instanceof Date) {\n        a2[k] = new Date(cur)\n      } else if (ArrayBuffer.isView(cur)) {\n        a2[k] = copyBuffer(cur)\n      } else {\n        a2[k] = fn(cur)\n      }\n    }\n    return a2\n  }\n\n  function clone (o) {\n    if (typeof o !== 'object' || o === null) return o\n    if (o instanceof Date) return new Date(o)\n    if (Array.isArray(o)) return cloneArray(o, clone)\n    if (o instanceof Map) return new Map(cloneArray(Array.from(o), clone))\n    if (o instanceof Set) return new Set(cloneArray(Array.from(o), clone))\n    var o2 = {}\n    for (var k in o) {\n      if (Object.hasOwnProperty.call(o, k) === false) continue\n      var cur = o[k]\n      if (typeof cur !== 'object' || cur === null) {\n        o2[k] = cur\n      } else if (cur instanceof Date) {\n        o2[k] = new Date(cur)\n      } else if (cur instanceof Map) {\n        o2[k] = new Map(cloneArray(Array.from(cur), clone))\n      } else if (cur instanceof Set) {\n        o2[k] = new Set(cloneArray(Array.from(cur), clone))\n      } else if (ArrayBuffer.isView(cur)) {\n        o2[k] = copyBuffer(cur)\n      } else {\n        o2[k] = clone(cur)\n      }\n    }\n    return o2\n  }\n\n  function cloneProto (o) {\n    if (typeof o !== 'object' || o === null) return o\n    if (o instanceof Date) return new Date(o)\n    if (Array.isArray(o)) return cloneArray(o, cloneProto)\n    if (o instanceof Map) return new Map(cloneArray(Array.from(o), cloneProto))\n    if (o instanceof Set) return new Set(cloneArray(Array.from(o), cloneProto))\n    var o2 = {}\n    for (var k in o) {\n      var cur = o[k]\n      if (typeof cur !== 'object' || cur === null) {\n        o2[k] = cur\n      } else if (cur instanceof Date) {\n        o2[k] = new Date(cur)\n      } else if (cur instanceof Map) {\n        o2[k] = new Map(cloneArray(Array.from(cur), cloneProto))\n      } else if (cur instanceof Set) {\n        o2[k] = new Set(cloneArray(Array.from(cur), cloneProto))\n      } else if (ArrayBuffer.isView(cur)) {\n        o2[k] = copyBuffer(cur)\n      } else {\n        o2[k] = cloneProto(cur)\n      }\n    }\n    return o2\n  }\n}\n\nfunction rfdcCircles (opts) {\n  var refs = []\n  var refsNew = []\n\n  return opts.proto ? cloneProto : clone\n\n  function cloneArray (a, fn) {\n    var keys = Object.keys(a)\n    var a2 = new Array(keys.length)\n    for (var i = 0; i < keys.length; i++) {\n      var k = keys[i]\n      var cur = a[k]\n      if (typeof cur !== 'object' || cur === null) {\n        a2[k] = cur\n      } else if (cur instanceof Date) {\n        a2[k] = new Date(cur)\n      } else if (ArrayBuffer.isView(cur)) {\n        a2[k] = copyBuffer(cur)\n      } else {\n        var index = refs.indexOf(cur)\n        if (index !== -1) {\n          a2[k] = refsNew[index]\n        } else {\n          a2[k] = fn(cur)\n        }\n      }\n    }\n    return a2\n  }\n\n  function clone (o) {\n    if (typeof o !== 'object' || o === null) return o\n    if (o instanceof Date) return new Date(o)\n    if (Array.isArray(o)) return cloneArray(o, clone)\n    if (o instanceof Map) return new Map(cloneArray(Array.from(o), clone))\n    if (o instanceof Set) return new Set(cloneArray(Array.from(o), clone))\n    var o2 = {}\n    refs.push(o)\n    refsNew.push(o2)\n    for (var k in o) {\n      if (Object.hasOwnProperty.call(o, k) === false) continue\n      var cur = o[k]\n      if (typeof cur !== 'object' || cur === null) {\n        o2[k] = cur\n      } else if (cur instanceof Date) {\n        o2[k] = new Date(cur)\n      } else if (cur instanceof Map) {\n        o2[k] = new Map(cloneArray(Array.from(cur), clone))\n      } else if (cur instanceof Set) {\n        o2[k] = new Set(cloneArray(Array.from(cur), clone))\n      } else if (ArrayBuffer.isView(cur)) {\n        o2[k] = copyBuffer(cur)\n      } else {\n        var i = refs.indexOf(cur)\n        if (i !== -1) {\n          o2[k] = refsNew[i]\n        } else {\n          o2[k] = clone(cur)\n        }\n      }\n    }\n    refs.pop()\n    refsNew.pop()\n    return o2\n  }\n\n  function cloneProto (o) {\n    if (typeof o !== 'object' || o === null) return o\n    if (o instanceof Date) return new Date(o)\n    if (Array.isArray(o)) return cloneArray(o, cloneProto)\n    if (o instanceof Map) return new Map(cloneArray(Array.from(o), cloneProto))\n    if (o instanceof Set) return new Set(cloneArray(Array.from(o), cloneProto))\n    var o2 = {}\n    refs.push(o)\n    refsNew.push(o2)\n    for (var k in o) {\n      var cur = o[k]\n      if (typeof cur !== 'object' || cur === null) {\n        o2[k] = cur\n      } else if (cur instanceof Date) {\n        o2[k] = new Date(cur)\n      } else if (cur instanceof Map) {\n        o2[k] = new Map(cloneArray(Array.from(cur), cloneProto))\n      } else if (cur instanceof Set) {\n        o2[k] = new Set(cloneArray(Array.from(cur), cloneProto))\n      } else if (ArrayBuffer.isView(cur)) {\n        o2[k] = copyBuffer(cur)\n      } else {\n        var i = refs.indexOf(cur)\n        if (i !== -1) {\n          o2[k] = refsNew[i]\n        } else {\n          o2[k] = cloneProto(cur)\n        }\n      }\n    }\n    refs.pop()\n    refsNew.pop()\n    return o2\n  }\n}\n\n\n//# sourceURL=webpack://brackets-viewer/./node_modules/rfdc/index.js?");

/***/ }),

/***/ "./node_modules/util/support/isBufferBrowser.js":
/*!******************************************************!*\
  !*** ./node_modules/util/support/isBufferBrowser.js ***!
  \******************************************************/
/***/ ((module) => {

eval("module.exports = function isBuffer(arg) {\n  return arg && typeof arg === 'object'\n    && typeof arg.copy === 'function'\n    && typeof arg.fill === 'function'\n    && typeof arg.readUInt8 === 'function';\n}\n\n//# sourceURL=webpack://brackets-viewer/./node_modules/util/support/isBufferBrowser.js?");

/***/ }),

/***/ "./node_modules/util/support/types.js":
/*!********************************************!*\
  !*** ./node_modules/util/support/types.js ***!
  \********************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("// Currently in sync with Node.js lib/internal/util/types.js\n// https://github.com/nodejs/node/commit/112cc7c27551254aa2b17098fb774867f05ed0d9\n\n\n\nvar isArgumentsObject = __webpack_require__(/*! is-arguments */ \"./node_modules/is-arguments/index.js\");\nvar isGeneratorFunction = __webpack_require__(/*! is-generator-function */ \"./node_modules/is-generator-function/index.js\");\nvar whichTypedArray = __webpack_require__(/*! which-typed-array */ \"./node_modules/which-typed-array/index.js\");\nvar isTypedArray = __webpack_require__(/*! is-typed-array */ \"./node_modules/is-typed-array/index.js\");\n\nfunction uncurryThis(f) {\n  return f.call.bind(f);\n}\n\nvar BigIntSupported = typeof BigInt !== 'undefined';\nvar SymbolSupported = typeof Symbol !== 'undefined';\n\nvar ObjectToString = uncurryThis(Object.prototype.toString);\n\nvar numberValue = uncurryThis(Number.prototype.valueOf);\nvar stringValue = uncurryThis(String.prototype.valueOf);\nvar booleanValue = uncurryThis(Boolean.prototype.valueOf);\n\nif (BigIntSupported) {\n  var bigIntValue = uncurryThis(BigInt.prototype.valueOf);\n}\n\nif (SymbolSupported) {\n  var symbolValue = uncurryThis(Symbol.prototype.valueOf);\n}\n\nfunction checkBoxedPrimitive(value, prototypeValueOf) {\n  if (typeof value !== 'object') {\n    return false;\n  }\n  try {\n    prototypeValueOf(value);\n    return true;\n  } catch(e) {\n    return false;\n  }\n}\n\nexports.isArgumentsObject = isArgumentsObject;\nexports.isGeneratorFunction = isGeneratorFunction;\nexports.isTypedArray = isTypedArray;\n\n// Taken from here and modified for better browser support\n// https://github.com/sindresorhus/p-is-promise/blob/cda35a513bda03f977ad5cde3a079d237e82d7ef/index.js\nfunction isPromise(input) {\n\treturn (\n\t\t(\n\t\t\ttypeof Promise !== 'undefined' &&\n\t\t\tinput instanceof Promise\n\t\t) ||\n\t\t(\n\t\t\tinput !== null &&\n\t\t\ttypeof input === 'object' &&\n\t\t\ttypeof input.then === 'function' &&\n\t\t\ttypeof input.catch === 'function'\n\t\t)\n\t);\n}\nexports.isPromise = isPromise;\n\nfunction isArrayBufferView(value) {\n  if (typeof ArrayBuffer !== 'undefined' && ArrayBuffer.isView) {\n    return ArrayBuffer.isView(value);\n  }\n\n  return (\n    isTypedArray(value) ||\n    isDataView(value)\n  );\n}\nexports.isArrayBufferView = isArrayBufferView;\n\n\nfunction isUint8Array(value) {\n  return whichTypedArray(value) === 'Uint8Array';\n}\nexports.isUint8Array = isUint8Array;\n\nfunction isUint8ClampedArray(value) {\n  return whichTypedArray(value) === 'Uint8ClampedArray';\n}\nexports.isUint8ClampedArray = isUint8ClampedArray;\n\nfunction isUint16Array(value) {\n  return whichTypedArray(value) === 'Uint16Array';\n}\nexports.isUint16Array = isUint16Array;\n\nfunction isUint32Array(value) {\n  return whichTypedArray(value) === 'Uint32Array';\n}\nexports.isUint32Array = isUint32Array;\n\nfunction isInt8Array(value) {\n  return whichTypedArray(value) === 'Int8Array';\n}\nexports.isInt8Array = isInt8Array;\n\nfunction isInt16Array(value) {\n  return whichTypedArray(value) === 'Int16Array';\n}\nexports.isInt16Array = isInt16Array;\n\nfunction isInt32Array(value) {\n  return whichTypedArray(value) === 'Int32Array';\n}\nexports.isInt32Array = isInt32Array;\n\nfunction isFloat32Array(value) {\n  return whichTypedArray(value) === 'Float32Array';\n}\nexports.isFloat32Array = isFloat32Array;\n\nfunction isFloat64Array(value) {\n  return whichTypedArray(value) === 'Float64Array';\n}\nexports.isFloat64Array = isFloat64Array;\n\nfunction isBigInt64Array(value) {\n  return whichTypedArray(value) === 'BigInt64Array';\n}\nexports.isBigInt64Array = isBigInt64Array;\n\nfunction isBigUint64Array(value) {\n  return whichTypedArray(value) === 'BigUint64Array';\n}\nexports.isBigUint64Array = isBigUint64Array;\n\nfunction isMapToString(value) {\n  return ObjectToString(value) === '[object Map]';\n}\nisMapToString.working = (\n  typeof Map !== 'undefined' &&\n  isMapToString(new Map())\n);\n\nfunction isMap(value) {\n  if (typeof Map === 'undefined') {\n    return false;\n  }\n\n  return isMapToString.working\n    ? isMapToString(value)\n    : value instanceof Map;\n}\nexports.isMap = isMap;\n\nfunction isSetToString(value) {\n  return ObjectToString(value) === '[object Set]';\n}\nisSetToString.working = (\n  typeof Set !== 'undefined' &&\n  isSetToString(new Set())\n);\nfunction isSet(value) {\n  if (typeof Set === 'undefined') {\n    return false;\n  }\n\n  return isSetToString.working\n    ? isSetToString(value)\n    : value instanceof Set;\n}\nexports.isSet = isSet;\n\nfunction isWeakMapToString(value) {\n  return ObjectToString(value) === '[object WeakMap]';\n}\nisWeakMapToString.working = (\n  typeof WeakMap !== 'undefined' &&\n  isWeakMapToString(new WeakMap())\n);\nfunction isWeakMap(value) {\n  if (typeof WeakMap === 'undefined') {\n    return false;\n  }\n\n  return isWeakMapToString.working\n    ? isWeakMapToString(value)\n    : value instanceof WeakMap;\n}\nexports.isWeakMap = isWeakMap;\n\nfunction isWeakSetToString(value) {\n  return ObjectToString(value) === '[object WeakSet]';\n}\nisWeakSetToString.working = (\n  typeof WeakSet !== 'undefined' &&\n  isWeakSetToString(new WeakSet())\n);\nfunction isWeakSet(value) {\n  return isWeakSetToString(value);\n}\nexports.isWeakSet = isWeakSet;\n\nfunction isArrayBufferToString(value) {\n  return ObjectToString(value) === '[object ArrayBuffer]';\n}\nisArrayBufferToString.working = (\n  typeof ArrayBuffer !== 'undefined' &&\n  isArrayBufferToString(new ArrayBuffer())\n);\nfunction isArrayBuffer(value) {\n  if (typeof ArrayBuffer === 'undefined') {\n    return false;\n  }\n\n  return isArrayBufferToString.working\n    ? isArrayBufferToString(value)\n    : value instanceof ArrayBuffer;\n}\nexports.isArrayBuffer = isArrayBuffer;\n\nfunction isDataViewToString(value) {\n  return ObjectToString(value) === '[object DataView]';\n}\nisDataViewToString.working = (\n  typeof ArrayBuffer !== 'undefined' &&\n  typeof DataView !== 'undefined' &&\n  isDataViewToString(new DataView(new ArrayBuffer(1), 0, 1))\n);\nfunction isDataView(value) {\n  if (typeof DataView === 'undefined') {\n    return false;\n  }\n\n  return isDataViewToString.working\n    ? isDataViewToString(value)\n    : value instanceof DataView;\n}\nexports.isDataView = isDataView;\n\n// Store a copy of SharedArrayBuffer in case it's deleted elsewhere\nvar SharedArrayBufferCopy = typeof SharedArrayBuffer !== 'undefined' ? SharedArrayBuffer : undefined;\nfunction isSharedArrayBufferToString(value) {\n  return ObjectToString(value) === '[object SharedArrayBuffer]';\n}\nfunction isSharedArrayBuffer(value) {\n  if (typeof SharedArrayBufferCopy === 'undefined') {\n    return false;\n  }\n\n  if (typeof isSharedArrayBufferToString.working === 'undefined') {\n    isSharedArrayBufferToString.working = isSharedArrayBufferToString(new SharedArrayBufferCopy());\n  }\n\n  return isSharedArrayBufferToString.working\n    ? isSharedArrayBufferToString(value)\n    : value instanceof SharedArrayBufferCopy;\n}\nexports.isSharedArrayBuffer = isSharedArrayBuffer;\n\nfunction isAsyncFunction(value) {\n  return ObjectToString(value) === '[object AsyncFunction]';\n}\nexports.isAsyncFunction = isAsyncFunction;\n\nfunction isMapIterator(value) {\n  return ObjectToString(value) === '[object Map Iterator]';\n}\nexports.isMapIterator = isMapIterator;\n\nfunction isSetIterator(value) {\n  return ObjectToString(value) === '[object Set Iterator]';\n}\nexports.isSetIterator = isSetIterator;\n\nfunction isGeneratorObject(value) {\n  return ObjectToString(value) === '[object Generator]';\n}\nexports.isGeneratorObject = isGeneratorObject;\n\nfunction isWebAssemblyCompiledModule(value) {\n  return ObjectToString(value) === '[object WebAssembly.Module]';\n}\nexports.isWebAssemblyCompiledModule = isWebAssemblyCompiledModule;\n\nfunction isNumberObject(value) {\n  return checkBoxedPrimitive(value, numberValue);\n}\nexports.isNumberObject = isNumberObject;\n\nfunction isStringObject(value) {\n  return checkBoxedPrimitive(value, stringValue);\n}\nexports.isStringObject = isStringObject;\n\nfunction isBooleanObject(value) {\n  return checkBoxedPrimitive(value, booleanValue);\n}\nexports.isBooleanObject = isBooleanObject;\n\nfunction isBigIntObject(value) {\n  return BigIntSupported && checkBoxedPrimitive(value, bigIntValue);\n}\nexports.isBigIntObject = isBigIntObject;\n\nfunction isSymbolObject(value) {\n  return SymbolSupported && checkBoxedPrimitive(value, symbolValue);\n}\nexports.isSymbolObject = isSymbolObject;\n\nfunction isBoxedPrimitive(value) {\n  return (\n    isNumberObject(value) ||\n    isStringObject(value) ||\n    isBooleanObject(value) ||\n    isBigIntObject(value) ||\n    isSymbolObject(value)\n  );\n}\nexports.isBoxedPrimitive = isBoxedPrimitive;\n\nfunction isAnyArrayBuffer(value) {\n  return typeof Uint8Array !== 'undefined' && (\n    isArrayBuffer(value) ||\n    isSharedArrayBuffer(value)\n  );\n}\nexports.isAnyArrayBuffer = isAnyArrayBuffer;\n\n['isProxy', 'isExternal', 'isModuleNamespaceObject'].forEach(function(method) {\n  Object.defineProperty(exports, method, {\n    enumerable: false,\n    value: function() {\n      throw new Error(method + ' is not supported in userland');\n    }\n  });\n});\n\n\n//# sourceURL=webpack://brackets-viewer/./node_modules/util/support/types.js?");

/***/ }),

/***/ "./node_modules/util/util.js":
/*!***********************************!*\
  !*** ./node_modules/util/util.js ***!
  \***********************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("/* provided dependency */ var process = __webpack_require__(/*! process/browser */ \"./node_modules/process/browser.js\");\n// Copyright Joyent, Inc. and other Node contributors.\n//\n// Permission is hereby granted, free of charge, to any person obtaining a\n// copy of this software and associated documentation files (the\n// \"Software\"), to deal in the Software without restriction, including\n// without limitation the rights to use, copy, modify, merge, publish,\n// distribute, sublicense, and/or sell copies of the Software, and to permit\n// persons to whom the Software is furnished to do so, subject to the\n// following conditions:\n//\n// The above copyright notice and this permission notice shall be included\n// in all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS\n// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN\n// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,\n// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR\n// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE\n// USE OR OTHER DEALINGS IN THE SOFTWARE.\n\nvar getOwnPropertyDescriptors = Object.getOwnPropertyDescriptors ||\n  function getOwnPropertyDescriptors(obj) {\n    var keys = Object.keys(obj);\n    var descriptors = {};\n    for (var i = 0; i < keys.length; i++) {\n      descriptors[keys[i]] = Object.getOwnPropertyDescriptor(obj, keys[i]);\n    }\n    return descriptors;\n  };\n\nvar formatRegExp = /%[sdj%]/g;\nexports.format = function(f) {\n  if (!isString(f)) {\n    var objects = [];\n    for (var i = 0; i < arguments.length; i++) {\n      objects.push(inspect(arguments[i]));\n    }\n    return objects.join(' ');\n  }\n\n  var i = 1;\n  var args = arguments;\n  var len = args.length;\n  var str = String(f).replace(formatRegExp, function(x) {\n    if (x === '%%') return '%';\n    if (i >= len) return x;\n    switch (x) {\n      case '%s': return String(args[i++]);\n      case '%d': return Number(args[i++]);\n      case '%j':\n        try {\n          return JSON.stringify(args[i++]);\n        } catch (_) {\n          return '[Circular]';\n        }\n      default:\n        return x;\n    }\n  });\n  for (var x = args[i]; i < len; x = args[++i]) {\n    if (isNull(x) || !isObject(x)) {\n      str += ' ' + x;\n    } else {\n      str += ' ' + inspect(x);\n    }\n  }\n  return str;\n};\n\n\n// Mark that a method should not be used.\n// Returns a modified function which warns once by default.\n// If --no-deprecation is set, then it is a no-op.\nexports.deprecate = function(fn, msg) {\n  if (typeof process !== 'undefined' && process.noDeprecation === true) {\n    return fn;\n  }\n\n  // Allow for deprecating things in the process of starting up.\n  if (typeof process === 'undefined') {\n    return function() {\n      return exports.deprecate(fn, msg).apply(this, arguments);\n    };\n  }\n\n  var warned = false;\n  function deprecated() {\n    if (!warned) {\n      if (process.throwDeprecation) {\n        throw new Error(msg);\n      } else if (process.traceDeprecation) {\n        console.trace(msg);\n      } else {\n        console.error(msg);\n      }\n      warned = true;\n    }\n    return fn.apply(this, arguments);\n  }\n\n  return deprecated;\n};\n\n\nvar debugs = {};\nvar debugEnvRegex = /^$/;\n\nif (process.env.NODE_DEBUG) {\n  var debugEnv = process.env.NODE_DEBUG;\n  debugEnv = debugEnv.replace(/[|\\\\{}()[\\]^$+?.]/g, '\\\\$&')\n    .replace(/\\*/g, '.*')\n    .replace(/,/g, '$|^')\n    .toUpperCase();\n  debugEnvRegex = new RegExp('^' + debugEnv + '$', 'i');\n}\nexports.debuglog = function(set) {\n  set = set.toUpperCase();\n  if (!debugs[set]) {\n    if (debugEnvRegex.test(set)) {\n      var pid = process.pid;\n      debugs[set] = function() {\n        var msg = exports.format.apply(exports, arguments);\n        console.error('%s %d: %s', set, pid, msg);\n      };\n    } else {\n      debugs[set] = function() {};\n    }\n  }\n  return debugs[set];\n};\n\n\n/**\n * Echos the value of a value. Trys to print the value out\n * in the best way possible given the different types.\n *\n * @param {Object} obj The object to print out.\n * @param {Object} opts Optional options object that alters the output.\n */\n/* legacy: obj, showHidden, depth, colors*/\nfunction inspect(obj, opts) {\n  // default options\n  var ctx = {\n    seen: [],\n    stylize: stylizeNoColor\n  };\n  // legacy...\n  if (arguments.length >= 3) ctx.depth = arguments[2];\n  if (arguments.length >= 4) ctx.colors = arguments[3];\n  if (isBoolean(opts)) {\n    // legacy...\n    ctx.showHidden = opts;\n  } else if (opts) {\n    // got an \"options\" object\n    exports._extend(ctx, opts);\n  }\n  // set default options\n  if (isUndefined(ctx.showHidden)) ctx.showHidden = false;\n  if (isUndefined(ctx.depth)) ctx.depth = 2;\n  if (isUndefined(ctx.colors)) ctx.colors = false;\n  if (isUndefined(ctx.customInspect)) ctx.customInspect = true;\n  if (ctx.colors) ctx.stylize = stylizeWithColor;\n  return formatValue(ctx, obj, ctx.depth);\n}\nexports.inspect = inspect;\n\n\n// http://en.wikipedia.org/wiki/ANSI_escape_code#graphics\ninspect.colors = {\n  'bold' : [1, 22],\n  'italic' : [3, 23],\n  'underline' : [4, 24],\n  'inverse' : [7, 27],\n  'white' : [37, 39],\n  'grey' : [90, 39],\n  'black' : [30, 39],\n  'blue' : [34, 39],\n  'cyan' : [36, 39],\n  'green' : [32, 39],\n  'magenta' : [35, 39],\n  'red' : [31, 39],\n  'yellow' : [33, 39]\n};\n\n// Don't use 'blue' not visible on cmd.exe\ninspect.styles = {\n  'special': 'cyan',\n  'number': 'yellow',\n  'boolean': 'yellow',\n  'undefined': 'grey',\n  'null': 'bold',\n  'string': 'green',\n  'date': 'magenta',\n  // \"name\": intentionally not styling\n  'regexp': 'red'\n};\n\n\nfunction stylizeWithColor(str, styleType) {\n  var style = inspect.styles[styleType];\n\n  if (style) {\n    return '\\u001b[' + inspect.colors[style][0] + 'm' + str +\n           '\\u001b[' + inspect.colors[style][1] + 'm';\n  } else {\n    return str;\n  }\n}\n\n\nfunction stylizeNoColor(str, styleType) {\n  return str;\n}\n\n\nfunction arrayToHash(array) {\n  var hash = {};\n\n  array.forEach(function(val, idx) {\n    hash[val] = true;\n  });\n\n  return hash;\n}\n\n\nfunction formatValue(ctx, value, recurseTimes) {\n  // Provide a hook for user-specified inspect functions.\n  // Check that value is an object with an inspect function on it\n  if (ctx.customInspect &&\n      value &&\n      isFunction(value.inspect) &&\n      // Filter out the util module, it's inspect function is special\n      value.inspect !== exports.inspect &&\n      // Also filter out any prototype objects using the circular check.\n      !(value.constructor && value.constructor.prototype === value)) {\n    var ret = value.inspect(recurseTimes, ctx);\n    if (!isString(ret)) {\n      ret = formatValue(ctx, ret, recurseTimes);\n    }\n    return ret;\n  }\n\n  // Primitive types cannot have properties\n  var primitive = formatPrimitive(ctx, value);\n  if (primitive) {\n    return primitive;\n  }\n\n  // Look up the keys of the object.\n  var keys = Object.keys(value);\n  var visibleKeys = arrayToHash(keys);\n\n  if (ctx.showHidden) {\n    keys = Object.getOwnPropertyNames(value);\n  }\n\n  // IE doesn't make error fields non-enumerable\n  // http://msdn.microsoft.com/en-us/library/ie/dww52sbt(v=vs.94).aspx\n  if (isError(value)\n      && (keys.indexOf('message') >= 0 || keys.indexOf('description') >= 0)) {\n    return formatError(value);\n  }\n\n  // Some type of object without properties can be shortcutted.\n  if (keys.length === 0) {\n    if (isFunction(value)) {\n      var name = value.name ? ': ' + value.name : '';\n      return ctx.stylize('[Function' + name + ']', 'special');\n    }\n    if (isRegExp(value)) {\n      return ctx.stylize(RegExp.prototype.toString.call(value), 'regexp');\n    }\n    if (isDate(value)) {\n      return ctx.stylize(Date.prototype.toString.call(value), 'date');\n    }\n    if (isError(value)) {\n      return formatError(value);\n    }\n  }\n\n  var base = '', array = false, braces = ['{', '}'];\n\n  // Make Array say that they are Array\n  if (isArray(value)) {\n    array = true;\n    braces = ['[', ']'];\n  }\n\n  // Make functions say that they are functions\n  if (isFunction(value)) {\n    var n = value.name ? ': ' + value.name : '';\n    base = ' [Function' + n + ']';\n  }\n\n  // Make RegExps say that they are RegExps\n  if (isRegExp(value)) {\n    base = ' ' + RegExp.prototype.toString.call(value);\n  }\n\n  // Make dates with properties first say the date\n  if (isDate(value)) {\n    base = ' ' + Date.prototype.toUTCString.call(value);\n  }\n\n  // Make error with message first say the error\n  if (isError(value)) {\n    base = ' ' + formatError(value);\n  }\n\n  if (keys.length === 0 && (!array || value.length == 0)) {\n    return braces[0] + base + braces[1];\n  }\n\n  if (recurseTimes < 0) {\n    if (isRegExp(value)) {\n      return ctx.stylize(RegExp.prototype.toString.call(value), 'regexp');\n    } else {\n      return ctx.stylize('[Object]', 'special');\n    }\n  }\n\n  ctx.seen.push(value);\n\n  var output;\n  if (array) {\n    output = formatArray(ctx, value, recurseTimes, visibleKeys, keys);\n  } else {\n    output = keys.map(function(key) {\n      return formatProperty(ctx, value, recurseTimes, visibleKeys, key, array);\n    });\n  }\n\n  ctx.seen.pop();\n\n  return reduceToSingleString(output, base, braces);\n}\n\n\nfunction formatPrimitive(ctx, value) {\n  if (isUndefined(value))\n    return ctx.stylize('undefined', 'undefined');\n  if (isString(value)) {\n    var simple = '\\'' + JSON.stringify(value).replace(/^\"|\"$/g, '')\n                                             .replace(/'/g, \"\\\\'\")\n                                             .replace(/\\\\\"/g, '\"') + '\\'';\n    return ctx.stylize(simple, 'string');\n  }\n  if (isNumber(value))\n    return ctx.stylize('' + value, 'number');\n  if (isBoolean(value))\n    return ctx.stylize('' + value, 'boolean');\n  // For some reason typeof null is \"object\", so special case here.\n  if (isNull(value))\n    return ctx.stylize('null', 'null');\n}\n\n\nfunction formatError(value) {\n  return '[' + Error.prototype.toString.call(value) + ']';\n}\n\n\nfunction formatArray(ctx, value, recurseTimes, visibleKeys, keys) {\n  var output = [];\n  for (var i = 0, l = value.length; i < l; ++i) {\n    if (hasOwnProperty(value, String(i))) {\n      output.push(formatProperty(ctx, value, recurseTimes, visibleKeys,\n          String(i), true));\n    } else {\n      output.push('');\n    }\n  }\n  keys.forEach(function(key) {\n    if (!key.match(/^\\d+$/)) {\n      output.push(formatProperty(ctx, value, recurseTimes, visibleKeys,\n          key, true));\n    }\n  });\n  return output;\n}\n\n\nfunction formatProperty(ctx, value, recurseTimes, visibleKeys, key, array) {\n  var name, str, desc;\n  desc = Object.getOwnPropertyDescriptor(value, key) || { value: value[key] };\n  if (desc.get) {\n    if (desc.set) {\n      str = ctx.stylize('[Getter/Setter]', 'special');\n    } else {\n      str = ctx.stylize('[Getter]', 'special');\n    }\n  } else {\n    if (desc.set) {\n      str = ctx.stylize('[Setter]', 'special');\n    }\n  }\n  if (!hasOwnProperty(visibleKeys, key)) {\n    name = '[' + key + ']';\n  }\n  if (!str) {\n    if (ctx.seen.indexOf(desc.value) < 0) {\n      if (isNull(recurseTimes)) {\n        str = formatValue(ctx, desc.value, null);\n      } else {\n        str = formatValue(ctx, desc.value, recurseTimes - 1);\n      }\n      if (str.indexOf('\\n') > -1) {\n        if (array) {\n          str = str.split('\\n').map(function(line) {\n            return '  ' + line;\n          }).join('\\n').substr(2);\n        } else {\n          str = '\\n' + str.split('\\n').map(function(line) {\n            return '   ' + line;\n          }).join('\\n');\n        }\n      }\n    } else {\n      str = ctx.stylize('[Circular]', 'special');\n    }\n  }\n  if (isUndefined(name)) {\n    if (array && key.match(/^\\d+$/)) {\n      return str;\n    }\n    name = JSON.stringify('' + key);\n    if (name.match(/^\"([a-zA-Z_][a-zA-Z_0-9]*)\"$/)) {\n      name = name.substr(1, name.length - 2);\n      name = ctx.stylize(name, 'name');\n    } else {\n      name = name.replace(/'/g, \"\\\\'\")\n                 .replace(/\\\\\"/g, '\"')\n                 .replace(/(^\"|\"$)/g, \"'\");\n      name = ctx.stylize(name, 'string');\n    }\n  }\n\n  return name + ': ' + str;\n}\n\n\nfunction reduceToSingleString(output, base, braces) {\n  var numLinesEst = 0;\n  var length = output.reduce(function(prev, cur) {\n    numLinesEst++;\n    if (cur.indexOf('\\n') >= 0) numLinesEst++;\n    return prev + cur.replace(/\\u001b\\[\\d\\d?m/g, '').length + 1;\n  }, 0);\n\n  if (length > 60) {\n    return braces[0] +\n           (base === '' ? '' : base + '\\n ') +\n           ' ' +\n           output.join(',\\n  ') +\n           ' ' +\n           braces[1];\n  }\n\n  return braces[0] + base + ' ' + output.join(', ') + ' ' + braces[1];\n}\n\n\n// NOTE: These type checking functions intentionally don't use `instanceof`\n// because it is fragile and can be easily faked with `Object.create()`.\nexports.types = __webpack_require__(/*! ./support/types */ \"./node_modules/util/support/types.js\");\n\nfunction isArray(ar) {\n  return Array.isArray(ar);\n}\nexports.isArray = isArray;\n\nfunction isBoolean(arg) {\n  return typeof arg === 'boolean';\n}\nexports.isBoolean = isBoolean;\n\nfunction isNull(arg) {\n  return arg === null;\n}\nexports.isNull = isNull;\n\nfunction isNullOrUndefined(arg) {\n  return arg == null;\n}\nexports.isNullOrUndefined = isNullOrUndefined;\n\nfunction isNumber(arg) {\n  return typeof arg === 'number';\n}\nexports.isNumber = isNumber;\n\nfunction isString(arg) {\n  return typeof arg === 'string';\n}\nexports.isString = isString;\n\nfunction isSymbol(arg) {\n  return typeof arg === 'symbol';\n}\nexports.isSymbol = isSymbol;\n\nfunction isUndefined(arg) {\n  return arg === void 0;\n}\nexports.isUndefined = isUndefined;\n\nfunction isRegExp(re) {\n  return isObject(re) && objectToString(re) === '[object RegExp]';\n}\nexports.isRegExp = isRegExp;\nexports.types.isRegExp = isRegExp;\n\nfunction isObject(arg) {\n  return typeof arg === 'object' && arg !== null;\n}\nexports.isObject = isObject;\n\nfunction isDate(d) {\n  return isObject(d) && objectToString(d) === '[object Date]';\n}\nexports.isDate = isDate;\nexports.types.isDate = isDate;\n\nfunction isError(e) {\n  return isObject(e) &&\n      (objectToString(e) === '[object Error]' || e instanceof Error);\n}\nexports.isError = isError;\nexports.types.isNativeError = isError;\n\nfunction isFunction(arg) {\n  return typeof arg === 'function';\n}\nexports.isFunction = isFunction;\n\nfunction isPrimitive(arg) {\n  return arg === null ||\n         typeof arg === 'boolean' ||\n         typeof arg === 'number' ||\n         typeof arg === 'string' ||\n         typeof arg === 'symbol' ||  // ES6 symbol\n         typeof arg === 'undefined';\n}\nexports.isPrimitive = isPrimitive;\n\nexports.isBuffer = __webpack_require__(/*! ./support/isBuffer */ \"./node_modules/util/support/isBufferBrowser.js\");\n\nfunction objectToString(o) {\n  return Object.prototype.toString.call(o);\n}\n\n\nfunction pad(n) {\n  return n < 10 ? '0' + n.toString(10) : n.toString(10);\n}\n\n\nvar months = ['Jan', 'Feb', 'Mar', 'Apr', 'May', 'Jun', 'Jul', 'Aug', 'Sep',\n              'Oct', 'Nov', 'Dec'];\n\n// 26 Feb 16:19:34\nfunction timestamp() {\n  var d = new Date();\n  var time = [pad(d.getHours()),\n              pad(d.getMinutes()),\n              pad(d.getSeconds())].join(':');\n  return [d.getDate(), months[d.getMonth()], time].join(' ');\n}\n\n\n// log is just a thin wrapper to console.log that prepends a timestamp\nexports.log = function() {\n  console.log('%s - %s', timestamp(), exports.format.apply(exports, arguments));\n};\n\n\n/**\n * Inherit the prototype methods from one constructor into another.\n *\n * The Function.prototype.inherits from lang.js rewritten as a standalone\n * function (not on Function.prototype). NOTE: If this file is to be loaded\n * during bootstrapping this function needs to be rewritten using some native\n * functions as prototype setup using normal JavaScript does not work as\n * expected during bootstrapping (see mirror.js in r114903).\n *\n * @param {function} ctor Constructor function which needs to inherit the\n *     prototype.\n * @param {function} superCtor Constructor function to inherit prototype from.\n */\nexports.inherits = __webpack_require__(/*! inherits */ \"./node_modules/inherits/inherits_browser.js\");\n\nexports._extend = function(origin, add) {\n  // Don't do anything if add isn't an object\n  if (!add || !isObject(add)) return origin;\n\n  var keys = Object.keys(add);\n  var i = keys.length;\n  while (i--) {\n    origin[keys[i]] = add[keys[i]];\n  }\n  return origin;\n};\n\nfunction hasOwnProperty(obj, prop) {\n  return Object.prototype.hasOwnProperty.call(obj, prop);\n}\n\nvar kCustomPromisifiedSymbol = typeof Symbol !== 'undefined' ? Symbol('util.promisify.custom') : undefined;\n\nexports.promisify = function promisify(original) {\n  if (typeof original !== 'function')\n    throw new TypeError('The \"original\" argument must be of type Function');\n\n  if (kCustomPromisifiedSymbol && original[kCustomPromisifiedSymbol]) {\n    var fn = original[kCustomPromisifiedSymbol];\n    if (typeof fn !== 'function') {\n      throw new TypeError('The \"util.promisify.custom\" argument must be of type Function');\n    }\n    Object.defineProperty(fn, kCustomPromisifiedSymbol, {\n      value: fn, enumerable: false, writable: false, configurable: true\n    });\n    return fn;\n  }\n\n  function fn() {\n    var promiseResolve, promiseReject;\n    var promise = new Promise(function (resolve, reject) {\n      promiseResolve = resolve;\n      promiseReject = reject;\n    });\n\n    var args = [];\n    for (var i = 0; i < arguments.length; i++) {\n      args.push(arguments[i]);\n    }\n    args.push(function (err, value) {\n      if (err) {\n        promiseReject(err);\n      } else {\n        promiseResolve(value);\n      }\n    });\n\n    try {\n      original.apply(this, args);\n    } catch (err) {\n      promiseReject(err);\n    }\n\n    return promise;\n  }\n\n  Object.setPrototypeOf(fn, Object.getPrototypeOf(original));\n\n  if (kCustomPromisifiedSymbol) Object.defineProperty(fn, kCustomPromisifiedSymbol, {\n    value: fn, enumerable: false, writable: false, configurable: true\n  });\n  return Object.defineProperties(\n    fn,\n    getOwnPropertyDescriptors(original)\n  );\n}\n\nexports.promisify.custom = kCustomPromisifiedSymbol\n\nfunction callbackifyOnRejected(reason, cb) {\n  // `!reason` guard inspired by bluebird (Ref: https://goo.gl/t5IS6M).\n  // Because `null` is a special error value in callbacks which means \"no error\n  // occurred\", we error-wrap so the callback consumer can distinguish between\n  // \"the promise rejected with null\" or \"the promise fulfilled with undefined\".\n  if (!reason) {\n    var newReason = new Error('Promise was rejected with a falsy value');\n    newReason.reason = reason;\n    reason = newReason;\n  }\n  return cb(reason);\n}\n\nfunction callbackify(original) {\n  if (typeof original !== 'function') {\n    throw new TypeError('The \"original\" argument must be of type Function');\n  }\n\n  // We DO NOT return the promise as it gives the user a false sense that\n  // the promise is actually somehow related to the callback's execution\n  // and that the callback throwing will reject the promise.\n  function callbackified() {\n    var args = [];\n    for (var i = 0; i < arguments.length; i++) {\n      args.push(arguments[i]);\n    }\n\n    var maybeCb = args.pop();\n    if (typeof maybeCb !== 'function') {\n      throw new TypeError('The last argument must be of type Function');\n    }\n    var self = this;\n    var cb = function() {\n      return maybeCb.apply(self, arguments);\n    };\n    // In true node style we process the callback on `nextTick` with all the\n    // implications (stack, `uncaughtException`, `async_hooks`)\n    original.apply(this, args)\n      .then(function(ret) { process.nextTick(cb.bind(null, null, ret)) },\n            function(rej) { process.nextTick(callbackifyOnRejected.bind(null, rej, cb)) });\n  }\n\n  Object.setPrototypeOf(callbackified, Object.getPrototypeOf(original));\n  Object.defineProperties(callbackified,\n                          getOwnPropertyDescriptors(original));\n  return callbackified;\n}\nexports.callbackify = callbackify;\n\n\n//# sourceURL=webpack://brackets-viewer/./node_modules/util/util.js?");

/***/ }),

/***/ "./node_modules/which-typed-array/index.js":
/*!*************************************************!*\
  !*** ./node_modules/which-typed-array/index.js ***!
  \*************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("\n\nvar forEach = __webpack_require__(/*! foreach */ \"./node_modules/foreach/index.js\");\nvar availableTypedArrays = __webpack_require__(/*! available-typed-arrays */ \"./node_modules/available-typed-arrays/index.js\");\nvar callBound = __webpack_require__(/*! call-bind/callBound */ \"./node_modules/call-bind/callBound.js\");\n\nvar $toString = callBound('Object.prototype.toString');\nvar hasToStringTag = __webpack_require__(/*! has-tostringtag/shams */ \"./node_modules/has-tostringtag/shams.js\")();\n\nvar typedArrays = availableTypedArrays();\n\nvar $slice = callBound('String.prototype.slice');\nvar toStrTags = {};\nvar gOPD = __webpack_require__(/*! es-abstract/helpers/getOwnPropertyDescriptor */ \"./node_modules/es-abstract/helpers/getOwnPropertyDescriptor.js\");\nvar getPrototypeOf = Object.getPrototypeOf; // require('getprototypeof');\nif (hasToStringTag && gOPD && getPrototypeOf) {\n\tforEach(typedArrays, function (typedArray) {\n\t\tif (typeof __webpack_require__.g[typedArray] === 'function') {\n\t\t\tvar arr = new __webpack_require__.g[typedArray]();\n\t\t\tif (Symbol.toStringTag in arr) {\n\t\t\t\tvar proto = getPrototypeOf(arr);\n\t\t\t\tvar descriptor = gOPD(proto, Symbol.toStringTag);\n\t\t\t\tif (!descriptor) {\n\t\t\t\t\tvar superProto = getPrototypeOf(proto);\n\t\t\t\t\tdescriptor = gOPD(superProto, Symbol.toStringTag);\n\t\t\t\t}\n\t\t\t\ttoStrTags[typedArray] = descriptor.get;\n\t\t\t}\n\t\t}\n\t});\n}\n\nvar tryTypedArrays = function tryAllTypedArrays(value) {\n\tvar foundName = false;\n\tforEach(toStrTags, function (getter, typedArray) {\n\t\tif (!foundName) {\n\t\t\ttry {\n\t\t\t\tvar name = getter.call(value);\n\t\t\t\tif (name === typedArray) {\n\t\t\t\t\tfoundName = name;\n\t\t\t\t}\n\t\t\t} catch (e) {}\n\t\t}\n\t});\n\treturn foundName;\n};\n\nvar isTypedArray = __webpack_require__(/*! is-typed-array */ \"./node_modules/is-typed-array/index.js\");\n\nmodule.exports = function whichTypedArray(value) {\n\tif (!isTypedArray(value)) { return false; }\n\tif (!hasToStringTag || !(Symbol.toStringTag in value)) { return $slice($toString(value), 8, -1); }\n\treturn tryTypedArrays(value);\n};\n\n\n//# sourceURL=webpack://brackets-viewer/./node_modules/which-typed-array/index.js?");

/***/ }),

/***/ "?c311":
/*!********************!*\
  !*** fs (ignored) ***!
  \********************/
/***/ (() => {

eval("/* (ignored) */\n\n//# sourceURL=webpack://brackets-viewer/fs_(ignored)?");

/***/ }),

/***/ "?daec":
/*!********************!*\
  !*** fs (ignored) ***!
  \********************/
/***/ (() => {

eval("/* (ignored) */\n\n//# sourceURL=webpack://brackets-viewer/fs_(ignored)?");

/***/ }),

/***/ "./node_modules/available-typed-arrays/index.js":
/*!******************************************************!*\
  !*** ./node_modules/available-typed-arrays/index.js ***!
  \******************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("\n\nvar possibleNames = [\n\t'BigInt64Array',\n\t'BigUint64Array',\n\t'Float32Array',\n\t'Float64Array',\n\t'Int16Array',\n\t'Int32Array',\n\t'Int8Array',\n\t'Uint16Array',\n\t'Uint32Array',\n\t'Uint8Array',\n\t'Uint8ClampedArray'\n];\n\nmodule.exports = function availableTypedArrays() {\n\tvar out = [];\n\tfor (var i = 0; i < possibleNames.length; i++) {\n\t\tif (typeof __webpack_require__.g[possibleNames[i]] === 'function') {\n\t\t\tout[out.length] = possibleNames[i];\n\t\t}\n\t}\n\treturn out;\n};\n\n\n//# sourceURL=webpack://brackets-viewer/./node_modules/available-typed-arrays/index.js?");

/***/ }),

/***/ "./node_modules/es-abstract/helpers/getOwnPropertyDescriptor.js":
/*!**********************************************************************!*\
  !*** ./node_modules/es-abstract/helpers/getOwnPropertyDescriptor.js ***!
  \**********************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("\n\nvar GetIntrinsic = __webpack_require__(/*! get-intrinsic */ \"./node_modules/get-intrinsic/index.js\");\n\nvar $gOPD = GetIntrinsic('%Object.getOwnPropertyDescriptor%');\nif ($gOPD) {\n\ttry {\n\t\t$gOPD([], 'length');\n\t} catch (e) {\n\t\t// IE 8 has a broken gOPD\n\t\t$gOPD = null;\n\t}\n}\n\nmodule.exports = $gOPD;\n\n\n//# sourceURL=webpack://brackets-viewer/./node_modules/es-abstract/helpers/getOwnPropertyDescriptor.js?");

/***/ }),

/***/ "./node_modules/@babel/runtime/helpers/esm/assertThisInitialized.js":
/*!**************************************************************************!*\
  !*** ./node_modules/@babel/runtime/helpers/esm/assertThisInitialized.js ***!
  \**************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (/* binding */ _assertThisInitialized)\n/* harmony export */ });\nfunction _assertThisInitialized(self) {\n  if (self === void 0) {\n    throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\");\n  }\n\n  return self;\n}\n\n//# sourceURL=webpack://brackets-viewer/./node_modules/@babel/runtime/helpers/esm/assertThisInitialized.js?");

/***/ }),

/***/ "./node_modules/@babel/runtime/helpers/esm/classCallCheck.js":
/*!*******************************************************************!*\
  !*** ./node_modules/@babel/runtime/helpers/esm/classCallCheck.js ***!
  \*******************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (/* binding */ _classCallCheck)\n/* harmony export */ });\nfunction _classCallCheck(instance, Constructor) {\n  if (!(instance instanceof Constructor)) {\n    throw new TypeError(\"Cannot call a class as a function\");\n  }\n}\n\n//# sourceURL=webpack://brackets-viewer/./node_modules/@babel/runtime/helpers/esm/classCallCheck.js?");

/***/ }),

/***/ "./node_modules/@babel/runtime/helpers/esm/createClass.js":
/*!****************************************************************!*\
  !*** ./node_modules/@babel/runtime/helpers/esm/createClass.js ***!
  \****************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (/* binding */ _createClass)\n/* harmony export */ });\nfunction _defineProperties(target, props) {\n  for (var i = 0; i < props.length; i++) {\n    var descriptor = props[i];\n    descriptor.enumerable = descriptor.enumerable || false;\n    descriptor.configurable = true;\n    if (\"value\" in descriptor) descriptor.writable = true;\n    Object.defineProperty(target, descriptor.key, descriptor);\n  }\n}\n\nfunction _createClass(Constructor, protoProps, staticProps) {\n  if (protoProps) _defineProperties(Constructor.prototype, protoProps);\n  if (staticProps) _defineProperties(Constructor, staticProps);\n  return Constructor;\n}\n\n//# sourceURL=webpack://brackets-viewer/./node_modules/@babel/runtime/helpers/esm/createClass.js?");

/***/ }),

/***/ "./node_modules/@babel/runtime/helpers/esm/defineProperty.js":
/*!*******************************************************************!*\
  !*** ./node_modules/@babel/runtime/helpers/esm/defineProperty.js ***!
  \*******************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (/* binding */ _defineProperty)\n/* harmony export */ });\nfunction _defineProperty(obj, key, value) {\n  if (key in obj) {\n    Object.defineProperty(obj, key, {\n      value: value,\n      enumerable: true,\n      configurable: true,\n      writable: true\n    });\n  } else {\n    obj[key] = value;\n  }\n\n  return obj;\n}\n\n//# sourceURL=webpack://brackets-viewer/./node_modules/@babel/runtime/helpers/esm/defineProperty.js?");

/***/ }),

/***/ "./node_modules/@babel/runtime/helpers/esm/getPrototypeOf.js":
/*!*******************************************************************!*\
  !*** ./node_modules/@babel/runtime/helpers/esm/getPrototypeOf.js ***!
  \*******************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (/* binding */ _getPrototypeOf)\n/* harmony export */ });\nfunction _getPrototypeOf(o) {\n  _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) {\n    return o.__proto__ || Object.getPrototypeOf(o);\n  };\n  return _getPrototypeOf(o);\n}\n\n//# sourceURL=webpack://brackets-viewer/./node_modules/@babel/runtime/helpers/esm/getPrototypeOf.js?");

/***/ }),

/***/ "./node_modules/@babel/runtime/helpers/esm/inherits.js":
/*!*************************************************************!*\
  !*** ./node_modules/@babel/runtime/helpers/esm/inherits.js ***!
  \*************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (/* binding */ _inherits)\n/* harmony export */ });\n/* harmony import */ var _setPrototypeOf_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./setPrototypeOf.js */ \"./node_modules/@babel/runtime/helpers/esm/setPrototypeOf.js\");\n\nfunction _inherits(subClass, superClass) {\n  if (typeof superClass !== \"function\" && superClass !== null) {\n    throw new TypeError(\"Super expression must either be null or a function\");\n  }\n\n  subClass.prototype = Object.create(superClass && superClass.prototype, {\n    constructor: {\n      value: subClass,\n      writable: true,\n      configurable: true\n    }\n  });\n  if (superClass) (0,_setPrototypeOf_js__WEBPACK_IMPORTED_MODULE_0__.default)(subClass, superClass);\n}\n\n//# sourceURL=webpack://brackets-viewer/./node_modules/@babel/runtime/helpers/esm/inherits.js?");

/***/ }),

/***/ "./node_modules/@babel/runtime/helpers/esm/objectSpread.js":
/*!*****************************************************************!*\
  !*** ./node_modules/@babel/runtime/helpers/esm/objectSpread.js ***!
  \*****************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (/* binding */ _objectSpread)\n/* harmony export */ });\n/* harmony import */ var _defineProperty_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./defineProperty.js */ \"./node_modules/@babel/runtime/helpers/esm/defineProperty.js\");\n\nfunction _objectSpread(target) {\n  for (var i = 1; i < arguments.length; i++) {\n    var source = arguments[i] != null ? Object(arguments[i]) : {};\n    var ownKeys = Object.keys(source);\n\n    if (typeof Object.getOwnPropertySymbols === 'function') {\n      ownKeys = ownKeys.concat(Object.getOwnPropertySymbols(source).filter(function (sym) {\n        return Object.getOwnPropertyDescriptor(source, sym).enumerable;\n      }));\n    }\n\n    ownKeys.forEach(function (key) {\n      (0,_defineProperty_js__WEBPACK_IMPORTED_MODULE_0__.default)(target, key, source[key]);\n    });\n  }\n\n  return target;\n}\n\n//# sourceURL=webpack://brackets-viewer/./node_modules/@babel/runtime/helpers/esm/objectSpread.js?");

/***/ }),

/***/ "./node_modules/@babel/runtime/helpers/esm/possibleConstructorReturn.js":
/*!******************************************************************************!*\
  !*** ./node_modules/@babel/runtime/helpers/esm/possibleConstructorReturn.js ***!
  \******************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (/* binding */ _possibleConstructorReturn)\n/* harmony export */ });\n/* harmony import */ var _babel_runtime_helpers_typeof__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @babel/runtime/helpers/typeof */ \"./node_modules/@babel/runtime/helpers/esm/typeof.js\");\n/* harmony import */ var _assertThisInitialized_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./assertThisInitialized.js */ \"./node_modules/@babel/runtime/helpers/esm/assertThisInitialized.js\");\n\n\nfunction _possibleConstructorReturn(self, call) {\n  if (call && ((0,_babel_runtime_helpers_typeof__WEBPACK_IMPORTED_MODULE_0__.default)(call) === \"object\" || typeof call === \"function\")) {\n    return call;\n  } else if (call !== void 0) {\n    throw new TypeError(\"Derived constructors may only return object or undefined\");\n  }\n\n  return (0,_assertThisInitialized_js__WEBPACK_IMPORTED_MODULE_1__.default)(self);\n}\n\n//# sourceURL=webpack://brackets-viewer/./node_modules/@babel/runtime/helpers/esm/possibleConstructorReturn.js?");

/***/ }),

/***/ "./node_modules/@babel/runtime/helpers/esm/setPrototypeOf.js":
/*!*******************************************************************!*\
  !*** ./node_modules/@babel/runtime/helpers/esm/setPrototypeOf.js ***!
  \*******************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (/* binding */ _setPrototypeOf)\n/* harmony export */ });\nfunction _setPrototypeOf(o, p) {\n  _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) {\n    o.__proto__ = p;\n    return o;\n  };\n\n  return _setPrototypeOf(o, p);\n}\n\n//# sourceURL=webpack://brackets-viewer/./node_modules/@babel/runtime/helpers/esm/setPrototypeOf.js?");

/***/ }),

/***/ "./node_modules/@babel/runtime/helpers/esm/typeof.js":
/*!***********************************************************!*\
  !*** ./node_modules/@babel/runtime/helpers/esm/typeof.js ***!
  \***********************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (/* binding */ _typeof)\n/* harmony export */ });\nfunction _typeof(obj) {\n  \"@babel/helpers - typeof\";\n\n  if (typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\") {\n    _typeof = function _typeof(obj) {\n      return typeof obj;\n    };\n  } else {\n    _typeof = function _typeof(obj) {\n      return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj;\n    };\n  }\n\n  return _typeof(obj);\n}\n\n//# sourceURL=webpack://brackets-viewer/./node_modules/@babel/runtime/helpers/esm/typeof.js?");

/***/ }),

/***/ "./src/i18n/en/translation.json":
/*!**************************************!*\
  !*** ./src/i18n/en/translation.json ***!
  \**************************************/
/***/ ((module) => {

"use strict";
eval("module.exports = JSON.parse('{\"origin-hint\":{\"seed\":\"Seed {{position}}\",\"winner-bracket\":\"Loser of WB {{round}}.{{position}}\",\"winner-bracket-semi-final\":\"Loser of WB Semi {{position}}\",\"winner-bracket-final\":\"Loser of WB Final\",\"consolation-final\":\"Loser of Semi {{position}}\",\"grand-final\":\"Winner of LB Final\"},\"match-label\":{\"winner-bracket\":\"WB\",\"loser-bracket\":\"LB\",\"standard-bracket\":\"M\",\"standard-bracket-semi-final\":\"Semi {{matchNumber}}\",\"standard-bracket-final\":\"Final\",\"double-elimination\":\"{{matchPrefix}} {{roundNumber}}.{{matchNumber}}\",\"double-elimination-semi-final\":\"{{matchPrefix}} Semi {{matchNumber}}\",\"double-elimination-final\":\"{{matchPrefix}} Final\",\"consolation-final\":\"Consolation Final\",\"grand-final-single\":\"Grand Final\",\"grand-final\":\"GF Round {{roundNumber}}\"},\"match-status\":{\"locked\":\"Locked\",\"waiting\":\"Waiting\",\"ready\":\"Ready\",\"running\":\"Running\",\"completed\":\"Completed\",\"archived\":\"Archived\"},\"abbreviations\":{\"win\":\"W\",\"loss\":\"L\",\"forfeit\":\"F\",\"position\":\"P\",\"seed\":\"#\"},\"ranking\":{\"rank\":{\"text\":\"#\",\"tooltip\":\"Rank\"},\"id\":{\"text\":\"Name\",\"tooltip\":\"Name\"},\"played\":{\"text\":\"P\",\"tooltip\":\"Played\"},\"wins\":{\"text\":\"$t(abbreviations.win)\",\"tooltip\":\"Wins\"},\"draws\":{\"text\":\"D\",\"tooltip\":\"Draws\"},\"losses\":{\"text\":\"$t(abbreviations.loss)\",\"tooltip\":\"Losses\"},\"forfeits\":{\"text\":\"$t(abbreviations.forfeit)\",\"tooltip\":\"Forfeits\"},\"score-for\":{\"text\":\"SF\",\"tooltip\":\"Score For\"},\"score-against\":{\"text\":\"SA\",\"tooltip\":\"Score Against\"},\"score-difference\":{\"text\":\"+/-\",\"tooltip\":\"Score Difference\"},\"points\":{\"text\":\"Pts\",\"tooltip\":\"Points\"}},\"common\":{\"bye\":\"BYE\",\"best-of-x\":\"Bo{{x}}\",\"group-name\":\"Group {{groupNumber}}\",\"round-name\":\"Round {{roundNumber}}\",\"round-name-final\":\"Final Round\",\"round-name-winner-bracket\":\"WB Round {{roundNumber}}\",\"round-name-winner-bracket-final\":\"WB Final Round\",\"round-name-loser-bracket\":\"LB Round {{roundNumber}}\",\"round-name-loser-bracket-final\":\"LB Final Round\"},\"form-creator\":{\"stage_name_label\":\"Name your stage\",\"stage_name_placeholder\":\"Give a name for your stage\",\"stage_selector_label\":\"Select a stage\",\"team_label\":\"Name your teams\",\"team_placeholder\":\"Comma seperated List of Team Names (must be 2^n)\",\"group_label\":\"How many groups?\",\"group_placeholder\":\"How many groups do you want?\",\"seed_order_label\":\"How would you like to order your seeds?\",\"double_elimination_seed_order_placeholder\":\"Seed order for double elimination comma seperated\",\"round_robin_mode_label\":\"Which round robin mode do you like?\",\"consolation_final_label\":\"Consolation Final\",\"skip_first_round_label\":\"Skip first round\",\"grand_final_type_label\":\"Grand final type\",\"submit\":\"Create\"}}');\n\n//# sourceURL=webpack://brackets-viewer/./src/i18n/en/translation.json?");

/***/ }),

/***/ "./src/i18n/fr/translation.json":
/*!**************************************!*\
  !*** ./src/i18n/fr/translation.json ***!
  \**************************************/
/***/ ((module) => {

"use strict";
eval("module.exports = JSON.parse('{\"origin-hint\":{\"seed\":\"Seed {{position}}\",\"winner-bracket\":\"Perdant WB {{round}}.{{position}}\",\"winner-bracket-semi-final\":\"Perdant WB Semi {{position}}\",\"winner-bracket-final\":\"Perdant Finale WB\",\"consolation-final\":\"Perdant Semi {{position}}\",\"grand-final\":\"Gagnant Finale LB\"},\"match-label\":{\"winner-bracket\":\"WB\",\"loser-bracket\":\"LB\",\"standard-bracket\":\"M\",\"standard-bracket-semi-final\":\"Semi {{matchNumber}}\",\"standard-bracket-final\":\"Finale\",\"double-elimination\":\"{{matchPrefix}} {{roundNumber}}.{{matchNumber}}\",\"double-elimination-semi-final\":\"{{matchPrefix}} Semi {{matchNumber}}\",\"double-elimination-final\":\"Finale {{matchPrefix}}\",\"consolation-final\":\"Petite finale\",\"grand-final-single\":\"Grande finale\",\"grand-final\":\"GF Round {{roundNumber}}\"},\"match-status\":{\"locked\":\"Verrouillé\",\"waiting\":\"En attente\",\"ready\":\"Prêt\",\"running\":\"En cours\",\"completed\":\"Terminé\",\"archived\":\"Archivé\"},\"abbreviations\":{\"win\":\"V\",\"loss\":\"D\",\"forfeit\":\"F\",\"position\":\"P\",\"seed\":\"#\"},\"ranking\":{\"rank\":{\"text\":\"#\",\"tooltip\":\"Rang\"},\"id\":{\"text\":\"Name\",\"tooltip\":\"Nom\"},\"played\":{\"text\":\"J\",\"tooltip\":\"Joué\"},\"wins\":{\"text\":\"$t(abbreviations.win)\",\"tooltip\":\"Victoires\"},\"draws\":{\"text\":\"N\",\"tooltip\":\"Match nul\"},\"losses\":{\"text\":\"$t(abbreviations.loss)\",\"tooltip\":\"Défaites\"},\"forfeits\":{\"text\":\"$t(abbreviations.forfeit)\",\"tooltip\":\"Forfaits\"},\"score-for\":{\"text\":\"SF\",\"tooltip\":\"Score pour\"},\"score-against\":{\"text\":\"SA\",\"tooltip\":\"Score contre\"},\"score-difference\":{\"text\":\"+/-\",\"tooltip\":\"Différence de score\"},\"points\":{\"text\":\"Pts\",\"tooltip\":\"Points\"}},\"common\":{\"bye\":\"BYE\",\"best-of-x\":\"Bo{{x}}\",\"group-name\":\"Groupe {{groupNumber}}\",\"round-name\":\"Round {{roundNumber}}\",\"round-name-final\":\"Round final\",\"round-name-winner-bracket\":\"WB Round {{roundNumber}}\",\"round-name-winner-bracket-final\":\"WB Round final\",\"round-name-loser-bracket\":\"LB Round {{roundNumber}}\",\"round-name-loser-bracket-final\":\"LB Round final\"},\"form-creator\":{\"stage_name_label\":\"Name your stage\",\"stage_name_placeholder\":\"Give a name for your stage\",\"stage_selector_label\":\"Select a stage\",\"team_label\":\"Name your teams\",\"team_placeholder\":\"Comma seperated List of Team Names (must be 2^n)\",\"group_label\":\"How many groups?\",\"group_placeholder\":\"How many groups do you want?\",\"seed_order_label\":\"How would you like to order your seeds?\",\"double_elimination_seed_order_placeholder\":\"Seed order for double elimination comma seperated\",\"round_robin_mode_label\":\"Which round robin mode do you like?\",\"consolation_final_label\":\"Consolation Final\",\"skip_first_round_label\":\"Skip first round\",\"grand_final_type_label\":\"Grand final type\",\"submit\":\"Create\"}}');\n\n//# sourceURL=webpack://brackets-viewer/./src/i18n/fr/translation.json?");

/***/ })

/******/ 	});
/************************************************************************/
/******/ 	// The module cache
/******/ 	var __webpack_module_cache__ = {};
/******/ 	
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/ 		// Check if module is in cache
/******/ 		var cachedModule = __webpack_module_cache__[moduleId];
/******/ 		if (cachedModule !== undefined) {
/******/ 			return cachedModule.exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = __webpack_module_cache__[moduleId] = {
/******/ 			// no module.id needed
/******/ 			// no module.loaded needed
/******/ 			exports: {}
/******/ 		};
/******/ 	
/******/ 		// Execute the module function
/******/ 		__webpack_modules__[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/ 	
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/ 	
/************************************************************************/
/******/ 	/* webpack/runtime/define property getters */
/******/ 	(() => {
/******/ 		// define getter functions for harmony exports
/******/ 		__webpack_require__.d = (exports, definition) => {
/******/ 			for(var key in definition) {
/******/ 				if(__webpack_require__.o(definition, key) && !__webpack_require__.o(exports, key)) {
/******/ 					Object.defineProperty(exports, key, { enumerable: true, get: definition[key] });
/******/ 				}
/******/ 			}
/******/ 		};
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/global */
/******/ 	(() => {
/******/ 		__webpack_require__.g = (function() {
/******/ 			if (typeof globalThis === 'object') return globalThis;
/******/ 			try {
/******/ 				return this || new Function('return this')();
/******/ 			} catch (e) {
/******/ 				if (typeof window === 'object') return window;
/******/ 			}
/******/ 		})();
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/hasOwnProperty shorthand */
/******/ 	(() => {
/******/ 		__webpack_require__.o = (obj, prop) => (Object.prototype.hasOwnProperty.call(obj, prop))
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/make namespace object */
/******/ 	(() => {
/******/ 		// define __esModule on exports
/******/ 		__webpack_require__.r = (exports) => {
/******/ 			if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
/******/ 				Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
/******/ 			}
/******/ 			Object.defineProperty(exports, '__esModule', { value: true });
/******/ 		};
/******/ 	})();
/******/ 	
/************************************************************************/
/******/ 	
/******/ 	// startup
/******/ 	// Load entry module and return exports
/******/ 	// This entry module is referenced by other modules so it can't be inlined
/******/ 	var __webpack_exports__ = __webpack_require__("./src/main.ts");
/******/ 	
/******/ })()
;